/*! For license information please see imagemin.min.js.LICENSE.txt */
module.exports = (() => {
  var __webpack_modules__ = {
      8185: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0);
        const n = r(7147);
        (t.FILE_SYSTEM_ADAPTER = {
          lstat: n.lstat,
          stat: n.stat,
          lstatSync: n.lstatSync,
          statSync: n.statSync,
          readdir: n.readdir,
          readdirSync: n.readdirSync,
        }),
          (t.createFileSystemAdapter = function (e) {
            return void 0 === e
              ? t.FILE_SYSTEM_ADAPTER
              : Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), e);
          });
      },
      1107: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0);
        const r = process.versions.node.split(".");
        if (void 0 === r[0] || void 0 === r[1])
          throw new Error(
            `Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`
          );
        const n = Number.parseInt(r[0], 10),
          i = Number.parseInt(r[1], 10),
          o = n > 10,
          s = 10 === n && i >= 10;
        t.IS_SUPPORT_READDIR_WITH_FILE_TYPES = o || s;
      },
      5923: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Settings = t.scandirSync = t.scandir = void 0);
        const n = r(1411),
          i = r(3953),
          o = r(6913);
        function s(e = {}) {
          return e instanceof o.default ? e : new o.default(e);
        }
        (t.Settings = o.default),
          (t.scandir = function (e, t, r) {
            "function" != typeof t ? n.read(e, s(t), r) : n.read(e, s(), t);
          }),
          (t.scandirSync = function (e, t) {
            const r = s(t);
            return i.read(e, r);
          });
      },
      1411: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.readdir = t.readdirWithFileTypes = t.read = void 0);
        const n = r(6203),
          i = r(4595),
          o = r(1107),
          s = r(6582),
          a = r(4587);
        function c(e, t, r) {
          t.fs.readdir(e, { withFileTypes: !0 }, (n, o) => {
            if (null !== n) return void l(r, n);
            const c = o.map((r) => ({
              dirent: r,
              name: r.name,
              path: a.joinPathSegments(e, r.name, t.pathSegmentSeparator),
            }));
            if (!t.followSymbolicLinks) return void d(r, c);
            const u = c.map((e) =>
              (function (e, t) {
                return (r) => {
                  e.dirent.isSymbolicLink()
                    ? t.fs.stat(e.path, (n, i) => {
                        if (null !== n)
                          return t.throwErrorOnBrokenSymbolicLink
                            ? void r(n)
                            : void r(null, e);
                        (e.dirent = s.fs.createDirentFromStats(e.name, i)),
                          r(null, e);
                      })
                    : r(null, e);
                };
              })(e, t)
            );
            i(u, (e, t) => {
              null === e ? d(r, t) : l(r, e);
            });
          });
        }
        function u(e, t, r) {
          t.fs.readdir(e, (o, c) => {
            if (null !== o) return void l(r, o);
            const u = c.map((r) => {
              const i = a.joinPathSegments(e, r, t.pathSegmentSeparator);
              return (e) => {
                n.stat(i, t.fsStatSettings, (n, o) => {
                  if (null !== n) return void e(n);
                  const a = {
                    name: r,
                    path: i,
                    dirent: s.fs.createDirentFromStats(r, o),
                  };
                  t.stats && (a.stats = o), e(null, a);
                });
              };
            });
            i(u, (e, t) => {
              null === e ? d(r, t) : l(r, e);
            });
          });
        }
        function l(e, t) {
          e(t);
        }
        function d(e, t) {
          e(null, t);
        }
        (t.read = function (e, t, r) {
          t.stats || !o.IS_SUPPORT_READDIR_WITH_FILE_TYPES
            ? u(e, t, r)
            : c(e, t, r);
        }),
          (t.readdirWithFileTypes = c),
          (t.readdir = u);
      },
      4587: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.joinPathSegments = void 0),
          (t.joinPathSegments = function (e, t, r) {
            return e.endsWith(r) ? e + t : e + r + t;
          });
      },
      3953: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.readdir = t.readdirWithFileTypes = t.read = void 0);
        const n = r(6203),
          i = r(1107),
          o = r(6582),
          s = r(4587);
        function a(e, t) {
          return t.fs.readdirSync(e, { withFileTypes: !0 }).map((r) => {
            const n = {
              dirent: r,
              name: r.name,
              path: s.joinPathSegments(e, r.name, t.pathSegmentSeparator),
            };
            if (n.dirent.isSymbolicLink() && t.followSymbolicLinks)
              try {
                const e = t.fs.statSync(n.path);
                n.dirent = o.fs.createDirentFromStats(n.name, e);
              } catch (e) {
                if (t.throwErrorOnBrokenSymbolicLink) throw e;
              }
            return n;
          });
        }
        function c(e, t) {
          return t.fs.readdirSync(e).map((r) => {
            const i = s.joinPathSegments(e, r, t.pathSegmentSeparator),
              a = n.statSync(i, t.fsStatSettings),
              c = {
                name: r,
                path: i,
                dirent: o.fs.createDirentFromStats(r, a),
              };
            return t.stats && (c.stats = a), c;
          });
        }
        (t.read = function (e, t) {
          return !t.stats && i.IS_SUPPORT_READDIR_WITH_FILE_TYPES
            ? a(e, t)
            : c(e, t);
        }),
          (t.readdirWithFileTypes = a),
          (t.readdir = c);
      },
      6913: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(1017),
          i = r(6203),
          o = r(8185);
        t.default = class {
          constructor(e = {}) {
            (this._options = e),
              (this.followSymbolicLinks = this._getValue(
                this._options.followSymbolicLinks,
                !1
              )),
              (this.fs = o.createFileSystemAdapter(this._options.fs)),
              (this.pathSegmentSeparator = this._getValue(
                this._options.pathSegmentSeparator,
                n.sep
              )),
              (this.stats = this._getValue(this._options.stats, !1)),
              (this.throwErrorOnBrokenSymbolicLink = this._getValue(
                this._options.throwErrorOnBrokenSymbolicLink,
                !0
              )),
              (this.fsStatSettings = new i.Settings({
                followSymbolicLink: this.followSymbolicLinks,
                fs: this.fs,
                throwErrorOnBrokenSymbolicLink:
                  this.throwErrorOnBrokenSymbolicLink,
              }));
          }
          _getValue(e, t) {
            return null != e ? e : t;
          }
        };
      },
      322: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createDirentFromStats = void 0);
        class r {
          constructor(e, t) {
            (this.name = e),
              (this.isBlockDevice = t.isBlockDevice.bind(t)),
              (this.isCharacterDevice = t.isCharacterDevice.bind(t)),
              (this.isDirectory = t.isDirectory.bind(t)),
              (this.isFIFO = t.isFIFO.bind(t)),
              (this.isFile = t.isFile.bind(t)),
              (this.isSocket = t.isSocket.bind(t)),
              (this.isSymbolicLink = t.isSymbolicLink.bind(t));
          }
        }
        t.createDirentFromStats = function (e, t) {
          return new r(e, t);
        };
      },
      6582: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.fs = void 0);
        const n = r(322);
        t.fs = n;
      },
      8980: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0);
        const n = r(7147);
        (t.FILE_SYSTEM_ADAPTER = {
          lstat: n.lstat,
          stat: n.stat,
          lstatSync: n.lstatSync,
          statSync: n.statSync,
        }),
          (t.createFileSystemAdapter = function (e) {
            return void 0 === e
              ? t.FILE_SYSTEM_ADAPTER
              : Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), e);
          });
      },
      6203: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.statSync = t.stat = t.Settings = void 0);
        const n = r(2654),
          i = r(8946),
          o = r(8328);
        function s(e = {}) {
          return e instanceof o.default ? e : new o.default(e);
        }
        (t.Settings = o.default),
          (t.stat = function (e, t, r) {
            "function" != typeof t ? n.read(e, s(t), r) : n.read(e, s(), t);
          }),
          (t.statSync = function (e, t) {
            const r = s(t);
            return i.read(e, r);
          });
      },
      2654: (e, t) => {
        "use strict";
        function r(e, t) {
          e(t);
        }
        function n(e, t) {
          e(null, t);
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.read = void 0),
          (t.read = function (e, t, i) {
            t.fs.lstat(e, (o, s) => {
              null === o
                ? s.isSymbolicLink() && t.followSymbolicLink
                  ? t.fs.stat(e, (e, o) => {
                      if (null !== e)
                        return t.throwErrorOnBrokenSymbolicLink
                          ? void r(i, e)
                          : void n(i, s);
                      t.markSymbolicLink && (o.isSymbolicLink = () => !0),
                        n(i, o);
                    })
                  : n(i, s)
                : r(i, o);
            });
          });
      },
      8946: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.read = void 0),
          (t.read = function (e, t) {
            const r = t.fs.lstatSync(e);
            if (!r.isSymbolicLink() || !t.followSymbolicLink) return r;
            try {
              const r = t.fs.statSync(e);
              return t.markSymbolicLink && (r.isSymbolicLink = () => !0), r;
            } catch (e) {
              if (!t.throwErrorOnBrokenSymbolicLink) return r;
              throw e;
            }
          });
      },
      8328: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(8980);
        t.default = class {
          constructor(e = {}) {
            (this._options = e),
              (this.followSymbolicLink = this._getValue(
                this._options.followSymbolicLink,
                !0
              )),
              (this.fs = n.createFileSystemAdapter(this._options.fs)),
              (this.markSymbolicLink = this._getValue(
                this._options.markSymbolicLink,
                !1
              )),
              (this.throwErrorOnBrokenSymbolicLink = this._getValue(
                this._options.throwErrorOnBrokenSymbolicLink,
                !0
              ));
          }
          _getValue(e, t) {
            return null != e ? e : t;
          }
        };
      },
      5439: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Settings = t.walkStream = t.walkSync = t.walk = void 0);
        const n = r(9346),
          i = r(215),
          o = r(4078),
          s = r(8690);
        function a(e = {}) {
          return e instanceof s.default ? e : new s.default(e);
        }
        (t.Settings = s.default),
          (t.walk = function (e, t, r) {
            "function" != typeof t
              ? new n.default(e, a(t)).read(r)
              : new n.default(e, a()).read(t);
          }),
          (t.walkSync = function (e, t) {
            const r = a(t);
            return new o.default(e, r).read();
          }),
          (t.walkStream = function (e, t) {
            const r = a(t);
            return new i.default(e, r).read();
          });
      },
      9346: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(4714);
        t.default = class {
          constructor(e, t) {
            (this._root = e),
              (this._settings = t),
              (this._reader = new n.default(this._root, this._settings)),
              (this._storage = []);
          }
          read(e) {
            this._reader.onError((t) => {
              !(function (e, t) {
                e(t);
              })(e, t);
            }),
              this._reader.onEntry((e) => {
                this._storage.push(e);
              }),
              this._reader.onEnd(() => {
                !(function (e, t) {
                  e(null, t);
                })(e, this._storage);
              }),
              this._reader.read();
          }
        };
      },
      215: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(2781),
          i = r(4714);
        t.default = class {
          constructor(e, t) {
            (this._root = e),
              (this._settings = t),
              (this._reader = new i.default(this._root, this._settings)),
              (this._stream = new n.Readable({
                objectMode: !0,
                read: () => {},
                destroy: () => {
                  this._reader.isDestroyed || this._reader.destroy();
                },
              }));
          }
          read() {
            return (
              this._reader.onError((e) => {
                this._stream.emit("error", e);
              }),
              this._reader.onEntry((e) => {
                this._stream.push(e);
              }),
              this._reader.onEnd(() => {
                this._stream.push(null);
              }),
              this._reader.read(),
              this._stream
            );
          }
        };
      },
      4078: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(9555);
        t.default = class {
          constructor(e, t) {
            (this._root = e),
              (this._settings = t),
              (this._reader = new n.default(this._root, this._settings));
          }
          read() {
            return this._reader.read();
          }
        };
      },
      4714: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(2361),
          i = r(5923),
          o = r(373),
          s = r(6865),
          a = r(5274);
        class c extends a.default {
          constructor(e, t) {
            super(e, t),
              (this._settings = t),
              (this._scandir = i.scandir),
              (this._emitter = new n.EventEmitter()),
              (this._queue = o(
                this._worker.bind(this),
                this._settings.concurrency
              )),
              (this._isFatalError = !1),
              (this._isDestroyed = !1),
              (this._queue.drain = () => {
                this._isFatalError || this._emitter.emit("end");
              });
          }
          read() {
            return (
              (this._isFatalError = !1),
              (this._isDestroyed = !1),
              setImmediate(() => {
                this._pushToQueue(this._root, this._settings.basePath);
              }),
              this._emitter
            );
          }
          get isDestroyed() {
            return this._isDestroyed;
          }
          destroy() {
            if (this._isDestroyed)
              throw new Error("The reader is already destroyed");
            (this._isDestroyed = !0), this._queue.killAndDrain();
          }
          onEntry(e) {
            this._emitter.on("entry", e);
          }
          onError(e) {
            this._emitter.once("error", e);
          }
          onEnd(e) {
            this._emitter.once("end", e);
          }
          _pushToQueue(e, t) {
            const r = { directory: e, base: t };
            this._queue.push(r, (e) => {
              null !== e && this._handleError(e);
            });
          }
          _worker(e, t) {
            this._scandir(
              e.directory,
              this._settings.fsScandirSettings,
              (r, n) => {
                if (null === r) {
                  for (const t of n) this._handleEntry(t, e.base);
                  t(null, void 0);
                } else t(r, void 0);
              }
            );
          }
          _handleError(e) {
            !this._isDestroyed &&
              s.isFatalError(this._settings, e) &&
              ((this._isFatalError = !0),
              (this._isDestroyed = !0),
              this._emitter.emit("error", e));
          }
          _handleEntry(e, t) {
            if (this._isDestroyed || this._isFatalError) return;
            const r = e.path;
            void 0 !== t &&
              (e.path = s.joinPathSegments(
                t,
                e.name,
                this._settings.pathSegmentSeparator
              )),
              s.isAppliedFilter(this._settings.entryFilter, e) &&
                this._emitEntry(e),
              e.dirent.isDirectory() &&
                s.isAppliedFilter(this._settings.deepFilter, e) &&
                this._pushToQueue(r, void 0 === t ? void 0 : e.path);
          }
          _emitEntry(e) {
            this._emitter.emit("entry", e);
          }
        }
        t.default = c;
      },
      6865: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.joinPathSegments =
            t.replacePathSegmentSeparator =
            t.isAppliedFilter =
            t.isFatalError =
              void 0),
          (t.isFatalError = function (e, t) {
            return null === e.errorFilter || !e.errorFilter(t);
          }),
          (t.isAppliedFilter = function (e, t) {
            return null === e || e(t);
          }),
          (t.replacePathSegmentSeparator = function (e, t) {
            return e.split(/[/\\]/).join(t);
          }),
          (t.joinPathSegments = function (e, t, r) {
            return "" === e ? t : e.endsWith(r) ? e + t : e + r + t;
          });
      },
      5274: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(6865);
        t.default = class {
          constructor(e, t) {
            (this._root = e),
              (this._settings = t),
              (this._root = n.replacePathSegmentSeparator(
                e,
                t.pathSegmentSeparator
              ));
          }
        };
      },
      9555: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(5923),
          i = r(6865),
          o = r(5274);
        class s extends o.default {
          constructor() {
            super(...arguments),
              (this._scandir = n.scandirSync),
              (this._storage = []),
              (this._queue = new Set());
          }
          read() {
            return (
              this._pushToQueue(this._root, this._settings.basePath),
              this._handleQueue(),
              this._storage
            );
          }
          _pushToQueue(e, t) {
            this._queue.add({ directory: e, base: t });
          }
          _handleQueue() {
            for (const e of this._queue.values())
              this._handleDirectory(e.directory, e.base);
          }
          _handleDirectory(e, t) {
            try {
              const r = this._scandir(e, this._settings.fsScandirSettings);
              for (const e of r) this._handleEntry(e, t);
            } catch (e) {
              this._handleError(e);
            }
          }
          _handleError(e) {
            if (i.isFatalError(this._settings, e)) throw e;
          }
          _handleEntry(e, t) {
            const r = e.path;
            void 0 !== t &&
              (e.path = i.joinPathSegments(
                t,
                e.name,
                this._settings.pathSegmentSeparator
              )),
              i.isAppliedFilter(this._settings.entryFilter, e) &&
                this._pushToStorage(e),
              e.dirent.isDirectory() &&
                i.isAppliedFilter(this._settings.deepFilter, e) &&
                this._pushToQueue(r, void 0 === t ? void 0 : e.path);
          }
          _pushToStorage(e) {
            this._storage.push(e);
          }
        }
        t.default = s;
      },
      8690: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(1017),
          i = r(5923);
        t.default = class {
          constructor(e = {}) {
            (this._options = e),
              (this.basePath = this._getValue(this._options.basePath, void 0)),
              (this.concurrency = this._getValue(
                this._options.concurrency,
                Number.POSITIVE_INFINITY
              )),
              (this.deepFilter = this._getValue(
                this._options.deepFilter,
                null
              )),
              (this.entryFilter = this._getValue(
                this._options.entryFilter,
                null
              )),
              (this.errorFilter = this._getValue(
                this._options.errorFilter,
                null
              )),
              (this.pathSegmentSeparator = this._getValue(
                this._options.pathSegmentSeparator,
                n.sep
              )),
              (this.fsScandirSettings = new i.Settings({
                followSymbolicLinks: this._options.followSymbolicLinks,
                fs: this._options.fs,
                pathSegmentSeparator: this._options.pathSegmentSeparator,
                stats: this._options.stats,
                throwErrorOnBrokenSymbolicLink:
                  this._options.throwErrorOnBrokenSymbolicLink,
              }));
          }
          _getValue(e, t) {
            return null != e ? e : t;
          }
        };
      },
      2563: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 });
        const i = n(r(9689)),
          o = n(r(2172)),
          s = n(r(7354));
        e.exports = {
          imagemin: i.default,
          imageminMozjpeg: o.default,
          imageminPngquant: s.default,
        };
      },
      561: (e, t, r) => {
        "use strict";
        const n = r(7147),
          i = r(1017),
          o = r(7310),
          s = r(2352),
          a = r(6991)(r(5937)),
          c = a("bin-check"),
          u = a("bin-version-check"),
          l = a("download"),
          d = a("os-filter-obj"),
          p = s(n.stat),
          f = s(n.chmod);
        e.exports = class {
          constructor(e = {}) {
            (this.options = e),
              this.options.strip <= 0
                ? (this.options.strip = 0)
                : this.options.strip || (this.options.strip = 1);
          }
          src(e, t, r) {
            return 0 === arguments.length
              ? this._src
              : ((this._src = this._src || []),
                this._src.push({ url: e, os: t, arch: r }),
                this);
          }
          dest(e) {
            return 0 === arguments.length
              ? this._dest
              : ((this._dest = e), this);
          }
          use(e) {
            return 0 === arguments.length ? this._use : ((this._use = e), this);
          }
          version(e) {
            return 0 === arguments.length
              ? this._version
              : ((this._version = e), this);
          }
          path() {
            return i.join(this.dest(), this.use());
          }
          run(e = ["--version"]) {
            return this.findExisting().then(() => {
              if (!this.options.skipCheck) return this.runCheck(e);
            });
          }
          runCheck(e) {
            return c(this.path(), e).then((e) => {
              if (!e)
                throw new Error(
                  `The \`${this.path()}\` binary doesn't seem to work correctly`
                );
              return this.version()
                ? u(this.path(), this.version())
                : Promise.resolve();
            });
          }
          findExisting() {
            return p(this.path()).catch((e) =>
              e && "ENOENT" === e.code ? this.download() : Promise.reject(e)
            );
          }
          download() {
            const e = d(this.src() || []),
              t = [];
            return 0 === e.length
              ? Promise.reject(
                  new Error(
                    "No binary found matching your system. It's probably not supported."
                  )
                )
              : (e.forEach((e) => t.push(e.url)),
                Promise.all(
                  t.map((e) =>
                    l(e, this.dest(), {
                      extract: !0,
                      strip: this.options.strip,
                    })
                  )
                ).then((t) => {
                  const r = t
                    .map((t, r) => {
                      if (Array.isArray(t)) return t.map((e) => e.path);
                      const n = o.parse(e[r].url);
                      return i.parse(n.pathname).base;
                    })
                    .reduce(
                      (e, t) => (
                        Array.isArray(t) ? e.push(...t) : e.push(t), e
                      ),
                      []
                    );
                  return Promise.all(
                    r.map((e) => f(i.join(this.dest(), e), 493))
                  );
                }));
          }
        };
      },
      5937: (e) => {
        function t(e) {
          var t = new Error("Cannot find module '" + e + "'");
          throw ((t.code = "MODULE_NOT_FOUND"), t);
        }
        (t.keys = () => []), (t.resolve = t), (t.id = 5937), (e.exports = t);
      },
      6744: (e, t, r) => {
        "use strict";
        const n = r(3349),
          i = r(7529),
          o = r(8050),
          s = r(4339),
          a = (e, t = {}) => {
            let r = [];
            if (Array.isArray(e))
              for (let n of e) {
                let e = a.create(n, t);
                Array.isArray(e) ? r.push(...e) : r.push(e);
              }
            else r = [].concat(a.create(e, t));
            return (
              t && !0 === t.expand && !0 === t.nodupes && (r = [...new Set(r)]),
              r
            );
          };
        (a.parse = (e, t = {}) => s(e, t)),
          (a.stringify = (e, t = {}) =>
            n("string" == typeof e ? a.parse(e, t) : e, t)),
          (a.compile = (e, t = {}) => (
            "string" == typeof e && (e = a.parse(e, t)), i(e, t)
          )),
          (a.expand = (e, t = {}) => {
            "string" == typeof e && (e = a.parse(e, t));
            let r = o(e, t);
            return (
              !0 === t.noempty && (r = r.filter(Boolean)),
              !0 === t.nodupes && (r = [...new Set(r)]),
              r
            );
          }),
          (a.create = (e, t = {}) =>
            "" === e || e.length < 3
              ? [e]
              : !0 !== t.expand
              ? a.compile(e, t)
              : a.expand(e, t)),
          (e.exports = a);
      },
      7529: (e, t, r) => {
        "use strict";
        const n = r(2664),
          i = r(3083);
        e.exports = (e, t = {}) => {
          let r = (e, o = {}) => {
            let s = i.isInvalidBrace(o),
              a = !0 === e.invalid && !0 === t.escapeInvalid,
              c = !0 === s || !0 === a,
              u = !0 === t.escapeInvalid ? "\\" : "",
              l = "";
            if (!0 === e.isOpen) return u + e.value;
            if (!0 === e.isClose) return u + e.value;
            if ("open" === e.type) return c ? u + e.value : "(";
            if ("close" === e.type) return c ? u + e.value : ")";
            if ("comma" === e.type)
              return "comma" === e.prev.type ? "" : c ? e.value : "|";
            if (e.value) return e.value;
            if (e.nodes && e.ranges > 0) {
              let r = i.reduce(e.nodes),
                o = n(...r, { ...t, wrap: !1, toRegex: !0 });
              if (0 !== o.length)
                return r.length > 1 && o.length > 1 ? `(${o})` : o;
            }
            if (e.nodes) for (let t of e.nodes) l += r(t, e);
            return l;
          };
          return r(e);
        };
      },
      6611: (e) => {
        "use strict";
        e.exports = {
          MAX_LENGTH: 65536,
          CHAR_0: "0",
          CHAR_9: "9",
          CHAR_UPPERCASE_A: "A",
          CHAR_LOWERCASE_A: "a",
          CHAR_UPPERCASE_Z: "Z",
          CHAR_LOWERCASE_Z: "z",
          CHAR_LEFT_PARENTHESES: "(",
          CHAR_RIGHT_PARENTHESES: ")",
          CHAR_ASTERISK: "*",
          CHAR_AMPERSAND: "&",
          CHAR_AT: "@",
          CHAR_BACKSLASH: "\\",
          CHAR_BACKTICK: "`",
          CHAR_CARRIAGE_RETURN: "\r",
          CHAR_CIRCUMFLEX_ACCENT: "^",
          CHAR_COLON: ":",
          CHAR_COMMA: ",",
          CHAR_DOLLAR: "$",
          CHAR_DOT: ".",
          CHAR_DOUBLE_QUOTE: '"',
          CHAR_EQUAL: "=",
          CHAR_EXCLAMATION_MARK: "!",
          CHAR_FORM_FEED: "\f",
          CHAR_FORWARD_SLASH: "/",
          CHAR_HASH: "#",
          CHAR_HYPHEN_MINUS: "-",
          CHAR_LEFT_ANGLE_BRACKET: "<",
          CHAR_LEFT_CURLY_BRACE: "{",
          CHAR_LEFT_SQUARE_BRACKET: "[",
          CHAR_LINE_FEED: "\n",
          CHAR_NO_BREAK_SPACE: "Â ",
          CHAR_PERCENT: "%",
          CHAR_PLUS: "+",
          CHAR_QUESTION_MARK: "?",
          CHAR_RIGHT_ANGLE_BRACKET: ">",
          CHAR_RIGHT_CURLY_BRACE: "}",
          CHAR_RIGHT_SQUARE_BRACKET: "]",
          CHAR_SEMICOLON: ";",
          CHAR_SINGLE_QUOTE: "'",
          CHAR_SPACE: " ",
          CHAR_TAB: "\t",
          CHAR_UNDERSCORE: "_",
          CHAR_VERTICAL_LINE: "|",
          CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\ufeff",
        };
      },
      8050: (e, t, r) => {
        "use strict";
        const n = r(2664),
          i = r(3349),
          o = r(3083),
          s = (e = "", t = "", r = !1) => {
            let n = [];
            if (((e = [].concat(e)), !(t = [].concat(t)).length)) return e;
            if (!e.length) return r ? o.flatten(t).map((e) => `{${e}}`) : t;
            for (let i of e)
              if (Array.isArray(i)) for (let e of i) n.push(s(e, t, r));
              else
                for (let e of t)
                  !0 === r && "string" == typeof e && (e = `{${e}}`),
                    n.push(Array.isArray(e) ? s(i, e, r) : i + e);
            return o.flatten(n);
          };
        e.exports = (e, t = {}) => {
          let r = void 0 === t.rangeLimit ? 1e3 : t.rangeLimit,
            a = (e, c = {}) => {
              e.queue = [];
              let u = c,
                l = c.queue;
              for (; "brace" !== u.type && "root" !== u.type && u.parent; )
                (u = u.parent), (l = u.queue);
              if (e.invalid || e.dollar)
                return void l.push(s(l.pop(), i(e, t)));
              if (
                "brace" === e.type &&
                !0 !== e.invalid &&
                2 === e.nodes.length
              )
                return void l.push(s(l.pop(), ["{}"]));
              if (e.nodes && e.ranges > 0) {
                let a = o.reduce(e.nodes);
                if (o.exceedsLimit(...a, t.step, r))
                  throw new RangeError(
                    "expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit."
                  );
                let c = n(...a, t);
                return (
                  0 === c.length && (c = i(e, t)),
                  l.push(s(l.pop(), c)),
                  void (e.nodes = [])
                );
              }
              let d = o.encloseBrace(e),
                p = e.queue,
                f = e;
              for (; "brace" !== f.type && "root" !== f.type && f.parent; )
                (f = f.parent), (p = f.queue);
              for (let t = 0; t < e.nodes.length; t++) {
                let r = e.nodes[t];
                "comma" !== r.type || "brace" !== e.type
                  ? "close" !== r.type
                    ? r.value && "open" !== r.type
                      ? p.push(s(p.pop(), r.value))
                      : r.nodes && a(r, e)
                    : l.push(s(l.pop(), p, d))
                  : (1 === t && p.push(""), p.push(""));
              }
              return p;
            };
          return o.flatten(a(e));
        };
      },
      4339: (e, t, r) => {
        "use strict";
        const n = r(3349),
          {
            MAX_LENGTH: i,
            CHAR_BACKSLASH: o,
            CHAR_BACKTICK: s,
            CHAR_COMMA: a,
            CHAR_DOT: c,
            CHAR_LEFT_PARENTHESES: u,
            CHAR_RIGHT_PARENTHESES: l,
            CHAR_LEFT_CURLY_BRACE: d,
            CHAR_RIGHT_CURLY_BRACE: p,
            CHAR_LEFT_SQUARE_BRACKET: f,
            CHAR_RIGHT_SQUARE_BRACKET: m,
            CHAR_DOUBLE_QUOTE: h,
            CHAR_SINGLE_QUOTE: g,
            CHAR_NO_BREAK_SPACE: y,
            CHAR_ZERO_WIDTH_NOBREAK_SPACE: b,
          } = r(6611);
        e.exports = (e, t = {}) => {
          if ("string" != typeof e) throw new TypeError("Expected a string");
          let r = t || {},
            _ = "number" == typeof r.maxLength ? Math.min(i, r.maxLength) : i;
          if (e.length > _)
            throw new SyntaxError(
              `Input length (${e.length}), exceeds max characters (${_})`
            );
          let v,
            x = { type: "root", input: e, nodes: [] },
            S = [x],
            E = x,
            w = x,
            A = 0,
            O = e.length,
            P = 0,
            $ = 0;
          const T = () => e[P++],
            k = (e) => {
              if (
                ("text" === e.type && "dot" === w.type && (w.type = "text"),
                !w || "text" !== w.type || "text" !== e.type)
              )
                return (
                  E.nodes.push(e), (e.parent = E), (e.prev = w), (w = e), e
                );
              w.value += e.value;
            };
          for (k({ type: "bos" }); P < O; )
            if (((E = S[S.length - 1]), (v = T()), v !== b && v !== y))
              if (v !== o)
                if (v !== m)
                  if (v !== f)
                    if (v !== u)
                      if (v !== l)
                        if (v !== h && v !== g && v !== s)
                          if (v !== d)
                            if (v !== p)
                              if (v === a && $ > 0) {
                                if (E.ranges > 0) {
                                  E.ranges = 0;
                                  let e = E.nodes.shift();
                                  E.nodes = [e, { type: "text", value: n(E) }];
                                }
                                k({ type: "comma", value: v }), E.commas++;
                              } else if (v === c && $ > 0 && 0 === E.commas) {
                                let e = E.nodes;
                                if (0 === $ || 0 === e.length) {
                                  k({ type: "text", value: v });
                                  continue;
                                }
                                if ("dot" === w.type) {
                                  if (
                                    ((E.range = []),
                                    (w.value += v),
                                    (w.type = "range"),
                                    3 !== E.nodes.length &&
                                      5 !== E.nodes.length)
                                  ) {
                                    (E.invalid = !0),
                                      (E.ranges = 0),
                                      (w.type = "text");
                                    continue;
                                  }
                                  E.ranges++, (E.args = []);
                                  continue;
                                }
                                if ("range" === w.type) {
                                  e.pop();
                                  let t = e[e.length - 1];
                                  (t.value += w.value + v), (w = t), E.ranges--;
                                  continue;
                                }
                                k({ type: "dot", value: v });
                              } else k({ type: "text", value: v });
                            else {
                              if ("brace" !== E.type) {
                                k({ type: "text", value: v });
                                continue;
                              }
                              let e = "close";
                              (E = S.pop()),
                                (E.close = !0),
                                k({ type: e, value: v }),
                                $--,
                                (E = S[S.length - 1]);
                            }
                          else {
                            $++;
                            let e =
                              (w.value && "$" === w.value.slice(-1)) ||
                              !0 === E.dollar;
                            (E = k({
                              type: "brace",
                              open: !0,
                              close: !1,
                              dollar: e,
                              depth: $,
                              commas: 0,
                              ranges: 0,
                              nodes: [],
                            })),
                              S.push(E),
                              k({ type: "open", value: v });
                          }
                        else {
                          let e,
                            r = v;
                          for (
                            !0 !== t.keepQuotes && (v = "");
                            P < O && (e = T());

                          )
                            if (e !== o) {
                              if (e === r) {
                                !0 === t.keepQuotes && (v += e);
                                break;
                              }
                              v += e;
                            } else v += e + T();
                          k({ type: "text", value: v });
                        }
                      else {
                        if ("paren" !== E.type) {
                          k({ type: "text", value: v });
                          continue;
                        }
                        (E = S.pop()),
                          k({ type: "text", value: v }),
                          (E = S[S.length - 1]);
                      }
                    else
                      (E = k({ type: "paren", nodes: [] })),
                        S.push(E),
                        k({ type: "text", value: v });
                  else {
                    let e;
                    for (A++; P < O && (e = T()); )
                      if (((v += e), e !== f))
                        if (e !== o) {
                          if (e === m && (A--, 0 === A)) break;
                        } else v += T();
                      else A++;
                    k({ type: "text", value: v });
                  }
                else k({ type: "text", value: "\\" + v });
              else k({ type: "text", value: (t.keepEscaping ? v : "") + T() });
          do {
            if (((E = S.pop()), "root" !== E.type)) {
              E.nodes.forEach((e) => {
                e.nodes ||
                  ("open" === e.type && (e.isOpen = !0),
                  "close" === e.type && (e.isClose = !0),
                  e.nodes || (e.type = "text"),
                  (e.invalid = !0));
              });
              let e = S[S.length - 1],
                t = e.nodes.indexOf(E);
              e.nodes.splice(t, 1, ...E.nodes);
            }
          } while (S.length > 0);
          return k({ type: "eos" }), x;
        };
      },
      3349: (e, t, r) => {
        "use strict";
        const n = r(3083);
        e.exports = (e, t = {}) => {
          let r = (e, i = {}) => {
            let o = t.escapeInvalid && n.isInvalidBrace(i),
              s = !0 === e.invalid && !0 === t.escapeInvalid,
              a = "";
            if (e.value)
              return (o || s) && n.isOpenOrClose(e) ? "\\" + e.value : e.value;
            if (e.value) return e.value;
            if (e.nodes) for (let t of e.nodes) a += r(t);
            return a;
          };
          return r(e);
        };
      },
      3083: (e, t) => {
        "use strict";
        (t.isInteger = (e) =>
          "number" == typeof e
            ? Number.isInteger(e)
            : "string" == typeof e &&
              "" !== e.trim() &&
              Number.isInteger(Number(e))),
          (t.find = (e, t) => e.nodes.find((e) => e.type === t)),
          (t.exceedsLimit = (e, r, n = 1, i) =>
            !1 !== i &&
            !(!t.isInteger(e) || !t.isInteger(r)) &&
            (Number(r) - Number(e)) / Number(n) >= i),
          (t.escapeNode = (e, t = 0, r) => {
            let n = e.nodes[t];
            n &&
              ((r && n.type === r) ||
                "open" === n.type ||
                "close" === n.type) &&
              !0 !== n.escaped &&
              ((n.value = "\\" + n.value), (n.escaped = !0));
          }),
          (t.encloseBrace = (e) =>
            "brace" === e.type &&
            (e.commas >> (0 + e.ranges)) >> 0 == 0 &&
            ((e.invalid = !0), !0)),
          (t.isInvalidBrace = (e) =>
            !(
              "brace" !== e.type ||
              (!0 !== e.invalid &&
                !e.dollar &&
                (((e.commas >> (0 + e.ranges)) >> 0 != 0 &&
                  !0 === e.open &&
                  !0 === e.close) ||
                  ((e.invalid = !0), 0)))
            )),
          (t.isOpenOrClose = (e) =>
            "open" === e.type ||
            "close" === e.type ||
            !0 === e.open ||
            !0 === e.close),
          (t.reduce = (e) =>
            e.reduce(
              (e, t) => (
                "text" === t.type && e.push(t.value),
                "range" === t.type && (t.type = "text"),
                e
              ),
              []
            )),
          (t.flatten = (...e) => {
            const t = [],
              r = (e) => {
                for (let n = 0; n < e.length; n++) {
                  let i = e[n];
                  Array.isArray(i) ? r(i, t) : void 0 !== i && t.push(i);
                }
                return t;
              };
            return r(e), t;
          });
      },
      8309: (e, t, r) => {
        "use strict";
        const n = r(2081),
          i = r(4605),
          o = r(3743);
        function s(e, t, r) {
          const s = i(e, t, r),
            a = n.spawn(s.command, s.args, s.options);
          return o.hookChildProcess(a, s), a;
        }
        (e.exports = s),
          (e.exports.spawn = s),
          (e.exports.sync = function (e, t, r) {
            const s = i(e, t, r),
              a = n.spawnSync(s.command, s.args, s.options);
            return (a.error = a.error || o.verifyENOENTSync(a.status, s)), a;
          }),
          (e.exports._parse = i),
          (e.exports._enoent = o);
      },
      3743: (e) => {
        "use strict";
        const t = "win32" === process.platform;
        function r(e, t) {
          return Object.assign(new Error(`${t} ${e.command} ENOENT`), {
            code: "ENOENT",
            errno: "ENOENT",
            syscall: `${t} ${e.command}`,
            path: e.command,
            spawnargs: e.args,
          });
        }
        function n(e, n) {
          return t && 1 === e && !n.file ? r(n.original, "spawn") : null;
        }
        e.exports = {
          hookChildProcess: function (e, r) {
            if (!t) return;
            const i = e.emit;
            e.emit = function (t, o) {
              if ("exit" === t) {
                const t = n(o, r);
                if (t) return i.call(e, "error", t);
              }
              return i.apply(e, arguments);
            };
          },
          verifyENOENT: n,
          verifyENOENTSync: function (e, n) {
            return t && 1 === e && !n.file ? r(n.original, "spawnSync") : null;
          },
          notFoundError: r,
        };
      },
      4605: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = r(2202),
          o = r(5081),
          s = r(7550),
          a = "win32" === process.platform,
          c = /\.(?:com|exe)$/i,
          u = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
        e.exports = function (e, t, r) {
          t && !Array.isArray(t) && ((r = t), (t = null));
          const l = {
            command: e,
            args: (t = t ? t.slice(0) : []),
            options: (r = Object.assign({}, r)),
            file: void 0,
            original: { command: e, args: t },
          };
          return r.shell
            ? l
            : (function (e) {
                if (!a) return e;
                const t = (function (e) {
                    e.file = i(e);
                    const t = e.file && s(e.file);
                    return t
                      ? (e.args.unshift(e.file), (e.command = t), i(e))
                      : e.file;
                  })(e),
                  r = !c.test(t);
                if (e.options.forceShell || r) {
                  const r = u.test(t);
                  (e.command = n.normalize(e.command)),
                    (e.command = o.command(e.command)),
                    (e.args = e.args.map((e) => o.argument(e, r)));
                  const i = [e.command].concat(e.args).join(" ");
                  (e.args = ["/d", "/s", "/c", `"${i}"`]),
                    (e.command = process.env.comspec || "cmd.exe"),
                    (e.options.windowsVerbatimArguments = !0);
                }
                return e;
              })(l);
        };
      },
      5081: (e) => {
        "use strict";
        const t = /([()\][%!^"`<>&|;, *?])/g;
        (e.exports.command = function (e) {
          return e.replace(t, "^$1");
        }),
          (e.exports.argument = function (e, r) {
            return (
              (e = (e = `"${(e = (e = (e = `${e}`).replace(
                /(\\*)"/g,
                '$1$1\\"'
              )).replace(/(\\*)$/, "$1$1"))}"`).replace(t, "^$1")),
              r && (e = e.replace(t, "^$1")),
              e
            );
          });
      },
      7550: (e, t, r) => {
        "use strict";
        const n = r(7147),
          i = r(2063);
        e.exports = function (e) {
          const t = Buffer.alloc(150);
          let r;
          try {
            (r = n.openSync(e, "r")),
              n.readSync(r, t, 0, 150, 0),
              n.closeSync(r);
          } catch (e) {}
          return i(t.toString());
        };
      },
      2202: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = r(2806),
          o = r(3024);
        function s(e, t) {
          const r = e.options.env || process.env,
            s = process.cwd(),
            a = null != e.options.cwd,
            c = a && void 0 !== process.chdir && !process.chdir.disabled;
          if (c)
            try {
              process.chdir(e.options.cwd);
            } catch (e) {}
          let u;
          try {
            u = i.sync(e.command, {
              path: r[o({ env: r })],
              pathExt: t ? n.delimiter : void 0,
            });
          } catch (e) {
          } finally {
            c && process.chdir(s);
          }
          return u && (u = n.resolve(a ? e.options.cwd : "", u)), u;
        }
        e.exports = function (e) {
          return s(e) || s(e, !0);
        };
      },
      367: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = r(9847),
          o = (e) => (e.length > 1 ? `{${e.join(",")}}` : e[0]),
          s = (e, t) => {
            const r = "!" === e[0] ? e.slice(1) : e;
            return n.isAbsolute(r) ? r : n.join(t, r);
          },
          a = (e, t) => {
            if (t.files && !Array.isArray(t.files))
              throw new TypeError(
                `Expected \`files\` to be of type \`Array\` but received type \`${typeof t.files}\``
              );
            if (t.extensions && !Array.isArray(t.extensions))
              throw new TypeError(
                `Expected \`extensions\` to be of type \`Array\` but received type \`${typeof t.extensions}\``
              );
            return t.files && t.extensions
              ? t.files.map((r) => {
                  return n.posix.join(
                    e,
                    ((i = r),
                    (s = t.extensions),
                    n.extname(i) ? `**/${i}` : `**/${i}.${o(s)}`)
                  );
                  var i, s;
                })
              : t.files
              ? t.files.map((t) => n.posix.join(e, `**/${t}`))
              : t.extensions
              ? [n.posix.join(e, `**/*.${o(t.extensions)}`)]
              : [n.posix.join(e, "**")];
          };
        (e.exports = async (e, t) => {
          if ("string" != typeof (t = { cwd: process.cwd(), ...t }).cwd)
            throw new TypeError(
              `Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``
            );
          const r = await Promise.all(
            []
              .concat(e)
              .map(async (e) =>
                (await i.isDirectory(s(e, t.cwd))) ? a(e, t) : e
              )
          );
          return [].concat.apply([], r);
        }),
          (e.exports.sync = (e, t) => {
            if ("string" != typeof (t = { cwd: process.cwd(), ...t }).cwd)
              throw new TypeError(
                `Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``
              );
            const r = []
              .concat(e)
              .map((e) => (i.isDirectorySync(s(e, t.cwd)) ? a(e, t) : e));
            return [].concat.apply([], r);
          });
      },
      2840: (e, t, r) => {
        var n = r(447),
          i = function () {},
          o = function (e, t, r) {
            if ("function" == typeof t) return o(e, null, t);
            t || (t = {}), (r = n(r || i));
            var s = e._writableState,
              a = e._readableState,
              c = t.readable || (!1 !== t.readable && e.readable),
              u = t.writable || (!1 !== t.writable && e.writable),
              l = !1,
              d = function () {
                e.writable || p();
              },
              p = function () {
                (u = !1), c || r.call(e);
              },
              f = function () {
                (c = !1), u || r.call(e);
              },
              m = function (t) {
                r.call(e, t ? new Error("exited with error code: " + t) : null);
              },
              h = function (t) {
                r.call(e, t);
              },
              g = function () {
                process.nextTick(y);
              },
              y = function () {
                if (!l)
                  return (!c || (a && a.ended && !a.destroyed)) &&
                    (!u || (s && s.ended && !s.destroyed))
                    ? void 0
                    : r.call(e, new Error("premature close"));
              },
              b = function () {
                e.req.on("finish", p);
              };
            return (
              (function (e) {
                return e.setHeader && "function" == typeof e.abort;
              })(e)
                ? (e.on("complete", p),
                  e.on("abort", g),
                  e.req ? b() : e.on("request", b))
                : u && !s && (e.on("end", d), e.on("close", d)),
              (function (e) {
                return (
                  e.stdio && Array.isArray(e.stdio) && 3 === e.stdio.length
                );
              })(e) && e.on("exit", m),
              e.on("end", f),
              e.on("finish", p),
              !1 !== t.error && e.on("error", h),
              e.on("close", g),
              function () {
                (l = !0),
                  e.removeListener("complete", p),
                  e.removeListener("abort", g),
                  e.removeListener("request", b),
                  e.req && e.req.removeListener("finish", p),
                  e.removeListener("end", d),
                  e.removeListener("close", d),
                  e.removeListener("finish", p),
                  e.removeListener("exit", m),
                  e.removeListener("end", f),
                  e.removeListener("error", h),
                  e.removeListener("close", g);
              }
            );
          };
        e.exports = o;
      },
      3294: (e, t, r) => {
        "use strict";
        const n = r(5135),
          i = r(7888),
          o = r(3456),
          s = r(3403),
          a = r(4113),
          c = r(3862),
          u = r(4426);
        async function l(e, t) {
          p(e);
          const r = d(e, o.default, t),
            n = await Promise.all(r);
          return u.array.flatten(n);
        }
        function d(e, t, r) {
          const o = i.transform([].concat(e)),
            s = new c.default(r),
            a = n.generate(o, s),
            u = new t(s);
          return a.map(u.read, u);
        }
        function p(e) {
          if (
            ![]
              .concat(e)
              .every((e) => u.string.isString(e) && !u.string.isEmpty(e))
          )
            throw new TypeError(
              "Patterns must be a string (non empty) or an array of strings"
            );
        }
        !(function (e) {
          (e.sync = function (e, t) {
            p(e);
            const r = d(e, a.default, t);
            return u.array.flatten(r);
          }),
            (e.stream = function (e, t) {
              p(e);
              const r = d(e, s.default, t);
              return u.stream.merge(r);
            }),
            (e.generateTasks = function (e, t) {
              p(e);
              const r = i.transform([].concat(e)),
                o = new c.default(t);
              return n.generate(r, o);
            }),
            (e.isDynamicPattern = function (e, t) {
              p(e);
              const r = new c.default(t);
              return u.pattern.isDynamicPattern(e, r);
            }),
            (e.escapePath = function (e) {
              return p(e), u.path.escape(e);
            });
        })(l || (l = {})),
          (e.exports = l);
      },
      7888: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.removeDuplicateSlashes = t.transform = void 0);
        const r = /(?!^)\/{2,}/g;
        function n(e) {
          return e.replace(r, "/");
        }
        (t.transform = function (e) {
          return e.map((e) => n(e));
        }),
          (t.removeDuplicateSlashes = n);
      },
      5135: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.convertPatternGroupToTask =
            t.convertPatternGroupsToTasks =
            t.groupPatternsByBaseDirectory =
            t.getNegativePatternsAsPositive =
            t.getPositivePatterns =
            t.convertPatternsToTasks =
            t.generate =
              void 0);
        const n = r(4426);
        function i(e, t, r) {
          const i = [],
            o = n.pattern.getPatternsOutsideCurrentDirectory(e),
            s = n.pattern.getPatternsInsideCurrentDirectory(e),
            l = a(o),
            d = a(s);
          return (
            i.push(...c(l, t, r)),
            "." in d ? i.push(u(".", s, t, r)) : i.push(...c(d, t, r)),
            i
          );
        }
        function o(e) {
          return n.pattern.getPositivePatterns(e);
        }
        function s(e, t) {
          return n.pattern
            .getNegativePatterns(e)
            .concat(t)
            .map(n.pattern.convertToPositivePattern);
        }
        function a(e) {
          return e.reduce((e, t) => {
            const r = n.pattern.getBaseDirectory(t);
            return r in e ? e[r].push(t) : (e[r] = [t]), e;
          }, {});
        }
        function c(e, t, r) {
          return Object.keys(e).map((n) => u(n, e[n], t, r));
        }
        function u(e, t, r, i) {
          return {
            dynamic: i,
            positive: t,
            negative: r,
            base: e,
            patterns: [].concat(t, r.map(n.pattern.convertToNegativePattern)),
          };
        }
        (t.generate = function (e, t) {
          const r = o(e),
            a = s(e, t.ignore),
            c = r.filter((e) => n.pattern.isStaticPattern(e, t)),
            u = r.filter((e) => n.pattern.isDynamicPattern(e, t)),
            l = i(c, a, !1),
            d = i(u, a, !0);
          return l.concat(d);
        }),
          (t.convertPatternsToTasks = i),
          (t.getPositivePatterns = o),
          (t.getNegativePatternsAsPositive = s),
          (t.groupPatternsByBaseDirectory = a),
          (t.convertPatternGroupsToTasks = c),
          (t.convertPatternGroupToTask = u);
      },
      3456: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(9086),
          i = r(466);
        class o extends i.default {
          constructor() {
            super(...arguments), (this._reader = new n.default(this._settings));
          }
          read(e) {
            const t = this._getRootDirectory(e),
              r = this._getReaderOptions(e),
              n = [];
            return new Promise((i, o) => {
              const s = this.api(t, e, r);
              s.once("error", o),
                s.on("data", (e) => n.push(r.transform(e))),
                s.once("end", () => i(n));
            });
          }
          api(e, t, r) {
            return t.dynamic
              ? this._reader.dynamic(e, r)
              : this._reader.static(t.patterns, r);
          }
        }
        t.default = o;
      },
      346: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(4426),
          i = r(1452);
        t.default = class {
          constructor(e, t) {
            (this._settings = e), (this._micromatchOptions = t);
          }
          getFilter(e, t, r) {
            const n = this._getMatcher(t),
              i = this._getNegativePatternsRe(r);
            return (t) => this._filter(e, t, n, i);
          }
          _getMatcher(e) {
            return new i.default(e, this._settings, this._micromatchOptions);
          }
          _getNegativePatternsRe(e) {
            const t = e.filter(n.pattern.isAffectDepthOfReadingPattern);
            return n.pattern.convertPatternsToRe(t, this._micromatchOptions);
          }
          _filter(e, t, r, i) {
            if (this._isSkippedByDeep(e, t.path)) return !1;
            if (this._isSkippedSymbolicLink(t)) return !1;
            const o = n.path.removeLeadingDotSegment(t.path);
            return (
              !this._isSkippedByPositivePatterns(o, r) &&
              this._isSkippedByNegativePatterns(o, i)
            );
          }
          _isSkippedByDeep(e, t) {
            return (
              this._settings.deep !== 1 / 0 &&
              this._getEntryLevel(e, t) >= this._settings.deep
            );
          }
          _getEntryLevel(e, t) {
            const r = t.split("/").length;
            return "" === e ? r : r - e.split("/").length;
          }
          _isSkippedSymbolicLink(e) {
            return (
              !this._settings.followSymbolicLinks && e.dirent.isSymbolicLink()
            );
          }
          _isSkippedByPositivePatterns(e, t) {
            return !this._settings.baseNameMatch && !t.match(e);
          }
          _isSkippedByNegativePatterns(e, t) {
            return !n.pattern.matchAny(e, t);
          }
        };
      },
      7026: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(4426);
        t.default = class {
          constructor(e, t) {
            (this._settings = e),
              (this._micromatchOptions = t),
              (this.index = new Map());
          }
          getFilter(e, t) {
            const r = n.pattern.convertPatternsToRe(e, this._micromatchOptions),
              i = n.pattern.convertPatternsToRe(t, this._micromatchOptions);
            return (e) => this._filter(e, r, i);
          }
          _filter(e, t, r) {
            if (this._settings.unique && this._isDuplicateEntry(e)) return !1;
            if (this._onlyFileFilter(e) || this._onlyDirectoryFilter(e))
              return !1;
            if (this._isSkippedByAbsoluteNegativePatterns(e.path, r)) return !1;
            const n = this._settings.baseNameMatch ? e.name : e.path,
              i =
                this._isMatchToPatterns(n, t) &&
                !this._isMatchToPatterns(e.path, r);
            return this._settings.unique && i && this._createIndexRecord(e), i;
          }
          _isDuplicateEntry(e) {
            return this.index.has(e.path);
          }
          _createIndexRecord(e) {
            this.index.set(e.path, void 0);
          }
          _onlyFileFilter(e) {
            return this._settings.onlyFiles && !e.dirent.isFile();
          }
          _onlyDirectoryFilter(e) {
            return this._settings.onlyDirectories && !e.dirent.isDirectory();
          }
          _isSkippedByAbsoluteNegativePatterns(e, t) {
            if (!this._settings.absolute) return !1;
            const r = n.path.makeAbsolute(this._settings.cwd, e);
            return n.pattern.matchAny(r, t);
          }
          _isMatchToPatterns(e, t) {
            const r = n.path.removeLeadingDotSegment(e);
            return n.pattern.matchAny(r, t) || n.pattern.matchAny(r + "/", t);
          }
        };
      },
      3046: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(4426);
        t.default = class {
          constructor(e) {
            this._settings = e;
          }
          getFilter() {
            return (e) => this._isNonFatalError(e);
          }
          _isNonFatalError(e) {
            return (
              n.errno.isEnoentCodeError(e) || this._settings.suppressErrors
            );
          }
        };
      },
      92: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(4426);
        t.default = class {
          constructor(e, t, r) {
            (this._patterns = e),
              (this._settings = t),
              (this._micromatchOptions = r),
              (this._storage = []),
              this._fillStorage();
          }
          _fillStorage() {
            const e = n.pattern.expandPatternsWithBraceExpansion(
              this._patterns
            );
            for (const t of e) {
              const e = this._getPatternSegments(t),
                r = this._splitSegmentsIntoSections(e);
              this._storage.push({
                complete: r.length <= 1,
                pattern: t,
                segments: e,
                sections: r,
              });
            }
          }
          _getPatternSegments(e) {
            return n.pattern
              .getPatternParts(e, this._micromatchOptions)
              .map((e) =>
                n.pattern.isDynamicPattern(e, this._settings)
                  ? {
                      dynamic: !0,
                      pattern: e,
                      patternRe: n.pattern.makeRe(e, this._micromatchOptions),
                    }
                  : { dynamic: !1, pattern: e }
              );
          }
          _splitSegmentsIntoSections(e) {
            return n.array.splitWhen(
              e,
              (e) => e.dynamic && n.pattern.hasGlobStar(e.pattern)
            );
          }
        };
      },
      1452: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(92);
        class i extends n.default {
          match(e) {
            const t = e.split("/"),
              r = t.length,
              n = this._storage.filter(
                (e) => !e.complete || e.segments.length > r
              );
            for (const e of n) {
              const n = e.sections[0];
              if (!e.complete && r > n.length) return !0;
              if (
                t.every((t, r) => {
                  const n = e.segments[r];
                  return (
                    !(!n.dynamic || !n.patternRe.test(t)) ||
                    (!n.dynamic && n.pattern === t)
                  );
                })
              )
                return !0;
            }
            return !1;
          }
        }
        t.default = i;
      },
      466: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(1017),
          i = r(346),
          o = r(7026),
          s = r(3046),
          a = r(218);
        t.default = class {
          constructor(e) {
            (this._settings = e),
              (this.errorFilter = new s.default(this._settings)),
              (this.entryFilter = new o.default(
                this._settings,
                this._getMicromatchOptions()
              )),
              (this.deepFilter = new i.default(
                this._settings,
                this._getMicromatchOptions()
              )),
              (this.entryTransformer = new a.default(this._settings));
          }
          _getRootDirectory(e) {
            return n.resolve(this._settings.cwd, e.base);
          }
          _getReaderOptions(e) {
            const t = "." === e.base ? "" : e.base;
            return {
              basePath: t,
              pathSegmentSeparator: "/",
              concurrency: this._settings.concurrency,
              deepFilter: this.deepFilter.getFilter(t, e.positive, e.negative),
              entryFilter: this.entryFilter.getFilter(e.positive, e.negative),
              errorFilter: this.errorFilter.getFilter(),
              followSymbolicLinks: this._settings.followSymbolicLinks,
              fs: this._settings.fs,
              stats: this._settings.stats,
              throwErrorOnBrokenSymbolicLink:
                this._settings.throwErrorOnBrokenSymbolicLink,
              transform: this.entryTransformer.getTransformer(),
            };
          }
          _getMicromatchOptions() {
            return {
              dot: this._settings.dot,
              matchBase: this._settings.baseNameMatch,
              nobrace: !this._settings.braceExpansion,
              nocase: !this._settings.caseSensitiveMatch,
              noext: !this._settings.extglob,
              noglobstar: !this._settings.globstar,
              posix: !0,
              strictSlashes: !1,
            };
          }
        };
      },
      3403: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(2781),
          i = r(9086),
          o = r(466);
        class s extends o.default {
          constructor() {
            super(...arguments), (this._reader = new i.default(this._settings));
          }
          read(e) {
            const t = this._getRootDirectory(e),
              r = this._getReaderOptions(e),
              i = this.api(t, e, r),
              o = new n.Readable({ objectMode: !0, read: () => {} });
            return (
              i
                .once("error", (e) => o.emit("error", e))
                .on("data", (e) => o.emit("data", r.transform(e)))
                .once("end", () => o.emit("end")),
              o.once("close", () => i.destroy()),
              o
            );
          }
          api(e, t, r) {
            return t.dynamic
              ? this._reader.dynamic(e, r)
              : this._reader.static(t.patterns, r);
          }
        }
        t.default = s;
      },
      4113: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(112),
          i = r(466);
        class o extends i.default {
          constructor() {
            super(...arguments), (this._reader = new n.default(this._settings));
          }
          read(e) {
            const t = this._getRootDirectory(e),
              r = this._getReaderOptions(e);
            return this.api(t, e, r).map(r.transform);
          }
          api(e, t, r) {
            return t.dynamic
              ? this._reader.dynamic(e, r)
              : this._reader.static(t.patterns, r);
          }
        }
        t.default = o;
      },
      218: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(4426);
        t.default = class {
          constructor(e) {
            this._settings = e;
          }
          getTransformer() {
            return (e) => this._transform(e);
          }
          _transform(e) {
            let t = e.path;
            return (
              this._settings.absolute &&
                ((t = n.path.makeAbsolute(this._settings.cwd, t)),
                (t = n.path.unixify(t))),
              this._settings.markDirectories &&
                e.dirent.isDirectory() &&
                (t += "/"),
              this._settings.objectMode
                ? Object.assign(Object.assign({}, e), { path: t })
                : t
            );
          }
        };
      },
      2117: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(1017),
          i = r(6203),
          o = r(4426);
        t.default = class {
          constructor(e) {
            (this._settings = e),
              (this._fsStatSettings = new i.Settings({
                followSymbolicLink: this._settings.followSymbolicLinks,
                fs: this._settings.fs,
                throwErrorOnBrokenSymbolicLink:
                  this._settings.followSymbolicLinks,
              }));
          }
          _getFullEntryPath(e) {
            return n.resolve(this._settings.cwd, e);
          }
          _makeEntry(e, t) {
            const r = {
              name: t,
              path: t,
              dirent: o.fs.createDirentFromStats(t, e),
            };
            return this._settings.stats && (r.stats = e), r;
          }
          _isFatalError(e) {
            return (
              !o.errno.isEnoentCodeError(e) && !this._settings.suppressErrors
            );
          }
        };
      },
      9086: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(2781),
          i = r(6203),
          o = r(5439),
          s = r(2117);
        class a extends s.default {
          constructor() {
            super(...arguments),
              (this._walkStream = o.walkStream),
              (this._stat = i.stat);
          }
          dynamic(e, t) {
            return this._walkStream(e, t);
          }
          static(e, t) {
            const r = e.map(this._getFullEntryPath, this),
              i = new n.PassThrough({ objectMode: !0 });
            i._write = (n, o, s) =>
              this._getEntry(r[n], e[n], t)
                .then((e) => {
                  null !== e && t.entryFilter(e) && i.push(e),
                    n === r.length - 1 && i.end(),
                    s();
                })
                .catch(s);
            for (let e = 0; e < r.length; e++) i.write(e);
            return i;
          }
          _getEntry(e, t, r) {
            return this._getStat(e)
              .then((e) => this._makeEntry(e, t))
              .catch((e) => {
                if (r.errorFilter(e)) return null;
                throw e;
              });
          }
          _getStat(e) {
            return new Promise((t, r) => {
              this._stat(e, this._fsStatSettings, (e, n) =>
                null === e ? t(n) : r(e)
              );
            });
          }
        }
        t.default = a;
      },
      112: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(6203),
          i = r(5439),
          o = r(2117);
        class s extends o.default {
          constructor() {
            super(...arguments),
              (this._walkSync = i.walkSync),
              (this._statSync = n.statSync);
          }
          dynamic(e, t) {
            return this._walkSync(e, t);
          }
          static(e, t) {
            const r = [];
            for (const n of e) {
              const e = this._getFullEntryPath(n),
                i = this._getEntry(e, n, t);
              null !== i && t.entryFilter(i) && r.push(i);
            }
            return r;
          }
          _getEntry(e, t, r) {
            try {
              const r = this._getStat(e);
              return this._makeEntry(r, t);
            } catch (e) {
              if (r.errorFilter(e)) return null;
              throw e;
            }
          }
          _getStat(e) {
            return this._statSync(e, this._fsStatSettings);
          }
        }
        t.default = s;
      },
      3862: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DEFAULT_FILE_SYSTEM_ADAPTER = void 0);
        const n = r(7147),
          i = r(2037),
          o = Math.max(i.cpus().length, 1);
        (t.DEFAULT_FILE_SYSTEM_ADAPTER = {
          lstat: n.lstat,
          lstatSync: n.lstatSync,
          stat: n.stat,
          statSync: n.statSync,
          readdir: n.readdir,
          readdirSync: n.readdirSync,
        }),
          (t.default = class {
            constructor(e = {}) {
              (this._options = e),
                (this.absolute = this._getValue(this._options.absolute, !1)),
                (this.baseNameMatch = this._getValue(
                  this._options.baseNameMatch,
                  !1
                )),
                (this.braceExpansion = this._getValue(
                  this._options.braceExpansion,
                  !0
                )),
                (this.caseSensitiveMatch = this._getValue(
                  this._options.caseSensitiveMatch,
                  !0
                )),
                (this.concurrency = this._getValue(
                  this._options.concurrency,
                  o
                )),
                (this.cwd = this._getValue(this._options.cwd, process.cwd())),
                (this.deep = this._getValue(this._options.deep, 1 / 0)),
                (this.dot = this._getValue(this._options.dot, !1)),
                (this.extglob = this._getValue(this._options.extglob, !0)),
                (this.followSymbolicLinks = this._getValue(
                  this._options.followSymbolicLinks,
                  !0
                )),
                (this.fs = this._getFileSystemMethods(this._options.fs)),
                (this.globstar = this._getValue(this._options.globstar, !0)),
                (this.ignore = this._getValue(this._options.ignore, [])),
                (this.markDirectories = this._getValue(
                  this._options.markDirectories,
                  !1
                )),
                (this.objectMode = this._getValue(
                  this._options.objectMode,
                  !1
                )),
                (this.onlyDirectories = this._getValue(
                  this._options.onlyDirectories,
                  !1
                )),
                (this.onlyFiles = this._getValue(this._options.onlyFiles, !0)),
                (this.stats = this._getValue(this._options.stats, !1)),
                (this.suppressErrors = this._getValue(
                  this._options.suppressErrors,
                  !1
                )),
                (this.throwErrorOnBrokenSymbolicLink = this._getValue(
                  this._options.throwErrorOnBrokenSymbolicLink,
                  !1
                )),
                (this.unique = this._getValue(this._options.unique, !0)),
                this.onlyDirectories && (this.onlyFiles = !1),
                this.stats && (this.objectMode = !0);
            }
            _getValue(e, t) {
              return void 0 === e ? t : e;
            }
            _getFileSystemMethods(e = {}) {
              return Object.assign(
                Object.assign({}, t.DEFAULT_FILE_SYSTEM_ADAPTER),
                e
              );
            }
          });
      },
      4825: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.splitWhen = t.flatten = void 0),
          (t.flatten = function (e) {
            return e.reduce((e, t) => [].concat(e, t), []);
          }),
          (t.splitWhen = function (e, t) {
            const r = [[]];
            let n = 0;
            for (const i of e) t(i) ? (n++, (r[n] = [])) : r[n].push(i);
            return r;
          });
      },
      7843: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isEnoentCodeError = void 0),
          (t.isEnoentCodeError = function (e) {
            return "ENOENT" === e.code;
          });
      },
      6334: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createDirentFromStats = void 0);
        class r {
          constructor(e, t) {
            (this.name = e),
              (this.isBlockDevice = t.isBlockDevice.bind(t)),
              (this.isCharacterDevice = t.isCharacterDevice.bind(t)),
              (this.isDirectory = t.isDirectory.bind(t)),
              (this.isFIFO = t.isFIFO.bind(t)),
              (this.isFile = t.isFile.bind(t)),
              (this.isSocket = t.isSocket.bind(t)),
              (this.isSymbolicLink = t.isSymbolicLink.bind(t));
          }
        }
        t.createDirentFromStats = function (e, t) {
          return new r(e, t);
        };
      },
      4426: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.string =
            t.stream =
            t.pattern =
            t.path =
            t.fs =
            t.errno =
            t.array =
              void 0);
        const n = r(4825);
        t.array = n;
        const i = r(7843);
        t.errno = i;
        const o = r(6334);
        t.fs = o;
        const s = r(2003);
        t.path = s;
        const a = r(57);
        t.pattern = a;
        const c = r(6242);
        t.stream = c;
        const u = r(3021);
        t.string = u;
      },
      2003: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.removeLeadingDotSegment =
            t.escape =
            t.makeAbsolute =
            t.unixify =
              void 0);
        const n = r(1017),
          i = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
        (t.unixify = function (e) {
          return e.replace(/\\/g, "/");
        }),
          (t.makeAbsolute = function (e, t) {
            return n.resolve(e, t);
          }),
          (t.escape = function (e) {
            return e.replace(i, "\\$2");
          }),
          (t.removeLeadingDotSegment = function (e) {
            if ("." === e.charAt(0)) {
              const t = e.charAt(1);
              if ("/" === t || "\\" === t) return e.slice(2);
            }
            return e;
          });
      },
      57: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.matchAny =
            t.convertPatternsToRe =
            t.makeRe =
            t.getPatternParts =
            t.expandBraceExpansion =
            t.expandPatternsWithBraceExpansion =
            t.isAffectDepthOfReadingPattern =
            t.endsWithSlashGlobStar =
            t.hasGlobStar =
            t.getBaseDirectory =
            t.isPatternRelatedToParentDirectory =
            t.getPatternsOutsideCurrentDirectory =
            t.getPatternsInsideCurrentDirectory =
            t.getPositivePatterns =
            t.getNegativePatterns =
            t.isPositivePattern =
            t.isNegativePattern =
            t.convertToNegativePattern =
            t.convertToPositivePattern =
            t.isDynamicPattern =
            t.isStaticPattern =
              void 0);
        const n = r(1017),
          i = r(7647),
          o = r(850),
          s = /[*?]|^!/,
          a = /\[[^[]*]/,
          c = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/,
          u = /[!*+?@]\([^(]*\)/,
          l = /,|\.\./;
        function d(e, t = {}) {
          return !p(e, t);
        }
        function p(e, t = {}) {
          return !!(
            "" !== e &&
            (!1 === t.caseSensitiveMatch ||
              e.includes("\\") ||
              s.test(e) ||
              a.test(e) ||
              c.test(e) ||
              (!1 !== t.extglob && u.test(e)) ||
              (!1 !== t.braceExpansion &&
                (function (e) {
                  const t = e.indexOf("{");
                  if (-1 === t) return !1;
                  const r = e.indexOf("}", t + 1);
                  if (-1 === r) return !1;
                  const n = e.slice(t, r);
                  return l.test(n);
                })(e)))
          );
        }
        function f(e) {
          return e.startsWith("!") && "(" !== e[1];
        }
        function m(e) {
          return !f(e);
        }
        function h(e) {
          return e.startsWith("..") || e.startsWith("./..");
        }
        function g(e) {
          return e.endsWith("/**");
        }
        function y(e) {
          return o.braces(e, { expand: !0, nodupes: !0 });
        }
        function b(e, t) {
          return o.makeRe(e, t);
        }
        (t.isStaticPattern = d),
          (t.isDynamicPattern = p),
          (t.convertToPositivePattern = function (e) {
            return f(e) ? e.slice(1) : e;
          }),
          (t.convertToNegativePattern = function (e) {
            return "!" + e;
          }),
          (t.isNegativePattern = f),
          (t.isPositivePattern = m),
          (t.getNegativePatterns = function (e) {
            return e.filter(f);
          }),
          (t.getPositivePatterns = function (e) {
            return e.filter(m);
          }),
          (t.getPatternsInsideCurrentDirectory = function (e) {
            return e.filter((e) => !h(e));
          }),
          (t.getPatternsOutsideCurrentDirectory = function (e) {
            return e.filter(h);
          }),
          (t.isPatternRelatedToParentDirectory = h),
          (t.getBaseDirectory = function (e) {
            return i(e, { flipBackslashes: !1 });
          }),
          (t.hasGlobStar = function (e) {
            return e.includes("**");
          }),
          (t.endsWithSlashGlobStar = g),
          (t.isAffectDepthOfReadingPattern = function (e) {
            const t = n.basename(e);
            return g(e) || d(t);
          }),
          (t.expandPatternsWithBraceExpansion = function (e) {
            return e.reduce((e, t) => e.concat(y(t)), []);
          }),
          (t.expandBraceExpansion = y),
          (t.getPatternParts = function (e, t) {
            let { parts: r } = o.scan(
              e,
              Object.assign(Object.assign({}, t), { parts: !0 })
            );
            return (
              0 === r.length && (r = [e]),
              r[0].startsWith("/") && ((r[0] = r[0].slice(1)), r.unshift("")),
              r
            );
          }),
          (t.makeRe = b),
          (t.convertPatternsToRe = function (e, t) {
            return e.map((e) => b(e, t));
          }),
          (t.matchAny = function (e, t) {
            return t.some((t) => t.test(e));
          });
      },
      6242: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.merge = void 0);
        const n = r(155);
        function i(e) {
          e.forEach((e) => e.emit("close"));
        }
        t.merge = function (e) {
          const t = n(e);
          return (
            e.forEach((e) => {
              e.once("error", (e) => t.emit("error", e));
            }),
            t.once("close", () => i(e)),
            t.once("end", () => i(e)),
            t
          );
        };
      },
      3021: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isEmpty = t.isString = void 0),
          (t.isString = function (e) {
            return "string" == typeof e;
          }),
          (t.isEmpty = function (e) {
            return "" === e;
          });
      },
      373: (e, t, r) => {
        "use strict";
        var n = r(3650);
        function i(e, t, r) {
          if (("function" == typeof e && ((r = t), (t = e), (e = null)), r < 1))
            throw new Error("fastqueue concurrency must be greater than 1");
          var i = n(s),
            a = null,
            c = null,
            u = 0,
            l = null,
            d = {
              push: function (r, n) {
                var s = i.get();
                (s.context = e),
                  (s.release = p),
                  (s.value = r),
                  (s.callback = n || o),
                  (s.errorHandler = l),
                  u === d.concurrency || d.paused
                    ? c
                      ? ((c.next = s), (c = s))
                      : ((a = s), (c = s), d.saturated())
                    : (u++, t.call(e, s.value, s.worked));
              },
              drain: o,
              saturated: o,
              pause: function () {
                d.paused = !0;
              },
              paused: !1,
              concurrency: r,
              running: function () {
                return u;
              },
              resume: function () {
                if (d.paused) {
                  d.paused = !1;
                  for (var e = 0; e < d.concurrency; e++) u++, p();
                }
              },
              idle: function () {
                return 0 === u && 0 === d.length();
              },
              length: function () {
                for (var e = a, t = 0; e; ) (e = e.next), t++;
                return t;
              },
              getQueue: function () {
                for (var e = a, t = []; e; ) t.push(e.value), (e = e.next);
                return t;
              },
              unshift: function (r, n) {
                var s = i.get();
                (s.context = e),
                  (s.release = p),
                  (s.value = r),
                  (s.callback = n || o),
                  u === d.concurrency || d.paused
                    ? a
                      ? ((s.next = a), (a = s))
                      : ((a = s), (c = s), d.saturated())
                    : (u++, t.call(e, s.value, s.worked));
              },
              empty: o,
              kill: function () {
                (a = null), (c = null), (d.drain = o);
              },
              killAndDrain: function () {
                (a = null), (c = null), d.drain(), (d.drain = o);
              },
              error: function (e) {
                l = e;
              },
            };
          return d;
          function p(r) {
            r && i.release(r);
            var n = a;
            n
              ? d.paused
                ? u--
                : (c === a && (c = null),
                  (a = n.next),
                  (n.next = null),
                  t.call(e, n.value, n.worked),
                  null === c && d.empty())
              : 0 == --u && d.drain();
          }
        }
        function o() {}
        function s() {
          (this.value = null),
            (this.callback = o),
            (this.next = null),
            (this.release = o),
            (this.context = null),
            (this.errorHandler = null);
          var e = this;
          this.worked = function (t, r) {
            var n = e.callback,
              i = e.errorHandler,
              s = e.value;
            (e.value = null),
              (e.callback = o),
              e.errorHandler && i(t, s),
              n.call(e.context, t, r),
              e.release(e);
          };
        }
        (e.exports = i),
          (e.exports.promise = function (e, t, r) {
            "function" == typeof e && ((r = t), (t = e), (e = null));
            var n = i(
                e,
                function (e, r) {
                  t.call(this, e).then(function (e) {
                    r(null, e);
                  }, r);
                },
                r
              ),
              s = n.push,
              a = n.unshift;
            return (
              (n.push = function (e) {
                var t = new Promise(function (t, r) {
                  s(e, function (e, n) {
                    e ? r(e) : t(n);
                  });
                });
                return t.catch(o), t;
              }),
              (n.unshift = function (e) {
                var t = new Promise(function (t, r) {
                  a(e, function (e, n) {
                    e ? r(e) : t(n);
                  });
                });
                return t.catch(o), t;
              }),
              (n.drained = function () {
                var e = n.drain;
                return new Promise(function (t) {
                  n.drain = function () {
                    e(), t();
                  };
                });
              }),
              n
            );
          });
      },
      1: (module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        const Token = __webpack_require__(3416),
          strtok3 = __webpack_require__(5849),
          { stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } =
            __webpack_require__(6188),
          supported = __webpack_require__(9898),
          minimumBytes = 4100;
        async function fromStream(e) {
          const t = await strtok3.fromStream(e);
          try {
            return await fromTokenizer(t);
          } finally {
            await t.close();
          }
        }
        async function fromBuffer(e) {
          if (
            !(
              e instanceof Uint8Array ||
              e instanceof ArrayBuffer ||
              Buffer.isBuffer(e)
            )
          )
            throw new TypeError(
              `Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof e}\``
            );
          const t = e instanceof Buffer ? e : Buffer.from(e);
          if (t && t.length > 1) return fromTokenizer(strtok3.fromBuffer(t));
        }
        function _check(e, t, r) {
          r = { offset: 0, ...r };
          for (const [n, i] of t.entries())
            if (r.mask) {
              if (i !== (r.mask[n] & e[n + r.offset])) return !1;
            } else if (i !== e[n + r.offset]) return !1;
          return !0;
        }
        async function fromTokenizer(e) {
          try {
            return _fromTokenizer(e);
          } catch (e) {
            if (!(e instanceof strtok3.EndOfStreamError)) throw e;
          }
        }
        async function _fromTokenizer(e) {
          let t = Buffer.alloc(minimumBytes);
          const r = (e, r) => _check(t, e, r),
            n = (e, t) => r(stringToBytes(e), t);
          if (
            (e.fileInfo.size || (e.fileInfo.size = Number.MAX_SAFE_INTEGER),
            await e.peekBuffer(t, { length: 12, mayBeLess: !0 }),
            r([66, 77]))
          )
            return { ext: "bmp", mime: "image/bmp" };
          if (r([11, 119]))
            return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
          if (r([120, 1]))
            return { ext: "dmg", mime: "application/x-apple-diskimage" };
          if (r([77, 90]))
            return { ext: "exe", mime: "application/x-msdownload" };
          if (r([37, 33]))
            return (
              await e.peekBuffer(t, { length: 24, mayBeLess: !0 }),
              n("PS-Adobe-", { offset: 2 }) && n(" EPSF-", { offset: 14 })
                ? { ext: "eps", mime: "application/eps" }
                : { ext: "ps", mime: "application/postscript" }
            );
          if (r([31, 160]) || r([31, 157]))
            return { ext: "Z", mime: "application/x-compress" };
          if (r([255, 216, 255])) return { ext: "jpg", mime: "image/jpeg" };
          if (r([73, 73, 188]))
            return { ext: "jxr", mime: "image/vnd.ms-photo" };
          if (r([31, 139, 8])) return { ext: "gz", mime: "application/gzip" };
          if (r([66, 90, 104]))
            return { ext: "bz2", mime: "application/x-bzip2" };
          if (n("ID3")) {
            await e.ignore(6);
            const i = await e.readToken(uint32SyncSafeToken);
            return e.position + i > e.fileInfo.size
              ? { ext: "mp3", mime: "audio/mpeg" }
              : (await e.ignore(i), fromTokenizer(e));
          }
          if (n("MP+")) return { ext: "mpc", mime: "audio/x-musepack" };
          if ((67 === t[0] || 70 === t[0]) && r([87, 83], { offset: 1 }))
            return { ext: "swf", mime: "application/x-shockwave-flash" };
          if (r([71, 73, 70])) return { ext: "gif", mime: "image/gif" };
          if (n("FLIF")) return { ext: "flif", mime: "image/flif" };
          if (n("8BPS"))
            return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
          if (n("WEBP", { offset: 8 }))
            return { ext: "webp", mime: "image/webp" };
          if (n("MPCK")) return { ext: "mpc", mime: "audio/x-musepack" };
          if (n("FORM")) return { ext: "aif", mime: "audio/aiff" };
          if (n("icns", { offset: 0 }))
            return { ext: "icns", mime: "image/icns" };
          if (r([80, 75, 3, 4])) {
            try {
              for (; e.position + 30 < e.fileInfo.size; ) {
                await e.readBuffer(t, { length: 30 });
                const o = {
                  compressedSize: t.readUInt32LE(18),
                  uncompressedSize: t.readUInt32LE(22),
                  filenameLength: t.readUInt16LE(26),
                  extraFieldLength: t.readUInt16LE(28),
                };
                if (
                  ((o.filename = await e.readToken(
                    new Token.StringType(o.filenameLength, "utf-8")
                  )),
                  await e.ignore(o.extraFieldLength),
                  "META-INF/mozilla.rsa" === o.filename)
                )
                  return { ext: "xpi", mime: "application/x-xpinstall" };
                if (o.filename.endsWith(".rels") || o.filename.endsWith(".xml"))
                  switch (o.filename.split("/")[0]) {
                    case "_rels":
                    default:
                      break;
                    case "word":
                      return {
                        ext: "docx",
                        mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                      };
                    case "ppt":
                      return {
                        ext: "pptx",
                        mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                      };
                    case "xl":
                      return {
                        ext: "xlsx",
                        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                      };
                  }
                if (o.filename.startsWith("xl/"))
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                  };
                if (
                  o.filename.startsWith("3D/") &&
                  o.filename.endsWith(".model")
                )
                  return { ext: "3mf", mime: "model/3mf" };
                if (
                  "mimetype" === o.filename &&
                  o.compressedSize === o.uncompressedSize
                )
                  switch (
                    await e.readToken(
                      new Token.StringType(o.compressedSize, "utf-8")
                    )
                  ) {
                    case "application/epub+zip":
                      return { ext: "epub", mime: "application/epub+zip" };
                    case "application/vnd.oasis.opendocument.text":
                      return {
                        ext: "odt",
                        mime: "application/vnd.oasis.opendocument.text",
                      };
                    case "application/vnd.oasis.opendocument.spreadsheet":
                      return {
                        ext: "ods",
                        mime: "application/vnd.oasis.opendocument.spreadsheet",
                      };
                    case "application/vnd.oasis.opendocument.presentation":
                      return {
                        ext: "odp",
                        mime: "application/vnd.oasis.opendocument.presentation",
                      };
                  }
                if (0 === o.compressedSize) {
                  let s = -1;
                  for (; s < 0 && e.position < e.fileInfo.size; )
                    await e.peekBuffer(t, { mayBeLess: !0 }),
                      (s = t.indexOf("504B0304", 0, "hex")),
                      await e.ignore(s >= 0 ? s : t.length);
                } else await e.ignore(o.compressedSize);
              }
            } catch (a) {
              if (!(a instanceof strtok3.EndOfStreamError)) throw a;
            }
            return { ext: "zip", mime: "application/zip" };
          }
          if (n("OggS")) {
            await e.ignore(28);
            const c = Buffer.alloc(8);
            return (
              await e.readBuffer(c),
              _check(c, [79, 112, 117, 115, 72, 101, 97, 100])
                ? { ext: "opus", mime: "audio/opus" }
                : _check(c, [128, 116, 104, 101, 111, 114, 97])
                ? { ext: "ogv", mime: "video/ogg" }
                : _check(c, [1, 118, 105, 100, 101, 111, 0])
                ? { ext: "ogm", mime: "video/ogg" }
                : _check(c, [127, 70, 76, 65, 67])
                ? { ext: "oga", mime: "audio/ogg" }
                : _check(c, [83, 112, 101, 101, 120, 32, 32])
                ? { ext: "spx", mime: "audio/ogg" }
                : _check(c, [1, 118, 111, 114, 98, 105, 115])
                ? { ext: "ogg", mime: "audio/ogg" }
                : { ext: "ogx", mime: "application/ogg" }
            );
          }
          if (
            r([80, 75]) &&
            (3 === t[2] || 5 === t[2] || 7 === t[2]) &&
            (4 === t[3] || 6 === t[3] || 8 === t[3])
          )
            return { ext: "zip", mime: "application/zip" };
          if (n("ftyp", { offset: 4 }) && 0 != (96 & t[8])) {
            const u = t.toString("binary", 8, 12).replace("\0", " ").trim();
            switch (u) {
              case "avif":
                return { ext: "avif", mime: "image/avif" };
              case "mif1":
                return { ext: "heic", mime: "image/heif" };
              case "msf1":
                return { ext: "heic", mime: "image/heif-sequence" };
              case "heic":
              case "heix":
                return { ext: "heic", mime: "image/heic" };
              case "hevc":
              case "hevx":
                return { ext: "heic", mime: "image/heic-sequence" };
              case "qt":
                return { ext: "mov", mime: "video/quicktime" };
              case "M4V":
              case "M4VH":
              case "M4VP":
                return { ext: "m4v", mime: "video/x-m4v" };
              case "M4P":
                return { ext: "m4p", mime: "video/mp4" };
              case "M4B":
                return { ext: "m4b", mime: "audio/mp4" };
              case "M4A":
                return { ext: "m4a", mime: "audio/x-m4a" };
              case "F4V":
                return { ext: "f4v", mime: "video/mp4" };
              case "F4P":
                return { ext: "f4p", mime: "video/mp4" };
              case "F4A":
                return { ext: "f4a", mime: "audio/mp4" };
              case "F4B":
                return { ext: "f4b", mime: "audio/mp4" };
              case "crx":
                return { ext: "cr3", mime: "image/x-canon-cr3" };
              default:
                return u.startsWith("3g")
                  ? u.startsWith("3g2")
                    ? { ext: "3g2", mime: "video/3gpp2" }
                    : { ext: "3gp", mime: "video/3gpp" }
                  : { ext: "mp4", mime: "video/mp4" };
            }
          }
          if (n("MThd")) return { ext: "mid", mime: "audio/midi" };
          if (
            n("wOFF") &&
            (r([0, 1, 0, 0], { offset: 4 }) || n("OTTO", { offset: 4 }))
          )
            return { ext: "woff", mime: "font/woff" };
          if (
            n("wOF2") &&
            (r([0, 1, 0, 0], { offset: 4 }) || n("OTTO", { offset: 4 }))
          )
            return { ext: "woff2", mime: "font/woff2" };
          if (r([212, 195, 178, 161]) || r([161, 178, 195, 212]))
            return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
          if (n("DSD ")) return { ext: "dsf", mime: "audio/x-dsf" };
          if (n("LZIP")) return { ext: "lz", mime: "application/x-lzip" };
          if (n("fLaC")) return { ext: "flac", mime: "audio/x-flac" };
          if (r([66, 80, 71, 251])) return { ext: "bpg", mime: "image/bpg" };
          if (n("wvpk")) return { ext: "wv", mime: "audio/wavpack" };
          if (n("%PDF")) {
            await e.ignore(1350);
            const l = 10485760,
              d = Buffer.alloc(Math.min(l, e.fileInfo.size));
            return (
              await e.readBuffer(d, { mayBeLess: !0 }),
              d.includes(Buffer.from("AIPrivateData"))
                ? { ext: "ai", mime: "application/postscript" }
                : { ext: "pdf", mime: "application/pdf" }
            );
          }
          if (r([0, 97, 115, 109]))
            return { ext: "wasm", mime: "application/wasm" };
          if (r([73, 73, 42, 0]))
            return n("CR", { offset: 8 })
              ? { ext: "cr2", mime: "image/x-canon-cr2" }
              : r([28, 0, 254, 0], { offset: 8 }) ||
                r([31, 0, 11, 0], { offset: 8 })
              ? { ext: "nef", mime: "image/x-nikon-nef" }
              : r([8, 0, 0, 0], { offset: 4 }) &&
                (r([45, 0, 254, 0], { offset: 8 }) ||
                  r([39, 0, 254, 0], { offset: 8 }))
              ? { ext: "dng", mime: "image/x-adobe-dng" }
              : ((t = Buffer.alloc(24)),
                await e.peekBuffer(t),
                (r([16, 251, 134, 1], { offset: 4 }) ||
                  r([8, 0, 0, 0], { offset: 4 })) &&
                r([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], {
                  offset: 9,
                })
                  ? { ext: "arw", mime: "image/x-sony-arw" }
                  : { ext: "tif", mime: "image/tiff" });
          if (r([77, 77, 0, 42])) return { ext: "tif", mime: "image/tiff" };
          if (n("MAC ")) return { ext: "ape", mime: "audio/ape" };
          if (r([26, 69, 223, 163])) {
            async function p() {
              const t = await e.peekNumber(Token.UINT8);
              let r = 128,
                n = 0;
              for (; 0 == (t & r); ) ++n, (r >>= 1);
              const i = Buffer.alloc(n + 1);
              return await e.readBuffer(i), i;
            }
            async function f() {
              const e = await p(),
                t = await p();
              t[0] ^= 128 >> (t.length - 1);
              const r = Math.min(6, t.length);
              return {
                id: e.readUIntBE(0, e.length),
                len: t.readUIntBE(t.length - r, r),
              };
            }
            async function m(t, r) {
              for (; r > 0; ) {
                const t = await f();
                if (17026 === t.id)
                  return e.readToken(new Token.StringType(t.len, "utf-8"));
                await e.ignore(t.len), --r;
              }
            }
            const h = await f();
            switch (await m(0, h.len)) {
              case "webm":
                return { ext: "webm", mime: "video/webm" };
              case "matroska":
                return { ext: "mkv", mime: "video/x-matroska" };
              default:
                return;
            }
          }
          if (r([82, 73, 70, 70])) {
            if (r([65, 86, 73], { offset: 8 }))
              return { ext: "avi", mime: "video/vnd.avi" };
            if (r([87, 65, 86, 69], { offset: 8 }))
              return { ext: "wav", mime: "audio/vnd.wave" };
            if (r([81, 76, 67, 77], { offset: 8 }))
              return { ext: "qcp", mime: "audio/qcelp" };
          }
          if (n("SQLi"))
            return { ext: "sqlite", mime: "application/x-sqlite3" };
          if (r([78, 69, 83, 26]))
            return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
          if (n("Cr24"))
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension",
            };
          if (n("MSCF") || n("ISc("))
            return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
          if (r([237, 171, 238, 219]))
            return { ext: "rpm", mime: "application/x-rpm" };
          if (r([197, 208, 211, 198]))
            return { ext: "eps", mime: "application/eps" };
          if (r([40, 181, 47, 253]))
            return { ext: "zst", mime: "application/zstd" };
          if (r([79, 84, 84, 79, 0])) return { ext: "otf", mime: "font/otf" };
          if (n("#!AMR")) return { ext: "amr", mime: "audio/amr" };
          if (n("{\\rtf")) return { ext: "rtf", mime: "application/rtf" };
          if (r([70, 76, 86, 1])) return { ext: "flv", mime: "video/x-flv" };
          if (n("IMPM")) return { ext: "it", mime: "audio/x-it" };
          if (
            n("-lh0-", { offset: 2 }) ||
            n("-lh1-", { offset: 2 }) ||
            n("-lh2-", { offset: 2 }) ||
            n("-lh3-", { offset: 2 }) ||
            n("-lh4-", { offset: 2 }) ||
            n("-lh5-", { offset: 2 }) ||
            n("-lh6-", { offset: 2 }) ||
            n("-lh7-", { offset: 2 }) ||
            n("-lzs-", { offset: 2 }) ||
            n("-lz4-", { offset: 2 }) ||
            n("-lz5-", { offset: 2 }) ||
            n("-lhd-", { offset: 2 })
          )
            return { ext: "lzh", mime: "application/x-lzh-compressed" };
          if (r([0, 0, 1, 186])) {
            if (r([33], { offset: 4, mask: [241] }))
              return { ext: "mpg", mime: "video/MP1S" };
            if (r([68], { offset: 4, mask: [196] }))
              return { ext: "mpg", mime: "video/MP2P" };
          }
          if (n("ITSF"))
            return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
          if (r([253, 55, 122, 88, 90, 0]))
            return { ext: "xz", mime: "application/x-xz" };
          if (n("<?xml ")) return { ext: "xml", mime: "application/xml" };
          if (r([55, 122, 188, 175, 39, 28]))
            return { ext: "7z", mime: "application/x-7z-compressed" };
          if (r([82, 97, 114, 33, 26, 7]) && (0 === t[6] || 1 === t[6]))
            return { ext: "rar", mime: "application/x-rar-compressed" };
          if (n("solid ")) return { ext: "stl", mime: "model/stl" };
          if (n("BLENDER"))
            return { ext: "blend", mime: "application/x-blender" };
          if (n("!<arch>"))
            return (
              await e.ignore(8),
              "debian-binary" ===
              (await e.readToken(new Token.StringType(13, "ascii")))
                ? { ext: "deb", mime: "application/x-deb" }
                : { ext: "ar", mime: "application/x-unix-archive" }
            );
          if (r([137, 80, 78, 71, 13, 10, 26, 10])) {
            async function g() {
              return {
                length: await e.readToken(Token.INT32_BE),
                type: await e.readToken(new Token.StringType(4, "binary")),
              };
            }
            await e.ignore(8);
            do {
              const y = await g();
              if (y.length < 0) return;
              switch (y.type) {
                case "IDAT":
                  return { ext: "png", mime: "image/png" };
                case "acTL":
                  return { ext: "apng", mime: "image/apng" };
                default:
                  await e.ignore(y.length + 4);
              }
            } while (e.position + 8 < e.fileInfo.size);
            return { ext: "png", mime: "image/png" };
          }
          if (r([65, 82, 82, 79, 87, 49, 0, 0]))
            return { ext: "arrow", mime: "application/x-apache-arrow" };
          if (r([103, 108, 84, 70, 2, 0, 0, 0]))
            return { ext: "glb", mime: "model/gltf-binary" };
          if (
            r([102, 114, 101, 101], { offset: 4 }) ||
            r([109, 100, 97, 116], { offset: 4 }) ||
            r([109, 111, 111, 118], { offset: 4 }) ||
            r([119, 105, 100, 101], { offset: 4 })
          )
            return { ext: "mov", mime: "video/quicktime" };
          if (r([73, 73, 82, 79, 8, 0, 0, 0, 24]))
            return { ext: "orf", mime: "image/x-olympus-orf" };
          if (n("gimp xcf ")) return { ext: "xcf", mime: "image/x-xcf" };
          if (r([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
            return { ext: "rw2", mime: "image/x-panasonic-rw2" };
          if (r([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            async function b() {
              const t = Buffer.alloc(16);
              return (
                await e.readBuffer(t),
                { id: t, size: Number(await e.readToken(Token.UINT64_LE)) }
              );
            }
            for (await e.ignore(30); e.position + 24 < e.fileInfo.size; ) {
              const _ = await b();
              let v = _.size - 24;
              if (
                _check(
                  _.id,
                  [
                    145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12,
                    32, 83, 101,
                  ]
                )
              ) {
                const x = Buffer.alloc(16);
                if (
                  ((v -= await e.readBuffer(x)),
                  _check(
                    x,
                    [
                      64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95,
                      92, 68, 43,
                    ]
                  ))
                )
                  return { ext: "asf", mime: "audio/x-ms-asf" };
                if (
                  _check(
                    x,
                    [
                      192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95,
                      92, 68, 43,
                    ]
                  )
                )
                  return { ext: "asf", mime: "video/x-ms-asf" };
                break;
              }
              await e.ignore(v);
            }
            return { ext: "asf", mime: "application/vnd.ms-asf" };
          }
          if (r([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
            return { ext: "ktx", mime: "image/ktx" };
          if (
            (r([126, 16, 4]) || r([126, 24, 4])) &&
            r([48, 77, 73, 69], { offset: 4 })
          )
            return { ext: "mie", mime: "application/x-mie" };
          if (r([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
            return { ext: "shp", mime: "application/x-esri-shape" };
          if (r([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
            switch (
              (await e.ignore(20),
              await e.readToken(new Token.StringType(4, "ascii")))
            ) {
              case "jp2 ":
                return { ext: "jp2", mime: "image/jp2" };
              case "jpx ":
                return { ext: "jpx", mime: "image/jpx" };
              case "jpm ":
                return { ext: "jpm", mime: "image/jpm" };
              case "mjp2":
                return { ext: "mj2", mime: "image/mj2" };
              default:
                return;
            }
          if (r([255, 10]) || r([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
            return { ext: "jxl", mime: "image/jxl" };
          if (r([0, 0, 1, 186]) || r([0, 0, 1, 179]))
            return { ext: "mpg", mime: "video/mpeg" };
          if (r([0, 1, 0, 0, 0])) return { ext: "ttf", mime: "font/ttf" };
          if (r([0, 0, 1, 0])) return { ext: "ico", mime: "image/x-icon" };
          if (r([0, 0, 2, 0])) return { ext: "cur", mime: "image/x-icon" };
          if (r([208, 207, 17, 224, 161, 177, 26, 225]))
            return { ext: "cfb", mime: "application/x-cfb" };
          if (
            (await e.peekBuffer(t, {
              length: Math.min(256, e.fileInfo.size),
              mayBeLess: !0,
            }),
            n("BEGIN:"))
          ) {
            if (n("VCARD", { offset: 6 }))
              return { ext: "vcf", mime: "text/vcard" };
            if (n("VCALENDAR", { offset: 6 }))
              return { ext: "ics", mime: "text/calendar" };
          }
          if (n("FUJIFILMCCD-RAW"))
            return { ext: "raf", mime: "image/x-fujifilm-raf" };
          if (n("Extended Module:")) return { ext: "xm", mime: "audio/x-xm" };
          if (n("Creative Voice File"))
            return { ext: "voc", mime: "audio/x-voc" };
          if (r([4, 0, 0, 0]) && t.length >= 16) {
            const S = t.readUInt32LE(12);
            if (S > 12 && t.length >= S + 16)
              try {
                const E = t.slice(16, S + 16).toString();
                if (JSON.parse(E).files)
                  return { ext: "asar", mime: "application/x-asar" };
              } catch (w) {}
          }
          if (r([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
            return { ext: "mxf", mime: "application/mxf" };
          if (n("SCRM", { offset: 44 }))
            return { ext: "s3m", mime: "audio/x-s3m" };
          if (
            r([71], { offset: 4 }) &&
            (r([71], { offset: 192 }) || r([71], { offset: 196 }))
          )
            return { ext: "mts", mime: "video/mp2t" };
          if (r([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
            return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
          if (r([68, 73, 67, 77], { offset: 128 }))
            return { ext: "dcm", mime: "application/dicom" };
          if (
            r([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])
          )
            return { ext: "lnk", mime: "application/x.ms.shortcut" };
          if (r([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
            return { ext: "alias", mime: "application/x.apple.alias" };
          if (
            r([76, 80], { offset: 34 }) &&
            (r([0, 0, 1], { offset: 8 }) ||
              r([1, 0, 2], { offset: 8 }) ||
              r([2, 0, 2], { offset: 8 }))
          )
            return { ext: "eot", mime: "application/vnd.ms-fontobject" };
          if (
            r([
              6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116,
              183, 29,
            ])
          )
            return { ext: "indd", mime: "application/x-indesign" };
          if (
            (await e.peekBuffer(t, {
              length: Math.min(512, e.fileInfo.size),
              mayBeLess: !0,
            }),
            tarHeaderChecksumMatches(t))
          )
            return { ext: "tar", mime: "application/x-tar" };
          if (
            r([
              255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0,
              85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0,
            ])
          )
            return { ext: "skp", mime: "application/vnd.sketchup.skp" };
          if (n("-----BEGIN PGP MESSAGE-----"))
            return { ext: "pgp", mime: "application/pgp-encrypted" };
          if (t.length >= 2 && r([255, 224], { offset: 0, mask: [255, 224] })) {
            if (r([16], { offset: 1, mask: [22] }))
              return (
                r([8], { offset: 1, mask: [8] }),
                { ext: "aac", mime: "audio/aac" }
              );
            if (r([2], { offset: 1, mask: [6] }))
              return { ext: "mp3", mime: "audio/mpeg" };
            if (r([4], { offset: 1, mask: [6] }))
              return { ext: "mp2", mime: "audio/mpeg" };
            if (r([6], { offset: 1, mask: [6] }))
              return { ext: "mp1", mime: "audio/mpeg" };
          }
        }
        const stream = (readableStream) =>
            new Promise((resolve, reject) => {
              const stream = eval("require")("stream");
              readableStream.on("error", reject),
                readableStream.once("readable", async () => {
                  const e = new stream.PassThrough();
                  let t;
                  t = stream.pipeline
                    ? stream.pipeline(readableStream, e, () => {})
                    : readableStream.pipe(e);
                  const r =
                    readableStream.read(minimumBytes) ||
                    readableStream.read() ||
                    Buffer.alloc(0);
                  try {
                    const t = await fromBuffer(r);
                    e.fileType = t;
                  } catch (e) {
                    reject(e);
                  }
                  resolve(t);
                });
            }),
          fileType = { fromStream, fromTokenizer, fromBuffer, stream };
        Object.defineProperty(fileType, "extensions", {
          get: () => new Set(supported.extensions),
        }),
          Object.defineProperty(fileType, "mimeTypes", {
            get: () => new Set(supported.mimeTypes),
          }),
          (module.exports = fileType);
      },
      7769: (e, t, r) => {
        "use strict";
        const n = r(6597),
          i = r(1),
          o = {
            fromFile: async function (e) {
              const t = await n.fromFile(e);
              try {
                return await i.fromTokenizer(t);
              } finally {
                await t.close();
              }
            },
          };
        Object.assign(o, i),
          Object.defineProperty(o, "extensions", { get: () => i.extensions }),
          Object.defineProperty(o, "mimeTypes", { get: () => i.mimeTypes }),
          (e.exports = o);
      },
      9898: (e) => {
        "use strict";
        e.exports = {
          extensions: [
            "jpg",
            "png",
            "apng",
            "gif",
            "webp",
            "flif",
            "xcf",
            "cr2",
            "cr3",
            "orf",
            "arw",
            "dng",
            "nef",
            "rw2",
            "raf",
            "tif",
            "bmp",
            "icns",
            "jxr",
            "psd",
            "indd",
            "zip",
            "tar",
            "rar",
            "gz",
            "bz2",
            "7z",
            "dmg",
            "mp4",
            "mid",
            "mkv",
            "webm",
            "mov",
            "avi",
            "mpg",
            "mp2",
            "mp3",
            "m4a",
            "oga",
            "ogg",
            "ogv",
            "opus",
            "flac",
            "wav",
            "spx",
            "amr",
            "pdf",
            "epub",
            "exe",
            "swf",
            "rtf",
            "wasm",
            "woff",
            "woff2",
            "eot",
            "ttf",
            "otf",
            "ico",
            "flv",
            "ps",
            "xz",
            "sqlite",
            "nes",
            "crx",
            "xpi",
            "cab",
            "deb",
            "ar",
            "rpm",
            "Z",
            "lz",
            "cfb",
            "mxf",
            "mts",
            "blend",
            "bpg",
            "docx",
            "pptx",
            "xlsx",
            "3gp",
            "3g2",
            "jp2",
            "jpm",
            "jpx",
            "mj2",
            "aif",
            "qcp",
            "odt",
            "ods",
            "odp",
            "xml",
            "mobi",
            "heic",
            "cur",
            "ktx",
            "ape",
            "wv",
            "dcm",
            "ics",
            "glb",
            "pcap",
            "dsf",
            "lnk",
            "alias",
            "voc",
            "ac3",
            "m4v",
            "m4p",
            "m4b",
            "f4v",
            "f4p",
            "f4b",
            "f4a",
            "mie",
            "asf",
            "ogm",
            "ogx",
            "mpc",
            "arrow",
            "shp",
            "aac",
            "mp1",
            "it",
            "s3m",
            "xm",
            "ai",
            "skp",
            "avif",
            "eps",
            "lzh",
            "pgp",
            "asar",
            "stl",
            "chm",
            "3mf",
            "zst",
            "jxl",
            "vcf",
          ],
          mimeTypes: [
            "image/jpeg",
            "image/png",
            "image/gif",
            "image/webp",
            "image/flif",
            "image/x-xcf",
            "image/x-canon-cr2",
            "image/x-canon-cr3",
            "image/tiff",
            "image/bmp",
            "image/vnd.ms-photo",
            "image/vnd.adobe.photoshop",
            "application/x-indesign",
            "application/epub+zip",
            "application/x-xpinstall",
            "application/vnd.oasis.opendocument.text",
            "application/vnd.oasis.opendocument.spreadsheet",
            "application/vnd.oasis.opendocument.presentation",
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            "application/vnd.openxmlformats-officedocument.presentationml.presentation",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "application/zip",
            "application/x-tar",
            "application/x-rar-compressed",
            "application/gzip",
            "application/x-bzip2",
            "application/x-7z-compressed",
            "application/x-apple-diskimage",
            "application/x-apache-arrow",
            "video/mp4",
            "audio/midi",
            "video/x-matroska",
            "video/webm",
            "video/quicktime",
            "video/vnd.avi",
            "audio/vnd.wave",
            "audio/qcelp",
            "audio/x-ms-asf",
            "video/x-ms-asf",
            "application/vnd.ms-asf",
            "video/mpeg",
            "video/3gpp",
            "audio/mpeg",
            "audio/mp4",
            "audio/opus",
            "video/ogg",
            "audio/ogg",
            "application/ogg",
            "audio/x-flac",
            "audio/ape",
            "audio/wavpack",
            "audio/amr",
            "application/pdf",
            "application/x-msdownload",
            "application/x-shockwave-flash",
            "application/rtf",
            "application/wasm",
            "font/woff",
            "font/woff2",
            "application/vnd.ms-fontobject",
            "font/ttf",
            "font/otf",
            "image/x-icon",
            "video/x-flv",
            "application/postscript",
            "application/eps",
            "application/x-xz",
            "application/x-sqlite3",
            "application/x-nintendo-nes-rom",
            "application/x-google-chrome-extension",
            "application/vnd.ms-cab-compressed",
            "application/x-deb",
            "application/x-unix-archive",
            "application/x-rpm",
            "application/x-compress",
            "application/x-lzip",
            "application/x-cfb",
            "application/x-mie",
            "application/mxf",
            "video/mp2t",
            "application/x-blender",
            "image/bpg",
            "image/jp2",
            "image/jpx",
            "image/jpm",
            "image/mj2",
            "audio/aiff",
            "application/xml",
            "application/x-mobipocket-ebook",
            "image/heif",
            "image/heif-sequence",
            "image/heic",
            "image/heic-sequence",
            "image/icns",
            "image/ktx",
            "application/dicom",
            "audio/x-musepack",
            "text/calendar",
            "text/vcard",
            "model/gltf-binary",
            "application/vnd.tcpdump.pcap",
            "audio/x-dsf",
            "application/x.ms.shortcut",
            "application/x.apple.alias",
            "audio/x-voc",
            "audio/vnd.dolby.dd-raw",
            "audio/x-m4a",
            "image/apng",
            "image/x-olympus-orf",
            "image/x-sony-arw",
            "image/x-adobe-dng",
            "image/x-nikon-nef",
            "image/x-panasonic-rw2",
            "image/x-fujifilm-raf",
            "video/x-m4v",
            "video/3gpp2",
            "application/x-esri-shape",
            "audio/aac",
            "audio/x-it",
            "audio/x-s3m",
            "audio/x-xm",
            "video/MP1S",
            "video/MP2P",
            "application/vnd.sketchup.skp",
            "image/avif",
            "application/x-lzh-compressed",
            "application/pgp-encrypted",
            "application/x-asar",
            "model/stl",
            "application/vnd.ms-htmlhelp",
            "model/3mf",
            "image/jxl",
            "application/zstd",
          ],
        };
      },
      6188: (e, t) => {
        "use strict";
        (t.stringToBytes = (e) => [...e].map((e) => e.charCodeAt(0))),
          (t.tarHeaderChecksumMatches = (e, t = 0) => {
            const r = parseInt(
              e.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(),
              8
            );
            if (isNaN(r)) return !1;
            let n = 256;
            for (let r = t; r < t + 148; r++) n += e[r];
            for (let r = t + 156; r < t + 512; r++) n += e[r];
            return r === n;
          }),
          (t.uint32SyncSafeToken = {
            get: (e, t) =>
              (127 & e[t + 3]) |
              (e[t + 2] << 7) |
              (e[t + 1] << 14) |
              (e[t] << 21),
            len: 4,
          });
      },
      2664: (e, t, r) => {
        "use strict";
        const n = r(3837),
          i = r(5702),
          o = (e) => null !== e && "object" == typeof e && !Array.isArray(e),
          s = (e) => "number" == typeof e || ("string" == typeof e && "" !== e),
          a = (e) => Number.isInteger(+e),
          c = (e) => {
            let t = `${e}`,
              r = -1;
            if (("-" === t[0] && (t = t.slice(1)), "0" === t)) return !1;
            for (; "0" === t[++r]; );
            return r > 0;
          },
          u = (e, t, r) => {
            if (t > 0) {
              let r = "-" === e[0] ? "-" : "";
              r && (e = e.slice(1)), (e = r + e.padStart(r ? t - 1 : t, "0"));
            }
            return !1 === r ? String(e) : e;
          },
          l = (e, t) => {
            let r = "-" === e[0] ? "-" : "";
            for (r && ((e = e.slice(1)), t--); e.length < t; ) e = "0" + e;
            return r ? "-" + e : e;
          },
          d = (e, t, r, n) => {
            if (r) return i(e, t, { wrap: !1, ...n });
            let o = String.fromCharCode(e);
            return e === t ? o : `[${o}-${String.fromCharCode(t)}]`;
          },
          p = (e, t, r) => {
            if (Array.isArray(e)) {
              let t = !0 === r.wrap,
                n = r.capture ? "" : "?:";
              return t ? `(${n}${e.join("|")})` : e.join("|");
            }
            return i(e, t, r);
          },
          f = (...e) =>
            new RangeError("Invalid range arguments: " + n.inspect(...e)),
          m = (e, t, r) => {
            if (!0 === r.strictRanges) throw f([e, t]);
            return [];
          },
          h = (e, t, r, n = {}) => {
            if (null == t && s(e)) return [e];
            if (!s(e) || !s(t)) return m(e, t, n);
            if ("function" == typeof r) return h(e, t, 1, { transform: r });
            if (o(r)) return h(e, t, 0, r);
            let i = { ...n };
            return (
              !0 === i.capture && (i.wrap = !0),
              (r = r || i.step || 1),
              a(r)
                ? a(e) && a(t)
                  ? ((e, t, r = 1, n = {}) => {
                      let i = Number(e),
                        o = Number(t);
                      if (!Number.isInteger(i) || !Number.isInteger(o)) {
                        if (!0 === n.strictRanges) throw f([e, t]);
                        return [];
                      }
                      0 === i && (i = 0), 0 === o && (o = 0);
                      let s = i > o,
                        a = String(e),
                        m = String(t),
                        h = String(r);
                      r = Math.max(Math.abs(r), 1);
                      let g = c(a) || c(m) || c(h),
                        y = g ? Math.max(a.length, m.length, h.length) : 0,
                        b =
                          !1 === g &&
                          !1 ===
                            ((e, t, r) =>
                              "string" == typeof e ||
                              "string" == typeof t ||
                              !0 === r.stringify)(e, t, n),
                        _ =
                          n.transform ||
                          (
                            (e) => (t) =>
                              !0 === e ? Number(t) : String(t)
                          )(b);
                      if (n.toRegex && 1 === r)
                        return d(l(e, y), l(t, y), !0, n);
                      let v = { negatives: [], positives: [] },
                        x = [],
                        S = 0;
                      for (; s ? i >= o : i <= o; )
                        !0 === n.toRegex && r > 1
                          ? v[(E = i) < 0 ? "negatives" : "positives"].push(
                              Math.abs(E)
                            )
                          : x.push(u(_(i, S), y, b)),
                          (i = s ? i - r : i + r),
                          S++;
                      var E;
                      return !0 === n.toRegex
                        ? r > 1
                          ? ((e, t) => {
                              e.negatives.sort((e, t) =>
                                e < t ? -1 : e > t ? 1 : 0
                              ),
                                e.positives.sort((e, t) =>
                                  e < t ? -1 : e > t ? 1 : 0
                                );
                              let r,
                                n = t.capture ? "" : "?:",
                                i = "",
                                o = "";
                              return (
                                e.positives.length &&
                                  (i = e.positives.join("|")),
                                e.negatives.length &&
                                  (o = `-(${n}${e.negatives.join("|")})`),
                                (r = i && o ? `${i}|${o}` : i || o),
                                t.wrap ? `(${n}${r})` : r
                              );
                            })(v, n)
                          : p(x, null, { wrap: !1, ...n })
                        : x;
                    })(e, t, r, i)
                  : ((e, t, r = 1, n = {}) => {
                      if ((!a(e) && e.length > 1) || (!a(t) && t.length > 1))
                        return m(e, t, n);
                      let i = n.transform || ((e) => String.fromCharCode(e)),
                        o = `${e}`.charCodeAt(0),
                        s = `${t}`.charCodeAt(0),
                        c = o > s,
                        u = Math.min(o, s),
                        l = Math.max(o, s);
                      if (n.toRegex && 1 === r) return d(u, l, !1, n);
                      let f = [],
                        h = 0;
                      for (; c ? o >= s : o <= s; )
                        f.push(i(o, h)), (o = c ? o - r : o + r), h++;
                      return !0 === n.toRegex
                        ? p(f, null, { wrap: !1, options: n })
                        : f;
                    })(e, t, Math.max(Math.abs(r), 1), i)
                : null == r || o(r)
                ? h(e, t, 1, r)
                : ((e, t) => {
                    if (!0 === t.strictRanges)
                      throw new TypeError(
                        `Expected step "${e}" to be a number`
                      );
                    return [];
                  })(r, i)
            );
          };
        e.exports = h;
      },
      5105: (e, t, r) => {
        "use strict";
        const { PassThrough: n } = r(2781);
        e.exports = (e) => {
          e = { ...e };
          const { array: t } = e;
          let { encoding: r } = e;
          const i = "buffer" === r;
          let o = !1;
          t ? (o = !(r || i)) : (r = r || "utf8"), i && (r = null);
          const s = new n({ objectMode: o });
          r && s.setEncoding(r);
          let a = 0;
          const c = [];
          return (
            s.on("data", (e) => {
              c.push(e), o ? (a = c.length) : (a += e.length);
            }),
            (s.getBufferedValue = () =>
              t ? c : i ? Buffer.concat(c, a) : c.join("")),
            (s.getBufferedLength = () => a),
            s
          );
        };
      },
      31: (e, t, r) => {
        "use strict";
        const { constants: n } = r(4300),
          i = r(2781),
          { promisify: o } = r(3837),
          s = r(5105),
          a = o(i.pipeline);
        class c extends Error {
          constructor() {
            super("maxBuffer exceeded"), (this.name = "MaxBufferError");
          }
        }
        async function u(e, t) {
          if (!e) throw new Error("Expected a stream");
          t = { maxBuffer: 1 / 0, ...t };
          const { maxBuffer: r } = t,
            i = s(t);
          return (
            await new Promise((t, o) => {
              const s = (e) => {
                e &&
                  i.getBufferedLength() <= n.MAX_LENGTH &&
                  (e.bufferedData = i.getBufferedValue()),
                  o(e);
              };
              (async () => {
                try {
                  await a(e, i), t();
                } catch (e) {
                  s(e);
                }
              })(),
                i.on("data", () => {
                  i.getBufferedLength() > r && s(new c());
                });
            }),
            i.getBufferedValue()
          );
        }
        (e.exports = u),
          (e.exports.buffer = (e, t) => u(e, { ...t, encoding: "buffer" })),
          (e.exports.array = (e, t) => u(e, { ...t, array: !0 })),
          (e.exports.MaxBufferError = c);
      },
      7647: (e, t, r) => {
        "use strict";
        var n = r(6830),
          i = r(1017).posix.dirname,
          o = "win32" === r(2037).platform(),
          s = /\\/g,
          a = /[\{\[].*[\}\]]$/,
          c = /(^|[^\\])([\{\[]|\([^\)]+$)/,
          u = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
        e.exports = function (e, t) {
          Object.assign({ flipBackslashes: !0 }, t).flipBackslashes &&
            o &&
            e.indexOf("/") < 0 &&
            (e = e.replace(s, "/")),
            a.test(e) && (e += "/"),
            (e += "a");
          do {
            e = i(e);
          } while (n(e) || c.test(e));
          return e.replace(u, "$1");
        };
      },
      6458: (e) => {
        "use strict";
        e.exports = function (e) {
          if (null === e || "object" != typeof e) return e;
          if (e instanceof Object) var r = { __proto__: t(e) };
          else r = Object.create(null);
          return (
            Object.getOwnPropertyNames(e).forEach(function (t) {
              Object.defineProperty(
                r,
                t,
                Object.getOwnPropertyDescriptor(e, t)
              );
            }),
            r
          );
        };
        var t =
          Object.getPrototypeOf ||
          function (e) {
            return e.__proto__;
          };
      },
      77: (e, t, r) => {
        var n,
          i,
          o = r(7147),
          s = r(2161),
          a = r(8520),
          c = r(6458),
          u = r(3837);
        function l(e, t) {
          Object.defineProperty(e, n, {
            get: function () {
              return t;
            },
          });
        }
        "function" == typeof Symbol && "function" == typeof Symbol.for
          ? ((n = Symbol.for("graceful-fs.queue")),
            (i = Symbol.for("graceful-fs.previous")))
          : ((n = "___graceful-fs.queue"), (i = "___graceful-fs.previous"));
        var d,
          p = function () {};
        if (
          (u.debuglog
            ? (p = u.debuglog("gfs4"))
            : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
              (p = function () {
                var e = u.format.apply(u, arguments);
                (e = "GFS4: " + e.split(/\n/).join("\nGFS4: ")),
                  console.error(e);
              }),
          !o[n])
        ) {
          var f = global[n] || [];
          l(o, f),
            (o.close = (function (e) {
              function t(t, r) {
                return e.call(o, t, function (e) {
                  e || g(), "function" == typeof r && r.apply(this, arguments);
                });
              }
              return Object.defineProperty(t, i, { value: e }), t;
            })(o.close)),
            (o.closeSync = (function (e) {
              function t(t) {
                e.apply(o, arguments), g();
              }
              return Object.defineProperty(t, i, { value: e }), t;
            })(o.closeSync)),
            /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
              process.on("exit", function () {
                p(o[n]), r(9491).equal(o[n].length, 0);
              });
        }
        function m(e) {
          s(e),
            (e.gracefulify = m),
            (e.createReadStream = function (t, r) {
              return new e.ReadStream(t, r);
            }),
            (e.createWriteStream = function (t, r) {
              return new e.WriteStream(t, r);
            });
          var t = e.readFile;
          e.readFile = function (e, r, n) {
            return (
              "function" == typeof r && ((n = r), (r = null)),
              (function e(r, n, i, o) {
                return t(r, n, function (t) {
                  !t || ("EMFILE" !== t.code && "ENFILE" !== t.code)
                    ? "function" == typeof i && i.apply(this, arguments)
                    : h([e, [r, n, i], t, o || Date.now(), Date.now()]);
                });
              })(e, r, n)
            );
          };
          var r = e.writeFile;
          e.writeFile = function (e, t, n, i) {
            return (
              "function" == typeof n && ((i = n), (n = null)),
              (function e(t, n, i, o, s) {
                return r(t, n, i, function (r) {
                  !r || ("EMFILE" !== r.code && "ENFILE" !== r.code)
                    ? "function" == typeof o && o.apply(this, arguments)
                    : h([e, [t, n, i, o], r, s || Date.now(), Date.now()]);
                });
              })(e, t, n, i)
            );
          };
          var n = e.appendFile;
          n &&
            (e.appendFile = function (e, t, r, i) {
              return (
                "function" == typeof r && ((i = r), (r = null)),
                (function e(t, r, i, o, s) {
                  return n(t, r, i, function (n) {
                    !n || ("EMFILE" !== n.code && "ENFILE" !== n.code)
                      ? "function" == typeof o && o.apply(this, arguments)
                      : h([e, [t, r, i, o], n, s || Date.now(), Date.now()]);
                  });
                })(e, t, r, i)
              );
            });
          var i = e.copyFile;
          i &&
            (e.copyFile = function (e, t, r, n) {
              return (
                "function" == typeof r && ((n = r), (r = 0)),
                (function e(t, r, n, o, s) {
                  return i(t, r, n, function (i) {
                    !i || ("EMFILE" !== i.code && "ENFILE" !== i.code)
                      ? "function" == typeof o && o.apply(this, arguments)
                      : h([e, [t, r, n, o], i, s || Date.now(), Date.now()]);
                  });
                })(e, t, r, n)
              );
            });
          var o = e.readdir;
          e.readdir = function (e, t, r) {
            "function" == typeof t && ((r = t), (t = null));
            var n = c.test(process.version)
              ? function (e, t, r, n) {
                  return o(e, i(e, t, r, n));
                }
              : function (e, t, r, n) {
                  return o(e, t, i(e, t, r, n));
                };
            return n(e, t, r);
            function i(e, t, r, i) {
              return function (o, s) {
                !o || ("EMFILE" !== o.code && "ENFILE" !== o.code)
                  ? (s && s.sort && s.sort(),
                    "function" == typeof r && r.call(this, o, s))
                  : h([n, [e, t, r], o, i || Date.now(), Date.now()]);
              };
            }
          };
          var c = /^v[0-5]\./;
          if ("v0.8" === process.version.substr(0, 4)) {
            var u = a(e);
            (g = u.ReadStream), (y = u.WriteStream);
          }
          var l = e.ReadStream;
          l &&
            ((g.prototype = Object.create(l.prototype)),
            (g.prototype.open = function () {
              var e = this;
              _(e.path, e.flags, e.mode, function (t, r) {
                t
                  ? (e.autoClose && e.destroy(), e.emit("error", t))
                  : ((e.fd = r), e.emit("open", r), e.read());
              });
            }));
          var d = e.WriteStream;
          d &&
            ((y.prototype = Object.create(d.prototype)),
            (y.prototype.open = function () {
              var e = this;
              _(e.path, e.flags, e.mode, function (t, r) {
                t
                  ? (e.destroy(), e.emit("error", t))
                  : ((e.fd = r), e.emit("open", r));
              });
            })),
            Object.defineProperty(e, "ReadStream", {
              get: function () {
                return g;
              },
              set: function (e) {
                g = e;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(e, "WriteStream", {
              get: function () {
                return y;
              },
              set: function (e) {
                y = e;
              },
              enumerable: !0,
              configurable: !0,
            });
          var p = g;
          Object.defineProperty(e, "FileReadStream", {
            get: function () {
              return p;
            },
            set: function (e) {
              p = e;
            },
            enumerable: !0,
            configurable: !0,
          });
          var f = y;
          function g(e, t) {
            return this instanceof g
              ? (l.apply(this, arguments), this)
              : g.apply(Object.create(g.prototype), arguments);
          }
          function y(e, t) {
            return this instanceof y
              ? (d.apply(this, arguments), this)
              : y.apply(Object.create(y.prototype), arguments);
          }
          Object.defineProperty(e, "FileWriteStream", {
            get: function () {
              return f;
            },
            set: function (e) {
              f = e;
            },
            enumerable: !0,
            configurable: !0,
          });
          var b = e.open;
          function _(e, t, r, n) {
            return (
              "function" == typeof r && ((n = r), (r = null)),
              (function e(t, r, n, i, o) {
                return b(t, r, n, function (s, a) {
                  !s || ("EMFILE" !== s.code && "ENFILE" !== s.code)
                    ? "function" == typeof i && i.apply(this, arguments)
                    : h([e, [t, r, n, i], s, o || Date.now(), Date.now()]);
                });
              })(e, t, r, n)
            );
          }
          return (e.open = _), e;
        }
        function h(e) {
          p("ENQUEUE", e[0].name, e[1]), o[n].push(e), y();
        }
        function g() {
          for (var e = Date.now(), t = 0; t < o[n].length; ++t)
            o[n][t].length > 2 && ((o[n][t][3] = e), (o[n][t][4] = e));
          y();
        }
        function y() {
          if ((clearTimeout(d), (d = void 0), 0 !== o[n].length)) {
            var e = o[n].shift(),
              t = e[0],
              r = e[1],
              i = e[2],
              s = e[3],
              a = e[4];
            if (void 0 === s) p("RETRY", t.name, r), t.apply(null, r);
            else if (Date.now() - s >= 6e4) {
              p("TIMEOUT", t.name, r);
              var c = r.pop();
              "function" == typeof c && c.call(null, i);
            } else {
              var u = Date.now() - a,
                l = Math.max(a - s, 1);
              u >= Math.min(1.2 * l, 100)
                ? (p("RETRY", t.name, r), t.apply(null, r.concat([s])))
                : o[n].push(e);
            }
            void 0 === d && (d = setTimeout(y, 0));
          }
        }
        global[n] || l(global, o[n]),
          (e.exports = m(c(o))),
          process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH &&
            !o.__patched &&
            ((e.exports = m(o)), (o.__patched = !0));
      },
      8520: (e, t, r) => {
        var n = r(2781).Stream;
        e.exports = function (e) {
          return {
            ReadStream: function t(r, i) {
              if (!(this instanceof t)) return new t(r, i);
              n.call(this);
              var o = this;
              (this.path = r),
                (this.fd = null),
                (this.readable = !0),
                (this.paused = !1),
                (this.flags = "r"),
                (this.mode = 438),
                (this.bufferSize = 65536),
                (i = i || {});
              for (var s = Object.keys(i), a = 0, c = s.length; a < c; a++) {
                var u = s[a];
                this[u] = i[u];
              }
              if (
                (this.encoding && this.setEncoding(this.encoding),
                void 0 !== this.start)
              ) {
                if ("number" != typeof this.start)
                  throw TypeError("start must be a Number");
                if (void 0 === this.end) this.end = 1 / 0;
                else if ("number" != typeof this.end)
                  throw TypeError("end must be a Number");
                if (this.start > this.end)
                  throw new Error("start must be <= end");
                this.pos = this.start;
              }
              null === this.fd
                ? e.open(this.path, this.flags, this.mode, function (e, t) {
                    if (e) return o.emit("error", e), void (o.readable = !1);
                    (o.fd = t), o.emit("open", t), o._read();
                  })
                : process.nextTick(function () {
                    o._read();
                  });
            },
            WriteStream: function t(r, i) {
              if (!(this instanceof t)) return new t(r, i);
              n.call(this),
                (this.path = r),
                (this.fd = null),
                (this.writable = !0),
                (this.flags = "w"),
                (this.encoding = "binary"),
                (this.mode = 438),
                (this.bytesWritten = 0),
                (i = i || {});
              for (var o = Object.keys(i), s = 0, a = o.length; s < a; s++) {
                var c = o[s];
                this[c] = i[c];
              }
              if (void 0 !== this.start) {
                if ("number" != typeof this.start)
                  throw TypeError("start must be a Number");
                if (this.start < 0) throw new Error("start must be >= zero");
                this.pos = this.start;
              }
              (this.busy = !1),
                (this._queue = []),
                null === this.fd &&
                  ((this._open = e.open),
                  this._queue.push([
                    this._open,
                    this.path,
                    this.flags,
                    this.mode,
                    void 0,
                  ]),
                  this.flush());
            },
          };
        };
      },
      2161: (e, t, r) => {
        var n = r(2057),
          i = process.cwd,
          o = null,
          s = process.env.GRACEFUL_FS_PLATFORM || process.platform;
        process.cwd = function () {
          return o || (o = i.call(process)), o;
        };
        try {
          process.cwd();
        } catch (e) {}
        if ("function" == typeof process.chdir) {
          var a = process.chdir;
          (process.chdir = function (e) {
            (o = null), a.call(process, e);
          }),
            Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, a);
        }
        e.exports = function (e) {
          function t(t) {
            return t
              ? function (r, n, i) {
                  return t.call(e, r, n, function (e) {
                    u(e) && (e = null), i && i.apply(this, arguments);
                  });
                }
              : t;
          }
          function r(t) {
            return t
              ? function (r, n) {
                  try {
                    return t.call(e, r, n);
                  } catch (e) {
                    if (!u(e)) throw e;
                  }
                }
              : t;
          }
          function i(t) {
            return t
              ? function (r, n, i, o) {
                  return t.call(e, r, n, i, function (e) {
                    u(e) && (e = null), o && o.apply(this, arguments);
                  });
                }
              : t;
          }
          function o(t) {
            return t
              ? function (r, n, i) {
                  try {
                    return t.call(e, r, n, i);
                  } catch (e) {
                    if (!u(e)) throw e;
                  }
                }
              : t;
          }
          function a(t) {
            return t
              ? function (r, n, i) {
                  function o(e, t) {
                    t &&
                      (t.uid < 0 && (t.uid += 4294967296),
                      t.gid < 0 && (t.gid += 4294967296)),
                      i && i.apply(this, arguments);
                  }
                  return (
                    "function" == typeof n && ((i = n), (n = null)),
                    n ? t.call(e, r, n, o) : t.call(e, r, o)
                  );
                }
              : t;
          }
          function c(t) {
            return t
              ? function (r, n) {
                  var i = n ? t.call(e, r, n) : t.call(e, r);
                  return (
                    i &&
                      (i.uid < 0 && (i.uid += 4294967296),
                      i.gid < 0 && (i.gid += 4294967296)),
                    i
                  );
                }
              : t;
          }
          function u(e) {
            return (
              !e ||
              "ENOSYS" === e.code ||
              !(
                (process.getuid && 0 === process.getuid()) ||
                ("EINVAL" !== e.code && "EPERM" !== e.code)
              )
            );
          }
          var l;
          n.hasOwnProperty("O_SYMLINK") &&
            process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) &&
            (function (e) {
              (e.lchmod = function (t, r, i) {
                e.open(t, n.O_WRONLY | n.O_SYMLINK, r, function (t, n) {
                  t
                    ? i && i(t)
                    : e.fchmod(n, r, function (t) {
                        e.close(n, function (e) {
                          i && i(t || e);
                        });
                      });
                });
              }),
                (e.lchmodSync = function (t, r) {
                  var i,
                    o = e.openSync(t, n.O_WRONLY | n.O_SYMLINK, r),
                    s = !0;
                  try {
                    (i = e.fchmodSync(o, r)), (s = !1);
                  } finally {
                    if (s)
                      try {
                        e.closeSync(o);
                      } catch (e) {}
                    else e.closeSync(o);
                  }
                  return i;
                });
            })(e),
            e.lutimes ||
              (function (e) {
                n.hasOwnProperty("O_SYMLINK") && e.futimes
                  ? ((e.lutimes = function (t, r, i, o) {
                      e.open(t, n.O_SYMLINK, function (t, n) {
                        t
                          ? o && o(t)
                          : e.futimes(n, r, i, function (t) {
                              e.close(n, function (e) {
                                o && o(t || e);
                              });
                            });
                      });
                    }),
                    (e.lutimesSync = function (t, r, i) {
                      var o,
                        s = e.openSync(t, n.O_SYMLINK),
                        a = !0;
                      try {
                        (o = e.futimesSync(s, r, i)), (a = !1);
                      } finally {
                        if (a)
                          try {
                            e.closeSync(s);
                          } catch (e) {}
                        else e.closeSync(s);
                      }
                      return o;
                    }))
                  : e.futimes &&
                    ((e.lutimes = function (e, t, r, n) {
                      n && process.nextTick(n);
                    }),
                    (e.lutimesSync = function () {}));
              })(e),
            (e.chown = i(e.chown)),
            (e.fchown = i(e.fchown)),
            (e.lchown = i(e.lchown)),
            (e.chmod = t(e.chmod)),
            (e.fchmod = t(e.fchmod)),
            (e.lchmod = t(e.lchmod)),
            (e.chownSync = o(e.chownSync)),
            (e.fchownSync = o(e.fchownSync)),
            (e.lchownSync = o(e.lchownSync)),
            (e.chmodSync = r(e.chmodSync)),
            (e.fchmodSync = r(e.fchmodSync)),
            (e.lchmodSync = r(e.lchmodSync)),
            (e.stat = a(e.stat)),
            (e.fstat = a(e.fstat)),
            (e.lstat = a(e.lstat)),
            (e.statSync = c(e.statSync)),
            (e.fstatSync = c(e.fstatSync)),
            (e.lstatSync = c(e.lstatSync)),
            e.chmod &&
              !e.lchmod &&
              ((e.lchmod = function (e, t, r) {
                r && process.nextTick(r);
              }),
              (e.lchmodSync = function () {})),
            e.chown &&
              !e.lchown &&
              ((e.lchown = function (e, t, r, n) {
                n && process.nextTick(n);
              }),
              (e.lchownSync = function () {})),
            "win32" === s &&
              (e.rename =
                "function" != typeof e.rename
                  ? e.rename
                  : (function (t) {
                      function r(r, n, i) {
                        var o = Date.now(),
                          s = 0;
                        t(r, n, function a(c) {
                          if (
                            c &&
                            ("EACCES" === c.code || "EPERM" === c.code) &&
                            Date.now() - o < 6e4
                          )
                            return (
                              setTimeout(function () {
                                e.stat(n, function (e, o) {
                                  e && "ENOENT" === e.code ? t(r, n, a) : i(c);
                                });
                              }, s),
                              void (s < 100 && (s += 10))
                            );
                          i && i(c);
                        });
                      }
                      return (
                        Object.setPrototypeOf && Object.setPrototypeOf(r, t), r
                      );
                    })(e.rename)),
            (e.read =
              "function" != typeof e.read
                ? e.read
                : (function (t) {
                    function r(r, n, i, o, s, a) {
                      var c;
                      if (a && "function" == typeof a) {
                        var u = 0;
                        c = function (l, d, p) {
                          if (l && "EAGAIN" === l.code && u < 10)
                            return u++, t.call(e, r, n, i, o, s, c);
                          a.apply(this, arguments);
                        };
                      }
                      return t.call(e, r, n, i, o, s, c);
                    }
                    return (
                      Object.setPrototypeOf && Object.setPrototypeOf(r, t), r
                    );
                  })(e.read)),
            (e.readSync =
              "function" != typeof e.readSync
                ? e.readSync
                : ((l = e.readSync),
                  function (t, r, n, i, o) {
                    for (var s = 0; ; )
                      try {
                        return l.call(e, t, r, n, i, o);
                      } catch (e) {
                        if ("EAGAIN" === e.code && s < 10) {
                          s++;
                          continue;
                        }
                        throw e;
                      }
                  }));
        };
      },
      645: (e, t) => {
        (t.read = function (e, t, r, n, i) {
          var o,
            s,
            a = 8 * i - n - 1,
            c = (1 << a) - 1,
            u = c >> 1,
            l = -7,
            d = r ? i - 1 : 0,
            p = r ? -1 : 1,
            f = e[t + d];
          for (
            d += p, o = f & ((1 << -l) - 1), f >>= -l, l += a;
            l > 0;
            o = 256 * o + e[t + d], d += p, l -= 8
          );
          for (
            s = o & ((1 << -l) - 1), o >>= -l, l += n;
            l > 0;
            s = 256 * s + e[t + d], d += p, l -= 8
          );
          if (0 === o) o = 1 - u;
          else {
            if (o === c) return s ? NaN : (1 / 0) * (f ? -1 : 1);
            (s += Math.pow(2, n)), (o -= u);
          }
          return (f ? -1 : 1) * s * Math.pow(2, o - n);
        }),
          (t.write = function (e, t, r, n, i, o) {
            var s,
              a,
              c,
              u = 8 * o - i - 1,
              l = (1 << u) - 1,
              d = l >> 1,
              p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              f = n ? 0 : o - 1,
              m = n ? 1 : -1,
              h = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
            for (
              t = Math.abs(t),
                isNaN(t) || t === 1 / 0
                  ? ((a = isNaN(t) ? 1 : 0), (s = l))
                  : ((s = Math.floor(Math.log(t) / Math.LN2)),
                    t * (c = Math.pow(2, -s)) < 1 && (s--, (c *= 2)),
                    (t += s + d >= 1 ? p / c : p * Math.pow(2, 1 - d)) * c >=
                      2 && (s++, (c /= 2)),
                    s + d >= l
                      ? ((a = 0), (s = l))
                      : s + d >= 1
                      ? ((a = (t * c - 1) * Math.pow(2, i)), (s += d))
                      : ((a = t * Math.pow(2, d - 1) * Math.pow(2, i)),
                        (s = 0)));
              i >= 8;
              e[r + f] = 255 & a, f += m, a /= 256, i -= 8
            );
            for (
              s = (s << i) | a, u += i;
              u > 0;
              e[r + f] = 255 & s, f += m, s /= 256, u -= 8
            );
            e[r + f - m] |= 128 * h;
          });
      },
      5151: (e) => {
        function t(e) {
          return Array.isArray(e) ? e : [e];
        }
        const r = /^\s+$/,
          n = /^\\!/,
          i = /^\\#/,
          o = /\r?\n/g,
          s = /^\.*\/|^\.+$/,
          a =
            "undefined" != typeof Symbol
              ? Symbol.for("node-ignore")
              : "node-ignore",
          c = /([0-z])-([0-z])/g,
          u = () => !1,
          l = [
            [/\\?\s+$/, (e) => (0 === e.indexOf("\\") ? " " : "")],
            [/\\\s/g, () => " "],
            [/[\\$.|*+(){^]/g, (e) => `\\${e}`],
            [/(?!\\)\?/g, () => "[^/]"],
            [/^\//, () => "^"],
            [/\//g, () => "\\/"],
            [/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"],
            [
              /^(?=[^^])/,
              function () {
                return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
              },
            ],
            [
              /\\\/\\\*\\\*(?=\\\/|$)/g,
              (e, t, r) => (t + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"),
            ],
            [/(^|[^\\]+)\\\*(?=.+)/g, (e, t) => `${t}[^\\/]*`],
            [/\\\\\\(?=[$.|*+(){^])/g, () => "\\"],
            [/\\\\/g, () => "\\"],
            [
              /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
              (e, t, r, n, i) =>
                "\\" === t
                  ? `\\[${r}${((e) => {
                      const { length: t } = e;
                      return e.slice(0, t - (t % 2));
                    })(n)}${i}`
                  : "]" === i && n.length % 2 == 0
                  ? `[${((e) =>
                      e.replace(c, (e, t, r) =>
                        t.charCodeAt(0) <= r.charCodeAt(0) ? e : ""
                      ))(r)}${n}]`
                  : "[]",
            ],
            [/(?:[^*])$/, (e) => (/\/$/.test(e) ? `${e}$` : `${e}(?=$|\\/$)`)],
            [
              /(\^|\\\/)?\\\*$/,
              (e, t) => (t ? `${t}[^/]+` : "[^/]*") + "(?=$|\\/$)",
            ],
          ],
          d = Object.create(null),
          p = (e) => "string" == typeof e;
        class f {
          constructor(e, t, r, n) {
            (this.origin = e),
              (this.pattern = t),
              (this.negative = r),
              (this.regex = n);
          }
        }
        const m = (e, t) => {
            throw new t(e);
          },
          h = (e, t, r) =>
            p(e)
              ? e
                ? !h.isNotRelative(e) ||
                  r(
                    `path should be a \`path.relative()\`d string, but got "${t}"`,
                    RangeError
                  )
                : r("path must not be empty", TypeError)
              : r(`path must be a string, but got \`${t}\``, TypeError),
          g = (e) => s.test(e);
        (h.isNotRelative = g), (h.convert = (e) => e);
        class y {
          constructor({
            ignorecase: e = !0,
            ignoreCase: t = e,
            allowRelativePaths: r = !1,
          } = {}) {
            var n;
            (n = a),
              Object.defineProperty(this, n, { value: true }),
              (this._rules = []),
              (this._ignoreCase = t),
              (this._allowRelativePaths = r),
              this._initCache();
          }
          _initCache() {
            (this._ignoreCache = Object.create(null)),
              (this._testCache = Object.create(null));
          }
          _addPattern(e) {
            if (e && e[a])
              return (
                (this._rules = this._rules.concat(e._rules)),
                void (this._added = !0)
              );
            if (((e) => e && p(e) && !r.test(e) && 0 !== e.indexOf("#"))(e)) {
              const t = ((e, t) => {
                const r = e;
                let o = !1;
                0 === e.indexOf("!") && ((o = !0), (e = e.substr(1)));
                const s = ((e, t) => {
                  let r = d[e];
                  return (
                    r ||
                      ((r = l.reduce(
                        (t, r) => t.replace(r[0], r[1].bind(e)),
                        e
                      )),
                      (d[e] = r)),
                    t ? new RegExp(r, "i") : new RegExp(r)
                  );
                })((e = e.replace(n, "!").replace(i, "#")), t);
                return new f(r, e, o, s);
              })(e, this._ignoreCase);
              (this._added = !0), this._rules.push(t);
            }
          }
          add(e) {
            return (
              (this._added = !1),
              t(p(e) ? ((e) => e.split(o))(e) : e).forEach(
                this._addPattern,
                this
              ),
              this._added && this._initCache(),
              this
            );
          }
          addPattern(e) {
            return this.add(e);
          }
          _testOne(e, t) {
            let r = !1,
              n = !1;
            return (
              this._rules.forEach((i) => {
                const { negative: o } = i;
                (n === o && r !== n) ||
                  (o && !r && !n && !t) ||
                  (i.regex.test(e) && ((r = !o), (n = o)));
              }),
              { ignored: r, unignored: n }
            );
          }
          _test(e, t, r, n) {
            const i = e && h.convert(e);
            return (
              h(i, e, this._allowRelativePaths ? u : m), this._t(i, t, r, n)
            );
          }
          _t(e, t, r, n) {
            if (e in t) return t[e];
            if ((n || (n = e.split("/")), n.pop(), !n.length))
              return (t[e] = this._testOne(e, r));
            const i = this._t(n.join("/") + "/", t, r, n);
            return (t[e] = i.ignored ? i : this._testOne(e, r));
          }
          ignores(e) {
            return this._test(e, this._ignoreCache, !1).ignored;
          }
          createFilter() {
            return (e) => !this.ignores(e);
          }
          filter(e) {
            return t(e).filter(this.createFilter());
          }
          test(e) {
            return this._test(e, this._testCache, !0);
          }
        }
        const b = (e) => new y(e);
        if (
          ((b.isPathValid = (e) => h(e && h.convert(e), e, u)),
          (b.default = b),
          (e.exports = b),
          "undefined" != typeof process &&
            ((process.env && process.env.IGNORE_TEST_WIN32) ||
              "win32" === process.platform))
        ) {
          const e = (e) =>
            /^\\\\\?\\/.test(e) || /["<>|\u0000-\u001F]+/u.test(e)
              ? e
              : e.replace(/\\/g, "/");
          h.convert = e;
          const t = /^[a-z]:\//i;
          h.isNotRelative = (e) => t.test(e) || g(e);
        }
      },
      7354: (e, t, r) => {
        "use strict";
        const n = r(226),
          i = r(6209),
          o = r(1364),
          s = r(7108),
          a = r(7968),
          c =
            (e = {}) =>
            (t) => {
              const r = Buffer.isBuffer(t);
              if (!r && !o(t))
                return Promise.reject(
                  new TypeError("Expected a Buffer or Stream, got " + typeof t)
                );
              if (r && !i(t)) return Promise.resolve(t);
              const c = ["-"];
              if (
                (void 0 !== e.speed &&
                  (a(e.speed, a.number.integer.inRange(1, 11)),
                  c.push("--speed", e.speed)),
                void 0 !== e.strip &&
                  (a(e.strip, a.boolean), e.strip && c.push("--strip")),
                void 0 !== e.quality)
              ) {
                a(e.quality, a.array.length(2).ofType(a.number.inRange(0, 1)));
                const [t, r] = e.quality;
                c.push(
                  "--quality",
                  `${Math.round(100 * t)}-${Math.round(100 * r)}`
                );
              }
              void 0 !== e.dithering &&
                (a(e.dithering, a.any(a.number.inRange(0, 1), a.boolean.false)),
                "number" == typeof e.dithering
                  ? c.push(`--floyd=${e.dithering}`)
                  : !1 === e.dithering && c.push("--ordered")),
                void 0 !== e.posterize &&
                  (a(e.posterize, a.number),
                  c.push("--posterize", e.posterize)),
                void 0 !== e.verbose &&
                  (a(e.verbose, a.boolean), c.push("--verbose"));
              const u = n(s, c, { encoding: null, maxBuffer: 1 / 0, input: t }),
                l = u
                  .then((e) => e.stdout)
                  .catch((e) => {
                    if (99 === e.exitCode) return t;
                    throw ((e.message = e.stderr || e.message), e);
                  });
              return (
                (u.stdout.then = l.then.bind(l)),
                (u.stdout.catch = l.catch.bind(l)),
                u.stdout
              );
            };
        (e.exports = c), (e.exports.default = c);
      },
      226: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = r(2081),
          o = r(8309),
          s = r(1718),
          a = r(3328),
          c = r(9305),
          u = r(8892),
          l = r(6465),
          {
            spawnedKill: d,
            spawnedCancel: p,
            setupTimeout: f,
            setExitHandler: m,
          } = r(2300),
          {
            handleInput: h,
            getSpawnedResult: g,
            makeAllStream: y,
            validateInputSync: b,
          } = r(2766),
          { mergePromise: _, getSpawnedPromise: v } = r(1056),
          { joinCommand: x, parseCommand: S } = r(366),
          E = (e, t, r = {}) => {
            const i = o._parse(e, t, r);
            return (
              (e = i.command),
              (t = i.args),
              ((r = {
                maxBuffer: 1e8,
                buffer: !0,
                stripFinalNewline: !0,
                extendEnv: !0,
                preferLocal: !1,
                localDir: (r = i.options).cwd || process.cwd(),
                execPath: process.execPath,
                encoding: "utf8",
                reject: !0,
                cleanup: !0,
                all: !1,
                windowsHide: !0,
                ...r,
              }).env = (({
                env: e,
                extendEnv: t,
                preferLocal: r,
                localDir: n,
                execPath: i,
              }) => {
                const o = t ? { ...process.env, ...e } : e;
                return r ? a.env({ env: o, cwd: n, execPath: i }) : o;
              })(r)),
              (r.stdio = l(r)),
              "win32" === process.platform &&
                "cmd" === n.basename(e, ".exe") &&
                t.unshift("/q"),
              { file: e, args: t, options: r, parsed: i }
            );
          },
          w = (e, t, r) =>
            "string" == typeof t || Buffer.isBuffer(t)
              ? e.stripFinalNewline
                ? s(t)
                : t
              : void 0 === r
              ? void 0
              : "",
          A = (e, t, r) => {
            const n = E(e, t, r),
              s = x(e, t);
            let a;
            try {
              a = i.spawn(n.file, n.args, n.options);
            } catch (e) {
              const t = new i.ChildProcess(),
                r = Promise.reject(
                  u({
                    error: e,
                    stdout: "",
                    stderr: "",
                    all: "",
                    command: s,
                    parsed: n,
                    timedOut: !1,
                    isCanceled: !1,
                    killed: !1,
                  })
                );
              return _(t, r);
            }
            const l = v(a),
              b = f(a, n.options, l),
              S = m(a, n.options, b),
              A = { isCanceled: !1 };
            (a.kill = d.bind(null, a.kill.bind(a))),
              (a.cancel = p.bind(null, a, A));
            const O = c(async () => {
              const [
                  { error: e, exitCode: t, signal: r, timedOut: i },
                  o,
                  c,
                  l,
                ] = await g(a, n.options, S),
                d = w(n.options, o),
                p = w(n.options, c),
                f = w(n.options, l);
              if (e || 0 !== t || null !== r) {
                const o = u({
                  error: e,
                  exitCode: t,
                  signal: r,
                  stdout: d,
                  stderr: p,
                  all: f,
                  command: s,
                  parsed: n,
                  timedOut: i,
                  isCanceled: A.isCanceled,
                  killed: a.killed,
                });
                if (!n.options.reject) return o;
                throw o;
              }
              return {
                command: s,
                exitCode: 0,
                stdout: d,
                stderr: p,
                all: f,
                failed: !1,
                timedOut: !1,
                isCanceled: !1,
                killed: !1,
              };
            });
            return (
              o._enoent.hookChildProcess(a, n.parsed),
              h(a, n.options.input),
              (a.all = y(a, n.options)),
              _(a, O)
            );
          };
        (e.exports = A),
          (e.exports.sync = (e, t, r) => {
            const n = E(e, t, r),
              o = x(e, t);
            let s;
            b(n.options);
            try {
              s = i.spawnSync(n.file, n.args, n.options);
            } catch (e) {
              throw u({
                error: e,
                stdout: "",
                stderr: "",
                all: "",
                command: o,
                parsed: n,
                timedOut: !1,
                isCanceled: !1,
                killed: !1,
              });
            }
            const a = w(n.options, s.stdout, s.error),
              c = w(n.options, s.stderr, s.error);
            if (s.error || 0 !== s.status || null !== s.signal) {
              const e = u({
                stdout: a,
                stderr: c,
                error: s.error,
                signal: s.signal,
                exitCode: s.status,
                command: o,
                parsed: n,
                timedOut: s.error && "ETIMEDOUT" === s.error.code,
                isCanceled: !1,
                killed: null !== s.signal,
              });
              if (!n.options.reject) return e;
              throw e;
            }
            return {
              command: o,
              exitCode: 0,
              stdout: a,
              stderr: c,
              failed: !1,
              timedOut: !1,
              isCanceled: !1,
              killed: !1,
            };
          }),
          (e.exports.command = (e, t) => {
            const [r, ...n] = S(e);
            return A(r, n, t);
          }),
          (e.exports.commandSync = (e, t) => {
            const [r, ...n] = S(e);
            return A.sync(r, n, t);
          }),
          (e.exports.node = (e, t, r = {}) => {
            t &&
              !Array.isArray(t) &&
              "object" == typeof t &&
              ((r = t), (t = []));
            const n = l.node(r),
              i = process.execArgv.filter((e) => !e.startsWith("--inspect")),
              { nodePath: o = process.execPath, nodeOptions: s = i } = r;
            return A(o, [...s, e, ...(Array.isArray(t) ? t : [])], {
              ...r,
              stdin: void 0,
              stdout: void 0,
              stderr: void 0,
              stdio: n,
              shell: !1,
            });
          });
      },
      366: (e) => {
        "use strict";
        const t = / +/g;
        e.exports = {
          joinCommand: (e, t = []) =>
            Array.isArray(t) ? [e, ...t].join(" ") : e,
          parseCommand: (e) => {
            const r = [];
            for (const n of e.trim().split(t)) {
              const e = r[r.length - 1];
              e && e.endsWith("\\")
                ? (r[r.length - 1] = `${e.slice(0, -1)} ${n}`)
                : r.push(n);
            }
            return r;
          },
        };
      },
      8892: (e, t, r) => {
        "use strict";
        const { signalsByName: n } = r(4024);
        e.exports = ({
          stdout: e,
          stderr: t,
          all: r,
          error: i,
          signal: o,
          exitCode: s,
          command: a,
          timedOut: c,
          isCanceled: u,
          killed: l,
          parsed: {
            options: { timeout: d },
          },
        }) => {
          s = null === s ? void 0 : s;
          const p =
              void 0 === (o = null === o ? void 0 : o)
                ? void 0
                : n[o].description,
            f = (({
              timedOut: e,
              timeout: t,
              errorCode: r,
              signal: n,
              signalDescription: i,
              exitCode: o,
              isCanceled: s,
            }) =>
              e
                ? `timed out after ${t} milliseconds`
                : s
                ? "was canceled"
                : void 0 !== r
                ? `failed with ${r}`
                : void 0 !== n
                ? `was killed with ${n} (${i})`
                : void 0 !== o
                ? `failed with exit code ${o}`
                : "failed")({
              timedOut: c,
              timeout: d,
              errorCode: i && i.code,
              signal: o,
              signalDescription: p,
              exitCode: s,
              isCanceled: u,
            }),
            m = `Command ${f}: ${a}`,
            h = "[object Error]" === Object.prototype.toString.call(i),
            g = h ? `${m}\n${i.message}` : m,
            y = [g, t, e].filter(Boolean).join("\n");
          return (
            h
              ? ((i.originalMessage = i.message), (i.message = y))
              : (i = new Error(y)),
            (i.shortMessage = g),
            (i.command = a),
            (i.exitCode = s),
            (i.signal = o),
            (i.signalDescription = p),
            (i.stdout = e),
            (i.stderr = t),
            void 0 !== r && (i.all = r),
            "bufferedData" in i && delete i.bufferedData,
            (i.failed = !0),
            (i.timedOut = Boolean(c)),
            (i.isCanceled = u),
            (i.killed = l && !c),
            i
          );
        };
      },
      2300: (e, t, r) => {
        "use strict";
        const n = r(2037),
          i = r(7908),
          o = (e, { forceKillAfterTimeout: t }, r) => s(e) && !1 !== t && r,
          s = (e) =>
            e === n.constants.signals.SIGTERM ||
            ("string" == typeof e && "SIGTERM" === e.toUpperCase()),
          a = ({ forceKillAfterTimeout: e = !0 }) => {
            if (!0 === e) return 5e3;
            if (!Number.isFinite(e) || e < 0)
              throw new TypeError(
                `Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`
              );
            return e;
          };
        e.exports = {
          spawnedKill: (e, t = "SIGTERM", r = {}) => {
            const n = e(t);
            return (
              ((e, t, r, n) => {
                if (!o(t, r, n)) return;
                const i = a(r),
                  s = setTimeout(() => {
                    e("SIGKILL");
                  }, i);
                s.unref && s.unref();
              })(e, t, r, n),
              n
            );
          },
          spawnedCancel: (e, t) => {
            e.kill() && (t.isCanceled = !0);
          },
          setupTimeout: (e, { timeout: t, killSignal: r = "SIGTERM" }, n) => {
            if (0 === t || void 0 === t) return n;
            if (!Number.isFinite(t) || t < 0)
              throw new TypeError(
                `Expected the \`timeout\` option to be a non-negative integer, got \`${t}\` (${typeof t})`
              );
            let i;
            const o = new Promise((n, o) => {
                i = setTimeout(() => {
                  ((e, t, r) => {
                    e.kill(t),
                      r(
                        Object.assign(new Error("Timed out"), {
                          timedOut: !0,
                          signal: t,
                        })
                      );
                  })(e, r, o);
                }, t);
              }),
              s = n.finally(() => {
                clearTimeout(i);
              });
            return Promise.race([o, s]);
          },
          setExitHandler: async (e, { cleanup: t, detached: r }, n) => {
            if (!t || r) return n;
            const o = i(() => {
              e.kill();
            });
            return n.finally(() => {
              o();
            });
          },
        };
      },
      1056: (e) => {
        "use strict";
        const t = (async () => {})().constructor.prototype,
          r = ["then", "catch", "finally"].map((e) => [
            e,
            Reflect.getOwnPropertyDescriptor(t, e),
          ]);
        e.exports = {
          mergePromise: (e, t) => {
            for (const [n, i] of r) {
              const r =
                "function" == typeof t
                  ? (...e) => Reflect.apply(i.value, t(), e)
                  : i.value.bind(t);
              Reflect.defineProperty(e, n, { ...i, value: r });
            }
            return e;
          },
          getSpawnedPromise: (e) =>
            new Promise((t, r) => {
              e.on("exit", (e, r) => {
                t({ exitCode: e, signal: r });
              }),
                e.on("error", (e) => {
                  r(e);
                }),
                e.stdin &&
                  e.stdin.on("error", (e) => {
                    r(e);
                  });
            }),
        };
      },
      6465: (e) => {
        "use strict";
        const t = ["stdin", "stdout", "stderr"],
          r = (e) => {
            if (!e) return;
            const { stdio: r } = e;
            if (void 0 === r) return t.map((t) => e[t]);
            if (((e) => t.some((t) => void 0 !== e[t]))(e))
              throw new Error(
                `It's not possible to provide \`stdio\` in combination with one of ${t
                  .map((e) => `\`${e}\``)
                  .join(", ")}`
              );
            if ("string" == typeof r) return r;
            if (!Array.isArray(r))
              throw new TypeError(
                `Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof r}\``
              );
            const n = Math.max(r.length, t.length);
            return Array.from({ length: n }, (e, t) => r[t]);
          };
        (e.exports = r),
          (e.exports.node = (e) => {
            const t = r(e);
            return "ipc" === t
              ? "ipc"
              : void 0 === t || "string" == typeof t
              ? [t, t, t, "ipc"]
              : t.includes("ipc")
              ? t
              : [...t, "ipc"];
          });
      },
      2766: (e, t, r) => {
        "use strict";
        const n = r(1364),
          i = r(7495),
          o = r(4034),
          s = async (e, t) => {
            if (e) {
              e.destroy();
              try {
                return await t;
              } catch (e) {
                return e.bufferedData;
              }
            }
          },
          a = (e, { encoding: t, buffer: r, maxBuffer: n }) => {
            if (e && r)
              return t
                ? i(e, { encoding: t, maxBuffer: n })
                : i.buffer(e, { maxBuffer: n });
          };
        e.exports = {
          handleInput: (e, t) => {
            void 0 !== t &&
              void 0 !== e.stdin &&
              (n(t) ? t.pipe(e.stdin) : e.stdin.end(t));
          },
          makeAllStream: (e, { all: t }) => {
            if (!t || (!e.stdout && !e.stderr)) return;
            const r = o();
            return e.stdout && r.add(e.stdout), e.stderr && r.add(e.stderr), r;
          },
          getSpawnedResult: async (
            { stdout: e, stderr: t, all: r },
            { encoding: n, buffer: i, maxBuffer: o },
            c
          ) => {
            const u = a(e, { encoding: n, buffer: i, maxBuffer: o }),
              l = a(t, { encoding: n, buffer: i, maxBuffer: o }),
              d = a(r, { encoding: n, buffer: i, maxBuffer: 2 * o });
            try {
              return await Promise.all([c, u, l, d]);
            } catch (n) {
              return Promise.all([
                { error: n, signal: n.signal, timedOut: n.timedOut },
                s(e, u),
                s(t, l),
                s(r, d),
              ]);
            }
          },
          validateInputSync: ({ input: e }) => {
            if (n(e))
              throw new TypeError(
                "The `input` option cannot be a stream in sync mode"
              );
          },
        };
      },
      4404: (e, t, r) => {
        "use strict";
        const { PassThrough: n } = r(2781);
        e.exports = (e) => {
          e = { ...e };
          const { array: t } = e;
          let { encoding: r } = e;
          const i = "buffer" === r;
          let o = !1;
          t ? (o = !(r || i)) : (r = r || "utf8"), i && (r = null);
          const s = new n({ objectMode: o });
          r && s.setEncoding(r);
          let a = 0;
          const c = [];
          return (
            s.on("data", (e) => {
              c.push(e), o ? (a = c.length) : (a += e.length);
            }),
            (s.getBufferedValue = () =>
              t ? c : i ? Buffer.concat(c, a) : c.join("")),
            (s.getBufferedLength = () => a),
            s
          );
        };
      },
      7495: (e, t, r) => {
        "use strict";
        const { constants: n } = r(4300),
          i = r(4286),
          o = r(4404);
        class s extends Error {
          constructor() {
            super("maxBuffer exceeded"), (this.name = "MaxBufferError");
          }
        }
        async function a(e, t) {
          if (!e) return Promise.reject(new Error("Expected a stream"));
          t = { maxBuffer: 1 / 0, ...t };
          const { maxBuffer: r } = t;
          let a;
          return (
            await new Promise((c, u) => {
              const l = (e) => {
                e &&
                  a.getBufferedLength() <= n.MAX_LENGTH &&
                  (e.bufferedData = a.getBufferedValue()),
                  u(e);
              };
              (a = i(e, o(t), (e) => {
                e ? l(e) : c();
              })),
                a.on("data", () => {
                  a.getBufferedLength() > r && l(new s());
                });
            }),
            a.getBufferedValue()
          );
        }
        (e.exports = a),
          (e.exports.default = a),
          (e.exports.buffer = (e, t) => a(e, { ...t, encoding: "buffer" })),
          (e.exports.array = (e, t) => a(e, { ...t, array: !0 })),
          (e.exports.MaxBufferError = s);
      },
      4845: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SIGNALS = void 0),
          (t.SIGNALS = [
            {
              name: "SIGHUP",
              number: 1,
              action: "terminate",
              description: "Terminal closed",
              standard: "posix",
            },
            {
              name: "SIGINT",
              number: 2,
              action: "terminate",
              description: "User interruption with CTRL-C",
              standard: "ansi",
            },
            {
              name: "SIGQUIT",
              number: 3,
              action: "core",
              description: "User interruption with CTRL-\\",
              standard: "posix",
            },
            {
              name: "SIGILL",
              number: 4,
              action: "core",
              description: "Invalid machine instruction",
              standard: "ansi",
            },
            {
              name: "SIGTRAP",
              number: 5,
              action: "core",
              description: "Debugger breakpoint",
              standard: "posix",
            },
            {
              name: "SIGABRT",
              number: 6,
              action: "core",
              description: "Aborted",
              standard: "ansi",
            },
            {
              name: "SIGIOT",
              number: 6,
              action: "core",
              description: "Aborted",
              standard: "bsd",
            },
            {
              name: "SIGBUS",
              number: 7,
              action: "core",
              description:
                "Bus error due to misaligned, non-existing address or paging error",
              standard: "bsd",
            },
            {
              name: "SIGEMT",
              number: 7,
              action: "terminate",
              description: "Command should be emulated but is not implemented",
              standard: "other",
            },
            {
              name: "SIGFPE",
              number: 8,
              action: "core",
              description: "Floating point arithmetic error",
              standard: "ansi",
            },
            {
              name: "SIGKILL",
              number: 9,
              action: "terminate",
              description: "Forced termination",
              standard: "posix",
              forced: !0,
            },
            {
              name: "SIGUSR1",
              number: 10,
              action: "terminate",
              description: "Application-specific signal",
              standard: "posix",
            },
            {
              name: "SIGSEGV",
              number: 11,
              action: "core",
              description: "Segmentation fault",
              standard: "ansi",
            },
            {
              name: "SIGUSR2",
              number: 12,
              action: "terminate",
              description: "Application-specific signal",
              standard: "posix",
            },
            {
              name: "SIGPIPE",
              number: 13,
              action: "terminate",
              description: "Broken pipe or socket",
              standard: "posix",
            },
            {
              name: "SIGALRM",
              number: 14,
              action: "terminate",
              description: "Timeout or timer",
              standard: "posix",
            },
            {
              name: "SIGTERM",
              number: 15,
              action: "terminate",
              description: "Termination",
              standard: "ansi",
            },
            {
              name: "SIGSTKFLT",
              number: 16,
              action: "terminate",
              description: "Stack is empty or overflowed",
              standard: "other",
            },
            {
              name: "SIGCHLD",
              number: 17,
              action: "ignore",
              description: "Child process terminated, paused or unpaused",
              standard: "posix",
            },
            {
              name: "SIGCLD",
              number: 17,
              action: "ignore",
              description: "Child process terminated, paused or unpaused",
              standard: "other",
            },
            {
              name: "SIGCONT",
              number: 18,
              action: "unpause",
              description: "Unpaused",
              standard: "posix",
              forced: !0,
            },
            {
              name: "SIGSTOP",
              number: 19,
              action: "pause",
              description: "Paused",
              standard: "posix",
              forced: !0,
            },
            {
              name: "SIGTSTP",
              number: 20,
              action: "pause",
              description: 'Paused using CTRL-Z or "suspend"',
              standard: "posix",
            },
            {
              name: "SIGTTIN",
              number: 21,
              action: "pause",
              description: "Background process cannot read terminal input",
              standard: "posix",
            },
            {
              name: "SIGBREAK",
              number: 21,
              action: "terminate",
              description: "User interruption with CTRL-BREAK",
              standard: "other",
            },
            {
              name: "SIGTTOU",
              number: 22,
              action: "pause",
              description: "Background process cannot write to terminal output",
              standard: "posix",
            },
            {
              name: "SIGURG",
              number: 23,
              action: "ignore",
              description: "Socket received out-of-band data",
              standard: "bsd",
            },
            {
              name: "SIGXCPU",
              number: 24,
              action: "core",
              description: "Process timed out",
              standard: "bsd",
            },
            {
              name: "SIGXFSZ",
              number: 25,
              action: "core",
              description: "File too big",
              standard: "bsd",
            },
            {
              name: "SIGVTALRM",
              number: 26,
              action: "terminate",
              description: "Timeout or timer",
              standard: "bsd",
            },
            {
              name: "SIGPROF",
              number: 27,
              action: "terminate",
              description: "Timeout or timer",
              standard: "bsd",
            },
            {
              name: "SIGWINCH",
              number: 28,
              action: "ignore",
              description: "Terminal window size changed",
              standard: "bsd",
            },
            {
              name: "SIGIO",
              number: 29,
              action: "terminate",
              description: "I/O is available",
              standard: "other",
            },
            {
              name: "SIGPOLL",
              number: 29,
              action: "terminate",
              description: "Watched event",
              standard: "other",
            },
            {
              name: "SIGINFO",
              number: 29,
              action: "ignore",
              description: "Request for process information",
              standard: "other",
            },
            {
              name: "SIGPWR",
              number: 30,
              action: "terminate",
              description: "Device running out of power",
              standard: "systemv",
            },
            {
              name: "SIGSYS",
              number: 31,
              action: "core",
              description: "Invalid system call",
              standard: "other",
            },
            {
              name: "SIGUNUSED",
              number: 31,
              action: "terminate",
              description: "Invalid system call",
              standard: "other",
            },
          ]);
      },
      4024: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.signalsByNumber = t.signalsByName = void 0);
        var n = r(2037),
          i = r(6539),
          o = r(499);
        const s = (0, i.getSignals)().reduce(function (
          e,
          {
            name: t,
            number: r,
            description: n,
            supported: i,
            action: o,
            forced: s,
            standard: a,
          }
        ) {
          return {
            ...e,
            [t]: {
              name: t,
              number: r,
              description: n,
              supported: i,
              action: o,
              forced: s,
              standard: a,
            },
          };
        },
        {});
        t.signalsByName = s;
        const a = function (e, t) {
            const r = t.find(({ name: t }) => n.constants.signals[t] === e);
            return void 0 !== r ? r : t.find((t) => t.number === e);
          },
          c = (function () {
            const e = (0, i.getSignals)(),
              t = o.SIGRTMAX + 1,
              r = Array.from({ length: t }, (t, r) =>
                (function (e, t) {
                  const r = a(e, t);
                  if (void 0 === r) return {};
                  const {
                    name: n,
                    description: i,
                    supported: o,
                    action: s,
                    forced: c,
                    standard: u,
                  } = r;
                  return {
                    [e]: {
                      name: n,
                      number: e,
                      description: i,
                      supported: o,
                      action: s,
                      forced: c,
                      standard: u,
                    },
                  };
                })(r, e)
              );
            return Object.assign({}, ...r);
          })();
        t.signalsByNumber = c;
      },
      499: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SIGRTMAX = t.getRealtimeSignals = void 0),
          (t.getRealtimeSignals = function () {
            const e = i - n + 1;
            return Array.from({ length: e }, r);
          });
        const r = function (e, t) {
            return {
              name: `SIGRT${t + 1}`,
              number: n + t,
              action: "terminate",
              description: "Application-specific signal (realtime)",
              standard: "posix",
            };
          },
          n = 34,
          i = 64;
        t.SIGRTMAX = i;
      },
      6539: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getSignals = void 0);
        var n = r(2037),
          i = r(4845),
          o = r(499);
        t.getSignals = function () {
          const e = (0, o.getRealtimeSignals)();
          return [...i.SIGNALS, ...e].map(s);
        };
        const s = function ({
          name: e,
          number: t,
          description: r,
          action: i,
          forced: o = !1,
          standard: s,
        }) {
          const {
              signals: { [e]: a },
            } = n.constants,
            c = void 0 !== a;
          return {
            name: e,
            number: c ? a : t,
            description: r,
            supported: c,
            action: i,
            forced: o,
            standard: s,
          };
        };
      },
      1364: (e) => {
        "use strict";
        const t = (e) =>
          null !== e && "object" == typeof e && "function" == typeof e.pipe;
        (t.writable = (e) =>
          t(e) &&
          !1 !== e.writable &&
          "function" == typeof e._write &&
          "object" == typeof e._writableState),
          (t.readable = (e) =>
            t(e) &&
            !1 !== e.readable &&
            "function" == typeof e._read &&
            "object" == typeof e._readableState),
          (t.duplex = (e) => t.writable(e) && t.readable(e)),
          (t.transform = (e) =>
            t.duplex(e) && "function" == typeof e._transform),
          (e.exports = t);
      },
      2222: (e) => {
        "use strict";
        const t = (e, t) => {
          for (const r of Reflect.ownKeys(t))
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
          return e;
        };
        (e.exports = t), (e.exports.default = t);
      },
      3328: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = r(3024),
          o = (e) => {
            let t;
            e = {
              cwd: process.cwd(),
              path: process.env[i()],
              execPath: process.execPath,
              ...e,
            };
            let r = n.resolve(e.cwd);
            const o = [];
            for (; t !== r; )
              o.push(n.join(r, "node_modules/.bin")),
                (t = r),
                (r = n.resolve(r, ".."));
            const s = n.resolve(e.cwd, e.execPath, "..");
            return o.push(s), o.concat(e.path).join(n.delimiter);
          };
        (e.exports = o),
          (e.exports.default = o),
          (e.exports.env = (t) => {
            const r = { ...(t = { env: process.env, ...t }).env },
              n = i({ env: r });
            return (t.path = r[n]), (r[n] = e.exports(t)), r;
          });
      },
      9305: (e, t, r) => {
        "use strict";
        const n = r(2222),
          i = new WeakMap(),
          o = (e, t = {}) => {
            if ("function" != typeof e)
              throw new TypeError("Expected a function");
            let r,
              o = 0;
            const s = e.displayName || e.name || "<anonymous>",
              a = function (...n) {
                if ((i.set(a, ++o), 1 === o))
                  (r = e.apply(this, n)), (e = null);
                else if (!0 === t.throw)
                  throw new Error(`Function \`${s}\` can only be called once`);
                return r;
              };
            return n(a, e), i.set(a, o), a;
          };
        (e.exports = o),
          (e.exports.default = o),
          (e.exports.callCount = (e) => {
            if (!i.has(e))
              throw new Error(
                `The given function \`${e.name}\` is not wrapped by the \`onetime\` package`
              );
            return i.get(e);
          });
      },
      1718: (e) => {
        "use strict";
        e.exports = (e) => {
          const t = "string" == typeof e ? "\n" : "\n".charCodeAt(),
            r = "string" == typeof e ? "\r" : "\r".charCodeAt();
          return (
            e[e.length - 1] === t && (e = e.slice(0, e.length - 1)),
            e[e.length - 1] === r && (e = e.slice(0, e.length - 1)),
            e
          );
        };
      },
      6991: (e) => {
        "use strict";
        const t = (e, t, r) => (void 0 === e ? t(r) : e);
        e.exports = (e) => (r) => {
          let n;
          return new Proxy(function () {}, {
            get: (i, o) => ((n = t(n, e, r)), Reflect.get(n, o)),
            apply: (i, o, s) => ((n = t(n, e, r)), Reflect.apply(n, o, s)),
            construct: (i, o) => ((n = t(n, e, r)), Reflect.construct(n, o)),
          });
        };
      },
      2428: (e) => {
        e.exports = function (e) {
          if ("string" != typeof e || "" === e) return !1;
          for (var t; (t = /(\\).|([@?!+*]\(.*\))/g.exec(e)); ) {
            if (t[2]) return !0;
            e = e.slice(t.index + t[0].length);
          }
          return !1;
        };
      },
      6830: (e, t, r) => {
        var n = r(2428),
          i = { "{": "}", "(": ")", "[": "]" },
          o = function (e) {
            if ("!" === e[0]) return !0;
            for (
              var t = 0, r = -2, n = -2, o = -2, s = -2, a = -2;
              t < e.length;

            ) {
              if ("*" === e[t]) return !0;
              if ("?" === e[t + 1] && /[\].+)]/.test(e[t])) return !0;
              if (
                -1 !== n &&
                "[" === e[t] &&
                "]" !== e[t + 1] &&
                (n < t && (n = e.indexOf("]", t)), n > t)
              ) {
                if (-1 === a || a > n) return !0;
                if (-1 === (a = e.indexOf("\\", t)) || a > n) return !0;
              }
              if (
                -1 !== o &&
                "{" === e[t] &&
                "}" !== e[t + 1] &&
                (o = e.indexOf("}", t)) > t &&
                (-1 === (a = e.indexOf("\\", t)) || a > o)
              )
                return !0;
              if (
                -1 !== s &&
                "(" === e[t] &&
                "?" === e[t + 1] &&
                /[:!=]/.test(e[t + 2]) &&
                ")" !== e[t + 3] &&
                (s = e.indexOf(")", t)) > t &&
                (-1 === (a = e.indexOf("\\", t)) || a > s)
              )
                return !0;
              if (
                -1 !== r &&
                "(" === e[t] &&
                "|" !== e[t + 1] &&
                (r < t && (r = e.indexOf("|", t)),
                -1 !== r &&
                  ")" !== e[r + 1] &&
                  (s = e.indexOf(")", r)) > r &&
                  (-1 === (a = e.indexOf("\\", r)) || a > s))
              )
                return !0;
              if ("\\" === e[t]) {
                var c = e[t + 1];
                t += 2;
                var u = i[c];
                if (u) {
                  var l = e.indexOf(u, t);
                  -1 !== l && (t = l + 1);
                }
                if ("!" === e[t]) return !0;
              } else t++;
            }
            return !1;
          },
          s = function (e) {
            if ("!" === e[0]) return !0;
            for (var t = 0; t < e.length; ) {
              if (/[*?{}()[\]]/.test(e[t])) return !0;
              if ("\\" === e[t]) {
                var r = e[t + 1];
                t += 2;
                var n = i[r];
                if (n) {
                  var o = e.indexOf(n, t);
                  -1 !== o && (t = o + 1);
                }
                if ("!" === e[t]) return !0;
              } else t++;
            }
            return !1;
          };
        e.exports = function (e, t) {
          if ("string" != typeof e || "" === e) return !1;
          if (n(e)) return !0;
          var r = o;
          return t && !1 === t.strict && (r = s), r(e);
        };
      },
      9924: (e) => {
        "use strict";
        e.exports = function (e) {
          return "number" == typeof e
            ? e - e == 0
            : "string" == typeof e &&
                "" !== e.trim() &&
                (Number.isFinite ? Number.isFinite(+e) : isFinite(+e));
        };
      },
      6209: (e) => {
        "use strict";
        e.exports = (e) =>
          !(!e || e.length < 8) &&
          137 === e[0] &&
          80 === e[1] &&
          78 === e[2] &&
          71 === e[3] &&
          13 === e[4] &&
          10 === e[5] &&
          26 === e[6] &&
          10 === e[7];
      },
      1959: (e, t, r) => {
        var n;
        function i(e, t, r) {
          if (("function" == typeof t && ((r = t), (t = {})), !r)) {
            if ("function" != typeof Promise)
              throw new TypeError("callback not provided");
            return new Promise(function (r, n) {
              i(e, t || {}, function (e, t) {
                e ? n(e) : r(t);
              });
            });
          }
          n(e, t || {}, function (e, n) {
            e &&
              ("EACCES" === e.code || (t && t.ignoreErrors)) &&
              ((e = null), (n = !1)),
              r(e, n);
          });
        }
        r(7147),
          (n =
            "win32" === process.platform || global.TESTING_WINDOWS
              ? r(1429)
              : r(4601)),
          (e.exports = i),
          (i.sync = function (e, t) {
            try {
              return n.sync(e, t || {});
            } catch (e) {
              if ((t && t.ignoreErrors) || "EACCES" === e.code) return !1;
              throw e;
            }
          });
      },
      4601: (e, t, r) => {
        (e.exports = i),
          (i.sync = function (e, t) {
            return o(n.statSync(e), t);
          });
        var n = r(7147);
        function i(e, t, r) {
          n.stat(e, function (e, n) {
            r(e, !e && o(n, t));
          });
        }
        function o(e, t) {
          return (
            e.isFile() &&
            (function (e, t) {
              var r = e.mode,
                n = e.uid,
                i = e.gid,
                o =
                  void 0 !== t.uid ? t.uid : process.getuid && process.getuid(),
                s =
                  void 0 !== t.gid ? t.gid : process.getgid && process.getgid(),
                a = parseInt("100", 8),
                c = parseInt("010", 8);
              return (
                r & parseInt("001", 8) ||
                (r & c && i === s) ||
                (r & a && n === o) ||
                (r & (a | c) && 0 === o)
              );
            })(e, t)
          );
        }
      },
      1429: (e, t, r) => {
        (e.exports = o),
          (o.sync = function (e, t) {
            return i(n.statSync(e), e, t);
          });
        var n = r(7147);
        function i(e, t, r) {
          return (
            !(!e.isSymbolicLink() && !e.isFile()) &&
            (function (e, t) {
              var r = void 0 !== t.pathExt ? t.pathExt : process.env.PATHEXT;
              if (!r) return !0;
              if (-1 !== (r = r.split(";")).indexOf("")) return !0;
              for (var n = 0; n < r.length; n++) {
                var i = r[n].toLowerCase();
                if (i && e.substr(-i.length).toLowerCase() === i) return !0;
              }
              return !1;
            })(t, r)
          );
        }
        function o(e, t, r) {
          n.stat(e, function (n, o) {
            r(n, !n && i(o, e, t));
          });
        }
      },
      1351: (e, t) => {
        "use strict";
        (t.re = () => {
          throw new Error("`junk.re` was renamed to `junk.regex`");
        }),
          (t.regex = new RegExp(
            [
              "^npm-debug\\.log$",
              "^\\..*\\.swp$",
              "^\\.DS_Store$",
              "^\\.AppleDouble$",
              "^\\.LSOverride$",
              "^Icon\\r$",
              "^\\._.*",
              "^\\.Spotlight-V100(?:$|\\/)",
              "\\.Trashes",
              "^__MACOSX$",
              "~$",
              "^Thumbs\\.db$",
              "^ehthumbs\\.db$",
              "^Desktop\\.ini$",
              "@eaDir$",
            ].join("|")
          )),
          (t.is = (e) => t.regex.test(e)),
          (t.not = (e) => !t.is(e)),
          (t.default = e.exports);
      },
      4034: (e, t, r) => {
        "use strict";
        const { PassThrough: n } = r(2781);
        e.exports = function () {
          var e = [],
            t = new n({ objectMode: !0 });
          return (
            t.setMaxListeners(0),
            (t.add = r),
            (t.isEmpty = i),
            t.on("unpipe", o),
            Array.prototype.slice.call(arguments).forEach(r),
            t
          );
          function r(n) {
            return Array.isArray(n)
              ? (n.forEach(r), this)
              : (e.push(n),
                n.once("end", o.bind(null, n)),
                n.once("error", t.emit.bind(t, "error")),
                n.pipe(t, { end: !1 }),
                this);
          }
          function i() {
            return 0 == e.length;
          }
          function o(r) {
            !(e = e.filter(function (e) {
              return e !== r;
            })).length &&
              t.readable &&
              t.end();
          }
        };
      },
      155: (e, t, r) => {
        "use strict";
        const n = r(2781).PassThrough,
          i = Array.prototype.slice;
        function o(e, t) {
          if (Array.isArray(e))
            for (let r = 0, n = e.length; r < n; r++) e[r] = o(e[r], t);
          else {
            if (
              (!e._readableState && e.pipe && (e = e.pipe(n(t))),
              !e._readableState || !e.pause || !e.pipe)
            )
              throw new Error("Only readable stream can be merged.");
            e.pause();
          }
          return e;
        }
        e.exports = function () {
          const e = [],
            t = i.call(arguments);
          let r = !1,
            s = t[t.length - 1];
          s && !Array.isArray(s) && null == s.pipe ? t.pop() : (s = {});
          const a = !1 !== s.end,
            c = !0 === s.pipeError;
          null == s.objectMode && (s.objectMode = !0),
            null == s.highWaterMark && (s.highWaterMark = 65536);
          const u = n(s);
          function l() {
            for (let t = 0, r = arguments.length; t < r; t++)
              e.push(o(arguments[t], s));
            return d(), this;
          }
          function d() {
            if (r) return;
            r = !0;
            let t = e.shift();
            if (!t) return void process.nextTick(p);
            Array.isArray(t) || (t = [t]);
            let n = t.length + 1;
            function i() {
              --n > 0 || ((r = !1), d());
            }
            function o(e) {
              function t() {
                e.removeListener("merge2UnpipeEnd", t),
                  e.removeListener("end", t),
                  c && e.removeListener("error", r),
                  i();
              }
              function r(e) {
                u.emit("error", e);
              }
              if (e._readableState.endEmitted) return i();
              e.on("merge2UnpipeEnd", t),
                e.on("end", t),
                c && e.on("error", r),
                e.pipe(u, { end: !1 }),
                e.resume();
            }
            for (let e = 0; e < t.length; e++) o(t[e]);
            i();
          }
          function p() {
            (r = !1), u.emit("queueDrain"), a && u.end();
          }
          return (
            u.setMaxListeners(0),
            (u.add = l),
            u.on("unpipe", function (e) {
              e.emit("merge2UnpipeEnd");
            }),
            t.length && l.apply(null, t),
            u
          );
        };
      },
      850: (e, t, r) => {
        "use strict";
        const n = r(3837),
          i = r(6744),
          o = r(9444),
          s = r(8702),
          a = (e) => "" === e || "./" === e,
          c = (e, t, r) => {
            (t = [].concat(t)), (e = [].concat(e));
            let n = new Set(),
              i = new Set(),
              s = new Set(),
              a = 0,
              c = (e) => {
                s.add(e.output), r && r.onResult && r.onResult(e);
              };
            for (let s = 0; s < t.length; s++) {
              let u = o(String(t[s]), { ...r, onResult: c }, !0),
                l = u.state.negated || u.state.negatedExtglob;
              l && a++;
              for (let t of e) {
                let e = u(t, !0);
                (l ? !e.isMatch : e.isMatch) &&
                  (l ? n.add(e.output) : (n.delete(e.output), i.add(e.output)));
              }
            }
            let u = (a === t.length ? [...s] : [...i]).filter((e) => !n.has(e));
            if (r && 0 === u.length) {
              if (!0 === r.failglob)
                throw new Error(`No matches found for "${t.join(", ")}"`);
              if (!0 === r.nonull || !0 === r.nullglob)
                return r.unescape ? t.map((e) => e.replace(/\\/g, "")) : t;
            }
            return u;
          };
        (c.match = c),
          (c.matcher = (e, t) => o(e, t)),
          (c.any = c.isMatch = (e, t, r) => o(t, r)(e)),
          (c.not = (e, t, r = {}) => {
            t = [].concat(t).map(String);
            let n = new Set(),
              i = [],
              o = new Set(
                c(e, t, {
                  ...r,
                  onResult: (e) => {
                    r.onResult && r.onResult(e), i.push(e.output);
                  },
                })
              );
            for (let e of i) o.has(e) || n.add(e);
            return [...n];
          }),
          (c.contains = (e, t, r) => {
            if ("string" != typeof e)
              throw new TypeError(`Expected a string: "${n.inspect(e)}"`);
            if (Array.isArray(t)) return t.some((t) => c.contains(e, t, r));
            if ("string" == typeof t) {
              if (a(e) || a(t)) return !1;
              if (
                e.includes(t) ||
                (e.startsWith("./") && e.slice(2).includes(t))
              )
                return !0;
            }
            return c.isMatch(e, t, { ...r, contains: !0 });
          }),
          (c.matchKeys = (e, t, r) => {
            if (!s.isObject(e))
              throw new TypeError(
                "Expected the first argument to be an object"
              );
            let n = c(Object.keys(e), t, r),
              i = {};
            for (let t of n) i[t] = e[t];
            return i;
          }),
          (c.some = (e, t, r) => {
            let n = [].concat(e);
            for (let e of [].concat(t)) {
              let t = o(String(e), r);
              if (n.some((e) => t(e))) return !0;
            }
            return !1;
          }),
          (c.every = (e, t, r) => {
            let n = [].concat(e);
            for (let e of [].concat(t)) {
              let t = o(String(e), r);
              if (!n.every((e) => t(e))) return !1;
            }
            return !0;
          }),
          (c.all = (e, t, r) => {
            if ("string" != typeof e)
              throw new TypeError(`Expected a string: "${n.inspect(e)}"`);
            return [].concat(t).every((t) => o(t, r)(e));
          }),
          (c.capture = (e, t, r) => {
            let n = s.isWindows(r),
              i = o
                .makeRe(String(e), { ...r, capture: !0 })
                .exec(n ? s.toPosixSlashes(t) : t);
            if (i) return i.slice(1).map((e) => (void 0 === e ? "" : e));
          }),
          (c.makeRe = (...e) => o.makeRe(...e)),
          (c.scan = (...e) => o.scan(...e)),
          (c.parse = (e, t) => {
            let r = [];
            for (let n of [].concat(e || []))
              for (let e of i(String(n), t)) r.push(o.parse(e, t));
            return r;
          }),
          (c.braces = (e, t) => {
            if ("string" != typeof e) throw new TypeError("Expected a string");
            return (t && !0 === t.nobrace) || !/\{.*\}/.test(e) ? [e] : i(e, t);
          }),
          (c.braceExpand = (e, t) => {
            if ("string" != typeof e) throw new TypeError("Expected a string");
            return c.braces(e, { ...t, expand: !0 });
          }),
          (e.exports = c);
      },
      447: (e, t, r) => {
        var n = r(2479);
        function i(e) {
          var t = function () {
            return t.called
              ? t.value
              : ((t.called = !0), (t.value = e.apply(this, arguments)));
          };
          return (t.called = !1), t;
        }
        function o(e) {
          var t = function () {
              if (t.called) throw new Error(t.onceError);
              return (t.called = !0), (t.value = e.apply(this, arguments));
            },
            r = e.name || "Function wrapped with `once`";
          return (
            (t.onceError = r + " shouldn't be called more than once"),
            (t.called = !1),
            t
          );
        }
        (e.exports = n(i)),
          (e.exports.strict = n(o)),
          (i.proto = i(function () {
            Object.defineProperty(Function.prototype, "once", {
              value: function () {
                return i(this);
              },
              configurable: !0,
            }),
              Object.defineProperty(Function.prototype, "onceStrict", {
                value: function () {
                  return o(this);
                },
                configurable: !0,
              });
          }));
      },
      7968: (e, t, r) => {
        e.exports = (function (e) {
          var t = {};
          function r(n) {
            if (t[n]) return t[n].exports;
            var i = (t[n] = { i: n, l: !1, exports: {} });
            return e[n].call(i.exports, i, i.exports, r), (i.l = !0), i.exports;
          }
          return (
            (r.m = e),
            (r.c = t),
            (r.d = function (e, t, n) {
              r.o(e, t) ||
                Object.defineProperty(e, t, { enumerable: !0, get: n });
            }),
            (r.r = function (e) {
              "undefined" != typeof Symbol &&
                Symbol.toStringTag &&
                Object.defineProperty(e, Symbol.toStringTag, {
                  value: "Module",
                }),
                Object.defineProperty(e, "__esModule", { value: !0 });
            }),
            (r.t = function (e, t) {
              if ((1 & t && (e = r(e)), 8 & t)) return e;
              if (4 & t && "object" == typeof e && e && e.__esModule) return e;
              var n = Object.create(null);
              if (
                (r.r(n),
                Object.defineProperty(n, "default", {
                  enumerable: !0,
                  value: e,
                }),
                2 & t && "string" != typeof e)
              )
                for (var i in e)
                  r.d(
                    n,
                    i,
                    function (t) {
                      return e[t];
                    }.bind(null, i)
                  );
              return n;
            }),
            (r.n = function (e) {
              var t =
                e && e.__esModule
                  ? function () {
                      return e.default;
                    }
                  : function () {
                      return e;
                    };
              return r.d(t, "a", t), t;
            }),
            (r.o = function (e, t) {
              return Object.prototype.hasOwnProperty.call(e, t);
            }),
            (r.p = ""),
            r((r.s = 4))
          );
        })([
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(1),
              i = r(6),
              o = r(15),
              s = r(2);
            (t.validatorSymbol = Symbol("validators")),
              (t.Predicate = class {
                constructor(e, t = {}) {
                  (this.type = e),
                    (this.options = t),
                    (this.context = { validators: [] }),
                    (this.context = { ...this.context, ...this.options });
                  const r = this.type[0].toLowerCase() + this.type.slice(1);
                  this.addValidator({
                    message: (e, t) =>
                      `Expected ${
                        (null == t ? void 0 : t.slice(this.type.length + 1)) ||
                        "argument"
                      } to be of type \`${
                        this.type
                      }\` but received type \`${n.default(e)}\``,
                    validator: (e) => n.default[r](e),
                  });
                }
                [s.testSymbol](e, t, r) {
                  for (const { validator: n, message: o } of this.context
                    .validators) {
                    if (!0 === this.options.optional && void 0 === e) continue;
                    const s = n(e);
                    if (!0 === s) continue;
                    let a = r;
                    throw (
                      ("function" == typeof r && (a = r()),
                      (a = a ? `${this.type} \`${a}\`` : this.type),
                      new i.ArgumentError(o(e, a, s), t))
                    );
                  }
                }
                get [t.validatorSymbol]() {
                  return this.context.validators;
                }
                get not() {
                  return o.not(this);
                }
                validate(e) {
                  return this.addValidator({
                    message: (e, t, r) =>
                      "string" == typeof r ? `(${t}) ${r}` : r(t),
                    validator: (t) => {
                      const { message: r, validator: n } = e(t);
                      return !!n || r;
                    },
                  });
                }
                is(e) {
                  return this.addValidator({
                    message: (e, t, r) =>
                      r
                        ? `(${t}) ${r}`
                        : `Expected ${t} \`${e}\` to pass custom validation function`,
                    validator: e,
                  });
                }
                addValidator(e) {
                  return this.context.validators.push(e), this;
                }
              });
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const { toString: n } = Object.prototype,
              i = (e) => (t) => typeof t === e,
              o = (e) => {
                const t = n.call(e).slice(8, -1);
                if (t) return t;
              },
              s = (e) => (t) => o(t) === e;
            function a(e) {
              switch (e) {
                case null:
                  return "null";
                case !0:
                case !1:
                  return "boolean";
              }
              switch (typeof e) {
                case "undefined":
                  return "undefined";
                case "string":
                  return "string";
                case "number":
                  return "number";
                case "bigint":
                  return "bigint";
                case "symbol":
                  return "symbol";
              }
              if (a.function_(e)) return "Function";
              if (a.observable(e)) return "Observable";
              if (a.array(e)) return "Array";
              if (a.buffer(e)) return "Buffer";
              const t = o(e);
              if (t) return t;
              if (
                e instanceof String ||
                e instanceof Boolean ||
                e instanceof Number
              )
                throw new TypeError(
                  "Please don't use object wrappers for primitive types"
                );
              return "Object";
            }
            (a.undefined = i("undefined")), (a.string = i("string"));
            const c = i("number");
            (a.number = (e) => c(e) && !a.nan(e)),
              (a.bigint = i("bigint")),
              (a.function_ = i("function")),
              (a.null_ = (e) => null === e),
              (a.class_ = (e) =>
                a.function_(e) && e.toString().startsWith("class ")),
              (a.boolean = (e) => !0 === e || !1 === e),
              (a.symbol = i("symbol")),
              (a.numericString = (e) =>
                a.string(e) && e.length > 0 && !Number.isNaN(Number(e))),
              (a.array = Array.isArray),
              (a.buffer = (e) =>
                !a.nullOrUndefined(e) &&
                !a.nullOrUndefined(e.constructor) &&
                a.function_(e.constructor.isBuffer) &&
                e.constructor.isBuffer(e)),
              (a.nullOrUndefined = (e) => a.null_(e) || a.undefined(e)),
              (a.object = (e) =>
                !a.null_(e) && ("object" == typeof e || a.function_(e))),
              (a.iterable = (e) =>
                !a.nullOrUndefined(e) && a.function_(e[Symbol.iterator])),
              (a.asyncIterable = (e) =>
                !a.nullOrUndefined(e) && a.function_(e[Symbol.asyncIterator])),
              (a.generator = (e) =>
                a.iterable(e) && a.function_(e.next) && a.function_(e.throw)),
              (a.asyncGenerator = (e) =>
                a.asyncIterable(e) &&
                a.function_(e.next) &&
                a.function_(e.throw)),
              (a.nativePromise = (e) => s("Promise")(e)),
              (a.promise = (e) =>
                a.nativePromise(e) ||
                ((e) =>
                  a.object(e) && a.function_(e.then) && a.function_(e.catch))(
                  e
                )),
              (a.generatorFunction = s("GeneratorFunction")),
              (a.asyncGeneratorFunction = (e) =>
                "AsyncGeneratorFunction" === o(e)),
              (a.asyncFunction = (e) => "AsyncFunction" === o(e)),
              (a.boundFunction = (e) =>
                a.function_(e) && !e.hasOwnProperty("prototype")),
              (a.regExp = s("RegExp")),
              (a.date = s("Date")),
              (a.error = s("Error")),
              (a.map = (e) => s("Map")(e)),
              (a.set = (e) => s("Set")(e)),
              (a.weakMap = (e) => s("WeakMap")(e)),
              (a.weakSet = (e) => s("WeakSet")(e)),
              (a.int8Array = s("Int8Array")),
              (a.uint8Array = s("Uint8Array")),
              (a.uint8ClampedArray = s("Uint8ClampedArray")),
              (a.int16Array = s("Int16Array")),
              (a.uint16Array = s("Uint16Array")),
              (a.int32Array = s("Int32Array")),
              (a.uint32Array = s("Uint32Array")),
              (a.float32Array = s("Float32Array")),
              (a.float64Array = s("Float64Array")),
              (a.bigInt64Array = s("BigInt64Array")),
              (a.bigUint64Array = s("BigUint64Array")),
              (a.arrayBuffer = s("ArrayBuffer")),
              (a.sharedArrayBuffer = s("SharedArrayBuffer")),
              (a.dataView = s("DataView")),
              (a.directInstanceOf = (e, t) =>
                Object.getPrototypeOf(e) === t.prototype),
              (a.urlInstance = (e) => s("URL")(e)),
              (a.urlString = (e) => {
                if (!a.string(e)) return !1;
                try {
                  return new URL(e), !0;
                } catch (e) {
                  return !1;
                }
              }),
              (a.truthy = (e) => Boolean(e)),
              (a.falsy = (e) => !e),
              (a.nan = (e) => Number.isNaN(e));
            const u = new Set([
              "undefined",
              "string",
              "number",
              "bigint",
              "boolean",
              "symbol",
            ]);
            (a.primitive = (e) => a.null_(e) || u.has(typeof e)),
              (a.integer = (e) => Number.isInteger(e)),
              (a.safeInteger = (e) => Number.isSafeInteger(e)),
              (a.plainObject = (e) => {
                if ("Object" !== o(e)) return !1;
                const t = Object.getPrototypeOf(e);
                return null === t || t === Object.getPrototypeOf({});
              });
            const l = new Set([
              "Int8Array",
              "Uint8Array",
              "Uint8ClampedArray",
              "Int16Array",
              "Uint16Array",
              "Int32Array",
              "Uint32Array",
              "Float32Array",
              "Float64Array",
              "BigInt64Array",
              "BigUint64Array",
            ]);
            (a.typedArray = (e) => {
              const t = o(e);
              return void 0 !== t && l.has(t);
            }),
              (a.arrayLike = (e) =>
                !a.nullOrUndefined(e) &&
                !a.function_(e) &&
                ((e) => a.safeInteger(e) && e >= 0)(e.length)),
              (a.inRange = (e, t) => {
                if (a.number(t))
                  return e >= Math.min(0, t) && e <= Math.max(t, 0);
                if (a.array(t) && 2 === t.length)
                  return e >= Math.min(...t) && e <= Math.max(...t);
                throw new TypeError(`Invalid range: ${JSON.stringify(t)}`);
              });
            const d = [
              "innerHTML",
              "ownerDocument",
              "style",
              "attributes",
              "nodeValue",
            ];
            (a.domElement = (e) =>
              a.object(e) &&
              1 === e.nodeType &&
              a.string(e.nodeName) &&
              !a.plainObject(e) &&
              d.every((t) => t in e)),
              (a.observable = (e) =>
                !(
                  !e ||
                  !(
                    (e[Symbol.observable] && e === e[Symbol.observable]()) ||
                    (e["@@observable"] && e === e["@@observable"]())
                  )
                )),
              (a.nodeStream = (e) =>
                a.object(e) && a.function_(e.pipe) && !a.observable(e)),
              (a.infinite = (e) => e === 1 / 0 || e === -1 / 0);
            const p = (e) => (t) => a.integer(t) && Math.abs(t % 2) === e;
            (a.evenInteger = p(0)),
              (a.oddInteger = p(1)),
              (a.emptyArray = (e) => a.array(e) && 0 === e.length),
              (a.nonEmptyArray = (e) => a.array(e) && e.length > 0),
              (a.emptyString = (e) => a.string(e) && 0 === e.length),
              (a.nonEmptyString = (e) => a.string(e) && e.length > 0),
              (a.emptyStringOrWhitespace = (e) =>
                a.emptyString(e) ||
                ((e) => a.string(e) && !1 === /\S/.test(e))(e)),
              (a.emptyObject = (e) =>
                a.object(e) &&
                !a.map(e) &&
                !a.set(e) &&
                0 === Object.keys(e).length),
              (a.nonEmptyObject = (e) =>
                a.object(e) &&
                !a.map(e) &&
                !a.set(e) &&
                Object.keys(e).length > 0),
              (a.emptySet = (e) => a.set(e) && 0 === e.size),
              (a.nonEmptySet = (e) => a.set(e) && e.size > 0),
              (a.emptyMap = (e) => a.map(e) && 0 === e.size),
              (a.nonEmptyMap = (e) => a.map(e) && e.size > 0);
            const f = (e, t, r) => {
              if (!1 === a.function_(t))
                throw new TypeError(`Invalid predicate: ${JSON.stringify(t)}`);
              if (0 === r.length)
                throw new TypeError("Invalid number of values");
              return e.call(r, t);
            };
            (a.any = (e, ...t) =>
              (a.array(e) ? e : [e]).some((e) =>
                f(Array.prototype.some, e, t)
              )),
              (a.all = (e, ...t) => f(Array.prototype.every, e, t));
            const m = (e, t, r) => {
              if (!e)
                throw new TypeError(
                  `Expected value which is \`${t}\`, received value of type \`${a(
                    r
                  )}\`.`
                );
            };
            (t.assert = {
              undefined: (e) => m(a.undefined(e), "undefined", e),
              string: (e) => m(a.string(e), "string", e),
              number: (e) => m(a.number(e), "number", e),
              bigint: (e) => m(a.bigint(e), "bigint", e),
              function_: (e) => m(a.function_(e), "Function", e),
              null_: (e) => m(a.null_(e), "null", e),
              class_: (e) => m(a.class_(e), "Class", e),
              boolean: (e) => m(a.boolean(e), "boolean", e),
              symbol: (e) => m(a.symbol(e), "symbol", e),
              numericString: (e) =>
                m(a.numericString(e), "string with a number", e),
              array: (e) => m(a.array(e), "Array", e),
              buffer: (e) => m(a.buffer(e), "Buffer", e),
              nullOrUndefined: (e) =>
                m(a.nullOrUndefined(e), "null or undefined", e),
              object: (e) => m(a.object(e), "Object", e),
              iterable: (e) => m(a.iterable(e), "Iterable", e),
              asyncIterable: (e) => m(a.asyncIterable(e), "AsyncIterable", e),
              generator: (e) => m(a.generator(e), "Generator", e),
              asyncGenerator: (e) =>
                m(a.asyncGenerator(e), "AsyncGenerator", e),
              nativePromise: (e) => m(a.nativePromise(e), "native Promise", e),
              promise: (e) => m(a.promise(e), "Promise", e),
              generatorFunction: (e) =>
                m(a.generatorFunction(e), "GeneratorFunction", e),
              asyncGeneratorFunction: (e) =>
                m(a.asyncGeneratorFunction(e), "AsyncGeneratorFunction", e),
              asyncFunction: (e) => m(a.asyncFunction(e), "AsyncFunction", e),
              boundFunction: (e) => m(a.boundFunction(e), "Function", e),
              regExp: (e) => m(a.regExp(e), "RegExp", e),
              date: (e) => m(a.date(e), "Date", e),
              error: (e) => m(a.error(e), "Error", e),
              map: (e) => m(a.map(e), "Map", e),
              set: (e) => m(a.set(e), "Set", e),
              weakMap: (e) => m(a.weakMap(e), "WeakMap", e),
              weakSet: (e) => m(a.weakSet(e), "WeakSet", e),
              int8Array: (e) => m(a.int8Array(e), "Int8Array", e),
              uint8Array: (e) => m(a.uint8Array(e), "Uint8Array", e),
              uint8ClampedArray: (e) =>
                m(a.uint8ClampedArray(e), "Uint8ClampedArray", e),
              int16Array: (e) => m(a.int16Array(e), "Int16Array", e),
              uint16Array: (e) => m(a.uint16Array(e), "Uint16Array", e),
              int32Array: (e) => m(a.int32Array(e), "Int32Array", e),
              uint32Array: (e) => m(a.uint32Array(e), "Uint32Array", e),
              float32Array: (e) => m(a.float32Array(e), "Float32Array", e),
              float64Array: (e) => m(a.float64Array(e), "Float64Array", e),
              bigInt64Array: (e) => m(a.bigInt64Array(e), "BigInt64Array", e),
              bigUint64Array: (e) =>
                m(a.bigUint64Array(e), "BigUint64Array", e),
              arrayBuffer: (e) => m(a.arrayBuffer(e), "ArrayBuffer", e),
              sharedArrayBuffer: (e) =>
                m(a.sharedArrayBuffer(e), "SharedArrayBuffer", e),
              dataView: (e) => m(a.dataView(e), "DataView", e),
              urlInstance: (e) => m(a.urlInstance(e), "URL", e),
              urlString: (e) => m(a.urlString(e), "string with a URL", e),
              truthy: (e) => m(a.truthy(e), "truthy", e),
              falsy: (e) => m(a.falsy(e), "falsy", e),
              nan: (e) => m(a.nan(e), "NaN", e),
              primitive: (e) => m(a.primitive(e), "primitive", e),
              integer: (e) => m(a.integer(e), "integer", e),
              safeInteger: (e) => m(a.safeInteger(e), "integer", e),
              plainObject: (e) => m(a.plainObject(e), "plain object", e),
              typedArray: (e) => m(a.typedArray(e), "TypedArray", e),
              arrayLike: (e) => m(a.arrayLike(e), "array-like", e),
              domElement: (e) => m(a.domElement(e), "Element", e),
              observable: (e) => m(a.observable(e), "Observable", e),
              nodeStream: (e) => m(a.nodeStream(e), "Node.js Stream", e),
              infinite: (e) => m(a.infinite(e), "infinite number", e),
              emptyArray: (e) => m(a.emptyArray(e), "empty array", e),
              nonEmptyArray: (e) => m(a.nonEmptyArray(e), "non-empty array", e),
              emptyString: (e) => m(a.emptyString(e), "empty string", e),
              nonEmptyString: (e) =>
                m(a.nonEmptyString(e), "non-empty string", e),
              emptyStringOrWhitespace: (e) =>
                m(
                  a.emptyStringOrWhitespace(e),
                  "empty string or whitespace",
                  e
                ),
              emptyObject: (e) => m(a.emptyObject(e), "empty object", e),
              nonEmptyObject: (e) =>
                m(a.nonEmptyObject(e), "non-empty object", e),
              emptySet: (e) => m(a.emptySet(e), "empty set", e),
              nonEmptySet: (e) => m(a.nonEmptySet(e), "non-empty set", e),
              emptyMap: (e) => m(a.emptyMap(e), "empty map", e),
              nonEmptyMap: (e) => m(a.nonEmptyMap(e), "non-empty map", e),
              evenInteger: (e) => m(a.evenInteger(e), "even integer", e),
              oddInteger: (e) => m(a.oddInteger(e), "odd integer", e),
              directInstanceOf: (e, t) => m(a.directInstanceOf(e, t), "T", e),
              inRange: (e, t) => m(a.inRange(e, t), "in range", e),
              any: (e, ...t) =>
                m(a.any(e, ...t), "predicate returns truthy for any value", t),
              all: (e, ...t) =>
                m(a.all(e, ...t), "predicate returns truthy for all values", t),
            }),
              Object.defineProperties(a, {
                class: { value: a.class_ },
                function: { value: a.function_ },
                null: { value: a.null_ },
              }),
              Object.defineProperties(t.assert, {
                class: { value: t.assert.class_ },
                function: { value: t.assert.function_ },
                null: { value: t.assert.null_ },
              }),
              (t.default = a),
              (e.exports = a),
              (e.exports.default = a),
              (e.exports.assert = t.assert);
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }),
              (t.testSymbol = Symbol("test")),
              (t.isPredicate = (e) => Boolean(e[t.testSymbol]));
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }),
              (t.default = (e, t, r = 5) => {
                const n = [];
                for (const i of t)
                  if (!e.has(i) && (n.push(i), n.length === r)) return n;
                return 0 === n.length || n;
              });
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(10),
              i = r(11),
              o = r(0);
            t.Predicate = o.Predicate;
            const s = r(2),
              a = r(17),
              c = r(7),
              u = r(9),
              l = (e, t, r) => {
                if (!s.isPredicate(t) && "string" != typeof t)
                  throw new TypeError(
                    `Expected second argument to be a predicate or a string, got \`${typeof t}\``
                  );
                if (s.isPredicate(t)) {
                  const r = n.default();
                  u.default(e, () => i.inferLabel(r), t);
                } else u.default(e, t, r);
              };
            Object.defineProperties(l, {
              isValid: {
                value: (e, t) => {
                  try {
                    return l(e, t), !0;
                  } catch (e) {
                    return !1;
                  }
                },
              },
              create: {
                value: (e, t) => (r, o) => {
                  if (s.isPredicate(e)) {
                    const t = n.default();
                    u.default(r, null != o ? o : () => i.inferLabel(t), e);
                  } else u.default(r, null != o ? o : e, t);
                },
              },
            }),
              (t.default = c.default(a.default(l)));
            var d = r(7);
            (t.StringPredicate = d.StringPredicate),
              (t.NumberPredicate = d.NumberPredicate),
              (t.BooleanPredicate = d.BooleanPredicate),
              (t.ArrayPredicate = d.ArrayPredicate),
              (t.ObjectPredicate = d.ObjectPredicate),
              (t.DatePredicate = d.DatePredicate),
              (t.ErrorPredicate = d.ErrorPredicate),
              (t.MapPredicate = d.MapPredicate),
              (t.WeakMapPredicate = d.WeakMapPredicate),
              (t.SetPredicate = d.SetPredicate),
              (t.WeakSetPredicate = d.WeakSetPredicate),
              (t.TypedArrayPredicate = d.TypedArrayPredicate),
              (t.ArrayBufferPredicate = d.ArrayBufferPredicate),
              (t.DataViewPredicate = d.DataViewPredicate),
              (t.AnyPredicate = d.AnyPredicate);
            var p = r(6);
            t.ArgumentError = p.ArgumentError;
          },
          function (e, t, r) {
            (function (e) {
              var r = "[object Arguments]",
                n = "[object Map]",
                i = "[object Object]",
                o = "[object Set]",
                s = /^\[object .+?Constructor\]$/,
                a = /^(?:0|[1-9]\d*)$/,
                c = {};
              (c["[object Float32Array]"] =
                c["[object Float64Array]"] =
                c["[object Int8Array]"] =
                c["[object Int16Array]"] =
                c["[object Int32Array]"] =
                c["[object Uint8Array]"] =
                c["[object Uint8ClampedArray]"] =
                c["[object Uint16Array]"] =
                c["[object Uint32Array]"] =
                  !0),
                (c[r] =
                  c["[object Array]"] =
                  c["[object ArrayBuffer]"] =
                  c["[object Boolean]"] =
                  c["[object DataView]"] =
                  c["[object Date]"] =
                  c["[object Error]"] =
                  c["[object Function]"] =
                  c[n] =
                  c["[object Number]"] =
                  c[i] =
                  c["[object RegExp]"] =
                  c[o] =
                  c["[object String]"] =
                  c["[object WeakMap]"] =
                    !1);
              var u =
                  "object" == typeof global &&
                  global &&
                  global.Object === Object &&
                  global,
                l =
                  "object" == typeof self &&
                  self &&
                  self.Object === Object &&
                  self,
                d = u || l || Function("return this")(),
                p = t && !t.nodeType && t,
                f = p && "object" == typeof e && e && !e.nodeType && e,
                m = f && f.exports === p,
                h = m && u.process,
                g = (function () {
                  try {
                    return h && h.binding && h.binding("util");
                  } catch (e) {}
                })(),
                y = g && g.isTypedArray;
              function b(e, t) {
                for (var r = -1, n = null == e ? 0 : e.length; ++r < n; )
                  if (t(e[r], r, e)) return !0;
                return !1;
              }
              function _(e) {
                var t = -1,
                  r = Array(e.size);
                return (
                  e.forEach(function (e, n) {
                    r[++t] = [n, e];
                  }),
                  r
                );
              }
              function v(e) {
                var t = -1,
                  r = Array(e.size);
                return (
                  e.forEach(function (e) {
                    r[++t] = e;
                  }),
                  r
                );
              }
              var x,
                S,
                E,
                w = Array.prototype,
                A = Function.prototype,
                O = Object.prototype,
                P = d["__core-js_shared__"],
                $ = A.toString,
                T = O.hasOwnProperty,
                k = (x = /[^.]+$/.exec((P && P.keys && P.keys.IE_PROTO) || ""))
                  ? "Symbol(src)_1." + x
                  : "",
                R = O.toString,
                j = RegExp(
                  "^" +
                    $.call(T)
                      .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                      .replace(
                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                        "$1.*?"
                      ) +
                    "$"
                ),
                I = m ? d.Buffer : void 0,
                L = d.Symbol,
                C = d.Uint8Array,
                M = O.propertyIsEnumerable,
                B = w.splice,
                N = L ? L.toStringTag : void 0,
                F = Object.getOwnPropertySymbols,
                D = I ? I.isBuffer : void 0,
                H =
                  ((S = Object.keys),
                  (E = Object),
                  function (e) {
                    return S(E(e));
                  }),
                U = fe(d, "DataView"),
                G = fe(d, "Map"),
                V = fe(d, "Promise"),
                z = fe(d, "Set"),
                q = fe(d, "WeakMap"),
                W = fe(Object, "create"),
                K = ye(U),
                Q = ye(G),
                Y = ye(V),
                X = ye(z),
                J = ye(q),
                Z = L ? L.prototype : void 0,
                ee = Z ? Z.valueOf : void 0;
              function te(e) {
                var t = -1,
                  r = null == e ? 0 : e.length;
                for (this.clear(); ++t < r; ) {
                  var n = e[t];
                  this.set(n[0], n[1]);
                }
              }
              function re(e) {
                var t = -1,
                  r = null == e ? 0 : e.length;
                for (this.clear(); ++t < r; ) {
                  var n = e[t];
                  this.set(n[0], n[1]);
                }
              }
              function ne(e) {
                var t = -1,
                  r = null == e ? 0 : e.length;
                for (this.clear(); ++t < r; ) {
                  var n = e[t];
                  this.set(n[0], n[1]);
                }
              }
              function ie(e) {
                var t = -1,
                  r = null == e ? 0 : e.length;
                for (this.__data__ = new ne(); ++t < r; ) this.add(e[t]);
              }
              function oe(e) {
                var t = (this.__data__ = new re(e));
                this.size = t.size;
              }
              function se(e, t) {
                for (var r = e.length; r--; ) if (be(e[r][0], t)) return r;
                return -1;
              }
              function ae(e) {
                return null == e
                  ? void 0 === e
                    ? "[object Undefined]"
                    : "[object Null]"
                  : N && N in Object(e)
                  ? (function (e) {
                      var t = T.call(e, N),
                        r = e[N];
                      try {
                        e[N] = void 0;
                        var n = !0;
                      } catch (e) {}
                      var i = R.call(e);
                      return n && (t ? (e[N] = r) : delete e[N]), i;
                    })(e)
                  : (function (e) {
                      return R.call(e);
                    })(e);
              }
              function ce(e) {
                return Ae(e) && ae(e) == r;
              }
              function ue(e, t, s, a, c) {
                return (
                  e === t ||
                  (null == e || null == t || (!Ae(e) && !Ae(t))
                    ? e != e && t != t
                    : (function (e, t, s, a, c, u) {
                        var l = ve(e),
                          d = ve(t),
                          p = l ? "[object Array]" : he(e),
                          f = d ? "[object Array]" : he(t),
                          m = (p = p == r ? i : p) == i,
                          h = (f = f == r ? i : f) == i,
                          g = p == f;
                        if (g && xe(e)) {
                          if (!xe(t)) return !1;
                          (l = !0), (m = !1);
                        }
                        if (g && !m)
                          return (
                            u || (u = new oe()),
                            l || Oe(e)
                              ? le(e, t, s, a, c, u)
                              : (function (e, t, r, i, s, a, c) {
                                  switch (r) {
                                    case "[object DataView]":
                                      if (
                                        e.byteLength != t.byteLength ||
                                        e.byteOffset != t.byteOffset
                                      )
                                        return !1;
                                      (e = e.buffer), (t = t.buffer);
                                    case "[object ArrayBuffer]":
                                      return !(
                                        e.byteLength != t.byteLength ||
                                        !a(new C(e), new C(t))
                                      );
                                    case "[object Boolean]":
                                    case "[object Date]":
                                    case "[object Number]":
                                      return be(+e, +t);
                                    case "[object Error]":
                                      return (
                                        e.name == t.name &&
                                        e.message == t.message
                                      );
                                    case "[object RegExp]":
                                    case "[object String]":
                                      return e == t + "";
                                    case n:
                                      var u = _;
                                    case o:
                                      var l = 1 & i;
                                      if (
                                        (u || (u = v), e.size != t.size && !l)
                                      )
                                        return !1;
                                      var d = c.get(e);
                                      if (d) return d == t;
                                      (i |= 2), c.set(e, t);
                                      var p = le(u(e), u(t), i, s, a, c);
                                      return c.delete(e), p;
                                    case "[object Symbol]":
                                      if (ee) return ee.call(e) == ee.call(t);
                                  }
                                  return !1;
                                })(e, t, p, s, a, c, u)
                          );
                        if (!(1 & s)) {
                          var y = m && T.call(e, "__wrapped__"),
                            b = h && T.call(t, "__wrapped__");
                          if (y || b) {
                            var x = y ? e.value() : e,
                              S = b ? t.value() : t;
                            return u || (u = new oe()), c(x, S, s, a, u);
                          }
                        }
                        return (
                          !!g &&
                          (u || (u = new oe()),
                          (function (e, t, r, n, i, o) {
                            var s = 1 & r,
                              a = de(e),
                              c = a.length;
                            if (c != de(t).length && !s) return !1;
                            for (var u = c; u--; ) {
                              var l = a[u];
                              if (!(s ? l in t : T.call(t, l))) return !1;
                            }
                            var d = o.get(e);
                            if (d && o.get(t)) return d == t;
                            var p = !0;
                            o.set(e, t), o.set(t, e);
                            for (var f = s; ++u < c; ) {
                              var m = e[(l = a[u])],
                                h = t[l];
                              if (n)
                                var g = s
                                  ? n(h, m, l, t, e, o)
                                  : n(m, h, l, e, t, o);
                              if (
                                !(void 0 === g
                                  ? m === h || i(m, h, r, n, o)
                                  : g)
                              ) {
                                p = !1;
                                break;
                              }
                              f || (f = "constructor" == l);
                            }
                            if (p && !f) {
                              var y = e.constructor,
                                b = t.constructor;
                              y != b &&
                                "constructor" in e &&
                                "constructor" in t &&
                                !(
                                  "function" == typeof y &&
                                  y instanceof y &&
                                  "function" == typeof b &&
                                  b instanceof b
                                ) &&
                                (p = !1);
                            }
                            return o.delete(e), o.delete(t), p;
                          })(e, t, s, a, c, u))
                        );
                      })(e, t, s, a, ue, c))
                );
              }
              function le(e, t, r, n, i, o) {
                var s = 1 & r,
                  a = e.length,
                  c = t.length;
                if (a != c && !(s && c > a)) return !1;
                var u = o.get(e);
                if (u && o.get(t)) return u == t;
                var l = -1,
                  d = !0,
                  p = 2 & r ? new ie() : void 0;
                for (o.set(e, t), o.set(t, e); ++l < a; ) {
                  var f = e[l],
                    m = t[l];
                  if (n) var h = s ? n(m, f, l, t, e, o) : n(f, m, l, e, t, o);
                  if (void 0 !== h) {
                    if (h) continue;
                    d = !1;
                    break;
                  }
                  if (p) {
                    if (
                      !b(t, function (e, t) {
                        if (
                          ((s = t), !p.has(s) && (f === e || i(f, e, r, n, o)))
                        )
                          return p.push(t);
                        var s;
                      })
                    ) {
                      d = !1;
                      break;
                    }
                  } else if (f !== m && !i(f, m, r, n, o)) {
                    d = !1;
                    break;
                  }
                }
                return o.delete(e), o.delete(t), d;
              }
              function de(e) {
                return (function (e, t, r) {
                  var n = t(e);
                  return ve(e)
                    ? n
                    : (function (e, t) {
                        for (var r = -1, n = t.length, i = e.length; ++r < n; )
                          e[i + r] = t[r];
                        return e;
                      })(n, r(e));
                })(e, Pe, me);
              }
              function pe(e, t) {
                var r,
                  n,
                  i = e.__data__;
                return (
                  "string" == (n = typeof (r = t)) ||
                  "number" == n ||
                  "symbol" == n ||
                  "boolean" == n
                    ? "__proto__" !== r
                    : null === r
                )
                  ? i["string" == typeof t ? "string" : "hash"]
                  : i.map;
              }
              function fe(e, t) {
                var r = (function (e, t) {
                  return null == e ? void 0 : e[t];
                })(e, t);
                return (function (e) {
                  return (
                    !(
                      !we(e) ||
                      (function (e) {
                        return !!k && k in e;
                      })(e)
                    ) && (Se(e) ? j : s).test(ye(e))
                  );
                })(r)
                  ? r
                  : void 0;
              }
              (te.prototype.clear = function () {
                (this.__data__ = W ? W(null) : {}), (this.size = 0);
              }),
                (te.prototype.delete = function (e) {
                  var t = this.has(e) && delete this.__data__[e];
                  return (this.size -= t ? 1 : 0), t;
                }),
                (te.prototype.get = function (e) {
                  var t = this.__data__;
                  if (W) {
                    var r = t[e];
                    return "__lodash_hash_undefined__" === r ? void 0 : r;
                  }
                  return T.call(t, e) ? t[e] : void 0;
                }),
                (te.prototype.has = function (e) {
                  var t = this.__data__;
                  return W ? void 0 !== t[e] : T.call(t, e);
                }),
                (te.prototype.set = function (e, t) {
                  var r = this.__data__;
                  return (
                    (this.size += this.has(e) ? 0 : 1),
                    (r[e] =
                      W && void 0 === t ? "__lodash_hash_undefined__" : t),
                    this
                  );
                }),
                (re.prototype.clear = function () {
                  (this.__data__ = []), (this.size = 0);
                }),
                (re.prototype.delete = function (e) {
                  var t = this.__data__,
                    r = se(t, e);
                  return !(
                    r < 0 ||
                    (r == t.length - 1 ? t.pop() : B.call(t, r, 1),
                    --this.size,
                    0)
                  );
                }),
                (re.prototype.get = function (e) {
                  var t = this.__data__,
                    r = se(t, e);
                  return r < 0 ? void 0 : t[r][1];
                }),
                (re.prototype.has = function (e) {
                  return se(this.__data__, e) > -1;
                }),
                (re.prototype.set = function (e, t) {
                  var r = this.__data__,
                    n = se(r, e);
                  return (
                    n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this
                  );
                }),
                (ne.prototype.clear = function () {
                  (this.size = 0),
                    (this.__data__ = {
                      hash: new te(),
                      map: new (G || re)(),
                      string: new te(),
                    });
                }),
                (ne.prototype.delete = function (e) {
                  var t = pe(this, e).delete(e);
                  return (this.size -= t ? 1 : 0), t;
                }),
                (ne.prototype.get = function (e) {
                  return pe(this, e).get(e);
                }),
                (ne.prototype.has = function (e) {
                  return pe(this, e).has(e);
                }),
                (ne.prototype.set = function (e, t) {
                  var r = pe(this, e),
                    n = r.size;
                  return r.set(e, t), (this.size += r.size == n ? 0 : 1), this;
                }),
                (ie.prototype.add = ie.prototype.push =
                  function (e) {
                    return (
                      this.__data__.set(e, "__lodash_hash_undefined__"), this
                    );
                  }),
                (ie.prototype.has = function (e) {
                  return this.__data__.has(e);
                }),
                (oe.prototype.clear = function () {
                  (this.__data__ = new re()), (this.size = 0);
                }),
                (oe.prototype.delete = function (e) {
                  var t = this.__data__,
                    r = t.delete(e);
                  return (this.size = t.size), r;
                }),
                (oe.prototype.get = function (e) {
                  return this.__data__.get(e);
                }),
                (oe.prototype.has = function (e) {
                  return this.__data__.has(e);
                }),
                (oe.prototype.set = function (e, t) {
                  var r = this.__data__;
                  if (r instanceof re) {
                    var n = r.__data__;
                    if (!G || n.length < 199)
                      return n.push([e, t]), (this.size = ++r.size), this;
                    r = this.__data__ = new ne(n);
                  }
                  return r.set(e, t), (this.size = r.size), this;
                });
              var me = F
                  ? function (e) {
                      return null == e
                        ? []
                        : ((e = Object(e)),
                          (function (e, t) {
                            for (
                              var r = -1,
                                n = null == e ? 0 : e.length,
                                i = 0,
                                o = [];
                              ++r < n;

                            ) {
                              var s = e[r];
                              t(s) && (o[i++] = s);
                            }
                            return o;
                          })(F(e), function (t) {
                            return M.call(e, t);
                          }));
                    }
                  : function () {
                      return [];
                    },
                he = ae;
              function ge(e, t) {
                return (
                  !!(t = null == t ? 9007199254740991 : t) &&
                  ("number" == typeof e || a.test(e)) &&
                  e > -1 &&
                  e % 1 == 0 &&
                  e < t
                );
              }
              function ye(e) {
                if (null != e) {
                  try {
                    return $.call(e);
                  } catch (e) {}
                  try {
                    return e + "";
                  } catch (e) {}
                }
                return "";
              }
              function be(e, t) {
                return e === t || (e != e && t != t);
              }
              ((U && "[object DataView]" != he(new U(new ArrayBuffer(1)))) ||
                (G && he(new G()) != n) ||
                (V && "[object Promise]" != he(V.resolve())) ||
                (z && he(new z()) != o) ||
                (q && "[object WeakMap]" != he(new q()))) &&
                (he = function (e) {
                  var t = ae(e),
                    r = t == i ? e.constructor : void 0,
                    s = r ? ye(r) : "";
                  if (s)
                    switch (s) {
                      case K:
                        return "[object DataView]";
                      case Q:
                        return n;
                      case Y:
                        return "[object Promise]";
                      case X:
                        return o;
                      case J:
                        return "[object WeakMap]";
                    }
                  return t;
                });
              var _e = ce(
                  (function () {
                    return arguments;
                  })()
                )
                  ? ce
                  : function (e) {
                      return (
                        Ae(e) && T.call(e, "callee") && !M.call(e, "callee")
                      );
                    },
                ve = Array.isArray,
                xe =
                  D ||
                  function () {
                    return !1;
                  };
              function Se(e) {
                if (!we(e)) return !1;
                var t = ae(e);
                return (
                  "[object Function]" == t ||
                  "[object GeneratorFunction]" == t ||
                  "[object AsyncFunction]" == t ||
                  "[object Proxy]" == t
                );
              }
              function Ee(e) {
                return (
                  "number" == typeof e &&
                  e > -1 &&
                  e % 1 == 0 &&
                  e <= 9007199254740991
                );
              }
              function we(e) {
                var t = typeof e;
                return null != e && ("object" == t || "function" == t);
              }
              function Ae(e) {
                return null != e && "object" == typeof e;
              }
              var Oe = y
                ? (function (e) {
                    return function (t) {
                      return e(t);
                    };
                  })(y)
                : function (e) {
                    return Ae(e) && Ee(e.length) && !!c[ae(e)];
                  };
              function Pe(e) {
                return null != (t = e) && Ee(t.length) && !Se(t)
                  ? (function (e, t) {
                      var r = ve(e),
                        n = !r && _e(e),
                        i = !r && !n && xe(e),
                        o = !r && !n && !i && Oe(e),
                        s = r || n || i || o,
                        a = s
                          ? (function (e, t) {
                              for (var r = -1, n = Array(e); ++r < e; )
                                n[r] = t(r);
                              return n;
                            })(e.length, String)
                          : [],
                        c = a.length;
                      for (var u in e)
                        !T.call(e, u) ||
                          (s &&
                            ("length" == u ||
                              (i && ("offset" == u || "parent" == u)) ||
                              (o &&
                                ("buffer" == u ||
                                  "byteLength" == u ||
                                  "byteOffset" == u)) ||
                              ge(u, c))) ||
                          a.push(u);
                      return a;
                    })(e)
                  : (function (e) {
                      if (
                        ((r = (t = e) && t.constructor),
                        t !== (("function" == typeof r && r.prototype) || O))
                      )
                        return H(e);
                      var t,
                        r,
                        n = [];
                      for (var i in Object(e))
                        T.call(e, i) && "constructor" != i && n.push(i);
                      return n;
                    })(e);
                var t;
              }
              e.exports = function (e, t) {
                return ue(e, t);
              };
            }.call(this, r(23)(e)));
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            class n extends Error {
              constructor(e, t) {
                super(e),
                  Error.captureStackTrace
                    ? Error.captureStackTrace(this, t)
                    : (this.stack = new Error().stack),
                  (this.name = "ArgumentError");
              }
            }
            t.ArgumentError = n;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(18);
            t.StringPredicate = n.StringPredicate;
            const i = r(20);
            t.NumberPredicate = i.NumberPredicate;
            const o = r(21);
            t.BooleanPredicate = o.BooleanPredicate;
            const s = r(0),
              a = r(22);
            t.ArrayPredicate = a.ArrayPredicate;
            const c = r(24);
            t.ObjectPredicate = c.ObjectPredicate;
            const u = r(29);
            t.DatePredicate = u.DatePredicate;
            const l = r(30);
            t.ErrorPredicate = l.ErrorPredicate;
            const d = r(31);
            t.MapPredicate = d.MapPredicate;
            const p = r(32);
            t.WeakMapPredicate = p.WeakMapPredicate;
            const f = r(33);
            t.SetPredicate = f.SetPredicate;
            const m = r(34);
            t.WeakSetPredicate = m.WeakSetPredicate;
            const h = r(35);
            t.TypedArrayPredicate = h.TypedArrayPredicate;
            const g = r(36);
            t.ArrayBufferPredicate = g.ArrayBufferPredicate;
            const y = r(37);
            t.DataViewPredicate = y.DataViewPredicate;
            const b = r(38);
            (t.AnyPredicate = b.AnyPredicate),
              (t.default = (e, t) => (
                Object.defineProperties(e, {
                  string: { get: () => new n.StringPredicate(t) },
                  number: { get: () => new i.NumberPredicate(t) },
                  boolean: { get: () => new o.BooleanPredicate(t) },
                  undefined: { get: () => new s.Predicate("undefined", t) },
                  null: { get: () => new s.Predicate("null", t) },
                  nullOrUndefined: {
                    get: () => new s.Predicate("nullOrUndefined", t),
                  },
                  nan: { get: () => new s.Predicate("nan", t) },
                  symbol: { get: () => new s.Predicate("symbol", t) },
                  array: { get: () => new a.ArrayPredicate(t) },
                  object: { get: () => new c.ObjectPredicate(t) },
                  date: { get: () => new u.DatePredicate(t) },
                  error: { get: () => new l.ErrorPredicate(t) },
                  map: { get: () => new d.MapPredicate(t) },
                  weakMap: { get: () => new p.WeakMapPredicate(t) },
                  set: { get: () => new f.SetPredicate(t) },
                  weakSet: { get: () => new m.WeakSetPredicate(t) },
                  function: { get: () => new s.Predicate("Function", t) },
                  buffer: { get: () => new s.Predicate("Buffer", t) },
                  regExp: { get: () => new s.Predicate("RegExp", t) },
                  promise: { get: () => new s.Predicate("Promise", t) },
                  typedArray: {
                    get: () => new h.TypedArrayPredicate("TypedArray", t),
                  },
                  int8Array: {
                    get: () => new h.TypedArrayPredicate("Int8Array", t),
                  },
                  uint8Array: {
                    get: () => new h.TypedArrayPredicate("Uint8Array", t),
                  },
                  uint8ClampedArray: {
                    get: () =>
                      new h.TypedArrayPredicate("Uint8ClampedArray", t),
                  },
                  int16Array: {
                    get: () => new h.TypedArrayPredicate("Int16Array", t),
                  },
                  uint16Array: {
                    get: () => new h.TypedArrayPredicate("Uint16Array", t),
                  },
                  int32Array: {
                    get: () => new h.TypedArrayPredicate("Int32Array", t),
                  },
                  uint32Array: {
                    get: () => new h.TypedArrayPredicate("Uint32Array", t),
                  },
                  float32Array: {
                    get: () => new h.TypedArrayPredicate("Float32Array", t),
                  },
                  float64Array: {
                    get: () => new h.TypedArrayPredicate("Float64Array", t),
                  },
                  arrayBuffer: {
                    get: () => new g.ArrayBufferPredicate("ArrayBuffer", t),
                  },
                  sharedArrayBuffer: {
                    get: () =>
                      new g.ArrayBufferPredicate("SharedArrayBuffer", t),
                  },
                  dataView: { get: () => new y.DataViewPredicate(t) },
                  iterable: { get: () => new s.Predicate("Iterable", t) },
                  any: { value: (...e) => new b.AnyPredicate(e, t) },
                }),
                e
              ));
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(4);
            t.default = (e, t) => {
              try {
                for (const r of e) n.default(r, t);
                return !0;
              } catch (e) {
                return e.message;
              }
            };
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(2);
            t.default = function e(t, r, i) {
              i[n.testSymbol](t, e, r);
            };
          },
          function (e, t, r) {
            "use strict";
            const n = () => {
              const e = Error.prepareStackTrace;
              Error.prepareStackTrace = (e, t) => t;
              const t = new Error().stack.slice(1);
              return (Error.prepareStackTrace = e), t;
            };
            (e.exports = n), (e.exports.default = n);
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(12),
              i = r(13),
              o = r(14),
              s = /^.*?\((?<label>.*?)[,)]/;
            t.inferLabel = (e) => {
              var t;
              if (!o.default) return;
              const r = e[1],
                a = r.getFileName(),
                c = r.getLineNumber(),
                u = r.getColumnNumber();
              if (null === a || null === c || null === u) return;
              let l = [];
              try {
                l = n.readFileSync(a, "utf8").split("\n");
              } catch (e) {
                return;
              }
              let d = l[c - 1];
              if (!d) return;
              d = d.slice(u - 1);
              const p = s.exec(d);
              if (
                !(null === (t = null == p ? void 0 : p.groups) || void 0 === t
                  ? void 0
                  : t.label)
              )
                return;
              const f = p.groups.label;
              return i.default(f) || i.default(f.split(".").pop()) ? f : void 0;
            };
          },
          function (e, t) {
            e.exports = r(7147);
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = /^[a-z$_][a-z$_\d]*$/i,
              i = new Set([
                "undefined",
                "null",
                "true",
                "false",
                "super",
                "this",
                "Infinity",
                "NaN",
              ]);
            t.default = (e) => e && !i.has(e) && n.test(e);
          },
          function (e, t, r) {
            "use strict";
            var n;
            Object.defineProperty(t, "__esModule", { value: !0 }),
              (t.default = Boolean(
                null ===
                  (n =
                    null === process || void 0 === process
                      ? void 0
                      : process.versions) || void 0 === n
                  ? void 0
                  : n.node
              ));
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(16),
              i = r(0);
            t.not = (e) => {
              const t = e.addValidator;
              return (
                (e.addValidator = (r) => {
                  const { validator: o, message: s, negatedMessage: a } = r,
                    c = n.default();
                  return (
                    (r.message = (e, t) =>
                      a
                        ? a(e, t)
                        : s(e, c).replace(/ to /, "$&not ").replace(c, t)),
                    (r.validator = (e) => !o(e)),
                    e[i.validatorSymbol].push(r),
                    (e.addValidator = t),
                    e
                  );
                }),
                e
              );
            };
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 }),
              (t.default = () => Math.random().toString(16).slice(2));
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(7);
            t.default = (e) => (
              Object.defineProperties(e, {
                optional: { get: () => n.default({}, { optional: !0 }) },
              }),
              e
            );
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(1),
              i = r(19),
              o = r(0);
            class s extends o.Predicate {
              constructor(e) {
                super("string", e);
              }
              length(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have length \`${e}\`, got \`${t}\``,
                  validator: (t) => t.length === e,
                });
              }
              minLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum length of \`${e}\`, got \`${t}\``,
                  validator: (t) => t.length >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum length of \`${
                      e - 1
                    }\`, got \`${t}\``,
                });
              }
              maxLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum length of \`${e}\`, got \`${t}\``,
                  validator: (t) => t.length <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum length of \`${
                      e + 1
                    }\`, got \`${t}\``,
                });
              }
              matches(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to match \`${e}\`, got \`${t}\``,
                  validator: (t) => e.test(t),
                });
              }
              startsWith(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to start with \`${e}\`, got \`${t}\``,
                  validator: (t) => t.startsWith(e),
                });
              }
              endsWith(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to end with \`${e}\`, got \`${t}\``,
                  validator: (t) => t.endsWith(e),
                });
              }
              includes(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to include \`${e}\`, got \`${t}\``,
                  validator: (t) => t.includes(e),
                });
              }
              oneOf(e) {
                return this.addValidator({
                  message: (t, r) => {
                    let n = JSON.stringify(e);
                    if (e.length > 10) {
                      const t = e.length - 10;
                      n = JSON.stringify(e.slice(0, 10)).replace(
                        /]$/,
                        `,â¦+${t} more]`
                      );
                    }
                    return `Expected ${r} to be one of \`${n}\`, got \`${t}\``;
                  },
                  validator: (t) => e.includes(t),
                });
              }
              get empty() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be empty, got \`${e}\``,
                  validator: (e) => "" === e,
                });
              }
              get nonEmpty() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to not be empty`,
                  validator: (e) => "" !== e,
                });
              }
              equals(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be equal to \`${e}\`, got \`${t}\``,
                  validator: (t) => t === e,
                });
              }
              get alphanumeric() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be alphanumeric, got \`${e}\``,
                  validator: (e) => /^[a-z\d]+$/i.test(e),
                });
              }
              get alphabetical() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be alphabetical, got \`${e}\``,
                  validator: (e) => /^[a-z]+$/gi.test(e),
                });
              }
              get numeric() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be numeric, got \`${e}\``,
                  validator: (e) => /^(?:\+|-)?\d+$/i.test(e),
                });
              }
              get date() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be a date, got \`${e}\``,
                  validator: i,
                });
              }
              get lowercase() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be lowercase, got \`${e}\``,
                  validator: (e) => "" !== e.trim() && e === e.toLowerCase(),
                });
              }
              get uppercase() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be uppercase, got \`${e}\``,
                  validator: (e) => "" !== e.trim() && e === e.toUpperCase(),
                });
              }
              get url() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be a URL, got \`${e}\``,
                  validator: n.default.urlString,
                });
              }
            }
            t.StringPredicate = s;
          },
          function (e, t, r) {
            "use strict";
            e.exports = function (e) {
              return !isNaN(Date.parse(e));
            };
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(1),
              i = r(0);
            class o extends i.Predicate {
              constructor(e) {
                super("number", e);
              }
              inRange(e, t) {
                return this.addValidator({
                  message: (r, n) =>
                    `Expected ${n} to be in range [${e}..${t}], got ${r}`,
                  validator: (r) => n.default.inRange(r, [e, t]),
                });
              }
              greaterThan(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be greater than ${e}, got ${t}`,
                  validator: (t) => t > e,
                });
              }
              greaterThanOrEqual(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be greater than or equal to ${e}, got ${t}`,
                  validator: (t) => t >= e,
                });
              }
              lessThan(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be less than ${e}, got ${t}`,
                  validator: (t) => t < e,
                });
              }
              lessThanOrEqual(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be less than or equal to ${e}, got ${t}`,
                  validator: (t) => t <= e,
                });
              }
              equal(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be equal to ${e}, got ${t}`,
                  validator: (t) => t === e,
                });
              }
              oneOf(e) {
                return this.addValidator({
                  message: (t, r) => {
                    let n = JSON.stringify(e);
                    if (e.length > 10) {
                      const t = e.length - 10;
                      n = JSON.stringify(e.slice(0, 10)).replace(
                        /]$/,
                        `,â¦+${t} more]`
                      );
                    }
                    return `Expected ${r} to be one of \`${n}\`, got ${t}`;
                  },
                  validator: (t) => e.includes(t),
                });
              }
              get integer() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be an integer, got ${e}`,
                  validator: (e) => n.default.integer(e),
                });
              }
              get finite() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be finite, got ${e}`,
                  validator: (e) => !n.default.infinite(e),
                });
              }
              get infinite() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be infinite, got ${e}`,
                  validator: (e) => n.default.infinite(e),
                });
              }
              get positive() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be positive, got ${e}`,
                  validator: (e) => e > 0,
                });
              }
              get negative() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be negative, got ${e}`,
                  validator: (e) => e < 0,
                });
              }
              get integerOrInfinite() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be an integer or infinite, got ${e}`,
                  validator: (e) =>
                    n.default.integer(e) || n.default.infinite(e),
                });
              }
              get uint8() {
                return this.integer.inRange(0, 255);
              }
              get uint16() {
                return this.integer.inRange(0, 65535);
              }
              get uint32() {
                return this.integer.inRange(0, 4294967295);
              }
              get int8() {
                return this.integer.inRange(-128, 127);
              }
              get int16() {
                return this.integer.inRange(-32768, 32767);
              }
              get int32() {
                return this.integer.inRange(-2147483648, 2147483647);
              }
            }
            t.NumberPredicate = o;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(0);
            class i extends n.Predicate {
              constructor(e) {
                super("boolean", e);
              }
              get true() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be true, got ${e}`,
                  validator: (e) => e,
                });
              }
              get false() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be false, got ${e}`,
                  validator: (e) => !e,
                });
              }
            }
            t.BooleanPredicate = i;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(5),
              i = r(0),
              o = r(4);
            class s extends i.Predicate {
              constructor(e) {
                super("array", e);
              }
              length(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have length \`${e}\`, got \`${t.length}\``,
                  validator: (t) => t.length === e,
                });
              }
              minLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum length of \`${e}\`, got \`${t.length}\``,
                  validator: (t) => t.length >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum length of \`${
                      e - 1
                    }\`, got \`${t.length}\``,
                });
              }
              maxLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum length of \`${e}\`, got \`${t.length}\``,
                  validator: (t) => t.length <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum length of \`${
                      e + 1
                    }\`, got \`${t.length}\``,
                });
              }
              startsWith(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to start with \`${e}\`, got \`${t[0]}\``,
                  validator: (t) => t[0] === e,
                });
              }
              endsWith(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to end with \`${e}\`, got \`${
                      t[t.length - 1]
                    }\``,
                  validator: (t) => t[t.length - 1] === e,
                });
              }
              includes(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to include all elements of \`${JSON.stringify(
                      e
                    )}\`, got \`${JSON.stringify(t)}\``,
                  validator: (t) => e.every((e) => t.includes(e)),
                });
              }
              includesAny(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to include any element of \`${JSON.stringify(
                      e
                    )}\`, got \`${JSON.stringify(t)}\``,
                  validator: (t) => e.some((e) => t.includes(e)),
                });
              }
              get empty() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be empty, got \`${JSON.stringify(e)}\``,
                  validator: (e) => 0 === e.length,
                });
              }
              get nonEmpty() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to not be empty`,
                  validator: (e) => e.length > 0,
                });
              }
              deepEqual(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be deeply equal to \`${JSON.stringify(
                      e
                    )}\`, got \`${JSON.stringify(t)}\``,
                  validator: (t) => n(t, e),
                });
              }
              ofType(e) {
                let t;
                return this.addValidator({
                  message: (e, r) => `(${r}) ${t}`,
                  validator: (r) => {
                    try {
                      for (const t of r) o.default(t, e);
                      return !0;
                    } catch (e) {
                      return (t = e.message), !1;
                    }
                  },
                });
              }
            }
            t.ArrayPredicate = s;
          },
          function (e, t) {
            e.exports = function (e) {
              return (
                e.webpackPolyfill ||
                  ((e.deprecate = function () {}),
                  (e.paths = []),
                  e.children || (e.children = []),
                  Object.defineProperty(e, "loaded", {
                    enumerable: !0,
                    get: function () {
                      return e.l;
                    },
                  }),
                  Object.defineProperty(e, "id", {
                    enumerable: !0,
                    get: function () {
                      return e.i;
                    },
                  }),
                  (e.webpackPolyfill = 1)),
                e
              );
            };
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(1),
              i = r(25),
              o = r(5),
              s = r(3),
              a = r(8),
              c = r(27),
              u = r(28),
              l = r(0);
            class d extends l.Predicate {
              constructor(e) {
                super("object", e);
              }
              get plain() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to be a plain object`,
                  validator: (e) => n.default.plainObject(e),
                });
              }
              get empty() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be empty, got \`${JSON.stringify(e)}\``,
                  validator: (e) => 0 === Object.keys(e).length,
                });
              }
              get nonEmpty() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to not be empty`,
                  validator: (e) => Object.keys(e).length > 0,
                });
              }
              valuesOfType(e) {
                return this.addValidator({
                  message: (e, t, r) => `(${t}) ${r}`,
                  validator: (t) => a.default(Object.values(t), e),
                });
              }
              deepValuesOfType(e) {
                return this.addValidator({
                  message: (e, t, r) => `(${t}) ${r}`,
                  validator: (t) => c.default(t, e),
                });
              }
              deepEqual(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be deeply equal to \`${JSON.stringify(
                      e
                    )}\`, got \`${JSON.stringify(t)}\``,
                  validator: (t) => o(t, e),
                });
              }
              instanceOf(e) {
                return this.addValidator({
                  message: (t, r) => {
                    let { name: n } = t.constructor;
                    return (
                      (n && "Object" !== n) || (n = JSON.stringify(t)),
                      `Expected ${r} \`${n}\` to be of type \`${e.name}\``
                    );
                  },
                  validator: (t) => t instanceof e,
                });
              }
              hasKeys(...e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `Expected ${t} to have keys \`${JSON.stringify(r)}\``,
                  validator: (t) => s.default({ has: (e) => i.has(t, e) }, e),
                });
              }
              hasAnyKeys(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have any key of \`${JSON.stringify(e)}\``,
                  validator: (t) => e.some((e) => i.has(t, e)),
                });
              }
              partialShape(e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `${r.replace("Expected", "Expected property")} in ${t}`,
                  validator: (t) => u.partial(t, e),
                });
              }
              exactShape(e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `${r.replace("Expected", "Expected property")} in ${t}`,
                  validator: (t) => u.exact(t, e),
                });
              }
            }
            t.ObjectPredicate = d;
          },
          function (e, t, r) {
            "use strict";
            const n = r(26),
              i = ["__proto__", "prototype", "constructor"];
            function o(e) {
              const t = e.split("."),
                r = [];
              for (let e = 0; e < t.length; e++) {
                let n = t[e];
                for (; "\\" === n[n.length - 1] && void 0 !== t[e + 1]; )
                  (n = n.slice(0, -1) + "."), (n += t[++e]);
                r.push(n);
              }
              return r.some((e) => i.includes(e)) ? [] : r;
            }
            e.exports = {
              get(e, t, r) {
                if (!n(e) || "string" != typeof t) return void 0 === r ? e : r;
                const i = o(t);
                if (0 !== i.length) {
                  for (let t = 0; t < i.length; t++) {
                    if (!Object.prototype.propertyIsEnumerable.call(e, i[t]))
                      return r;
                    if (null == (e = e[i[t]])) {
                      if (t !== i.length - 1) return r;
                      break;
                    }
                  }
                  return e;
                }
              },
              set(e, t, r) {
                if (!n(e) || "string" != typeof t) return e;
                const i = e,
                  s = o(t);
                for (let t = 0; t < s.length; t++) {
                  const i = s[t];
                  n(e[i]) || (e[i] = {}),
                    t === s.length - 1 && (e[i] = r),
                    (e = e[i]);
                }
                return i;
              },
              delete(e, t) {
                if (!n(e) || "string" != typeof t) return;
                const r = o(t);
                for (let t = 0; t < r.length; t++) {
                  const i = r[t];
                  if (t === r.length - 1) return void delete e[i];
                  if (((e = e[i]), !n(e))) return;
                }
              },
              has(e, t) {
                if (!n(e) || "string" != typeof t) return !1;
                const r = o(t);
                if (0 === r.length) return !1;
                for (let t = 0; t < r.length; t++) {
                  if (!n(e)) return !1;
                  if (!(r[t] in e)) return !1;
                  e = e[r[t]];
                }
                return !0;
              },
            };
          },
          function (e, t, r) {
            "use strict";
            e.exports = (e) => {
              const t = typeof e;
              return null !== e && ("object" === t || "function" === t);
            };
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(1),
              i = r(4),
              o = (e, t) =>
                n.default.plainObject(e)
                  ? Object.values(e).every((e) => o(e, t))
                  : (i.default(e, t), !0);
            t.default = (e, t) => {
              try {
                return o(e, t);
              } catch (e) {
                return e.message;
              }
            };
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(1),
              i = r(9),
              o = r(2);
            (t.partial = function e(t, r, s) {
              try {
                for (const a of Object.keys(r)) {
                  const c = s ? `${s}.${a}` : a;
                  if (o.isPredicate(r[a])) i.default(t[a], c, r[a]);
                  else if (n.default.plainObject(r[a])) {
                    const n = e(t[a], r[a], c);
                    if (!0 !== n) return n;
                  }
                }
                return !0;
              } catch (e) {
                return e.message;
              }
            }),
              (t.exact = function e(t, r, s) {
                try {
                  const a = new Set(Object.keys(t));
                  for (const c of Object.keys(r)) {
                    a.delete(c);
                    const u = s ? `${s}.${c}` : c;
                    if (o.isPredicate(r[c])) i.default(t[c], u, r[c]);
                    else if (n.default.plainObject(r[c])) {
                      if (!Object.prototype.hasOwnProperty.call(t, c))
                        return `Expected \`${u}\` to exist`;
                      const n = e(t[c], r[c], u);
                      if (!0 !== n) return n;
                    }
                  }
                  if (a.size > 0) {
                    const e = [...a.keys()][0];
                    return `Did not expect property \`${
                      s ? `${s}.${e}` : e
                    }\` to exist, got \`${t[e]}\``;
                  }
                  return !0;
                } catch (e) {
                  return e.message;
                }
              });
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(0);
            class i extends n.Predicate {
              constructor(e) {
                super("date", e);
              }
              before(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} ${t.toISOString()} to be before ${e.toISOString()}`,
                  validator: (t) => t.getTime() < e.getTime(),
                });
              }
              after(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} ${t.toISOString()} to be after ${e.toISOString()}`,
                  validator: (t) => t.getTime() > e.getTime(),
                });
              }
            }
            t.DatePredicate = i;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(0);
            class i extends n.Predicate {
              constructor(e) {
                super("error", e);
              }
              name(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have name \`${e}\`, got \`${t.name}\``,
                  validator: (t) => t.name === e,
                });
              }
              message(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} message to be \`${e}\`, got \`${t.message}\``,
                  validator: (t) => t.message === e,
                });
              }
              messageIncludes(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} message to include \`${e}\`, got \`${t.message}\``,
                  validator: (t) => t.message.includes(e),
                });
              }
              hasKeys(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} message to have keys \`${e.join("`, `")}\``,
                  validator: (t) =>
                    e.every((e) => Object.prototype.hasOwnProperty.call(t, e)),
                });
              }
              instanceOf(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} \`${t.name}\` to be of type \`${e.name}\``,
                  validator: (t) => t instanceof e,
                });
              }
              get typeError() {
                return this.instanceOf(TypeError);
              }
              get evalError() {
                return this.instanceOf(EvalError);
              }
              get rangeError() {
                return this.instanceOf(RangeError);
              }
              get referenceError() {
                return this.instanceOf(ReferenceError);
              }
              get syntaxError() {
                return this.instanceOf(SyntaxError);
              }
              get uriError() {
                return this.instanceOf(URIError);
              }
            }
            t.ErrorPredicate = i;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(5),
              i = r(3),
              o = r(8),
              s = r(0);
            class a extends s.Predicate {
              constructor(e) {
                super("Map", e);
              }
              size(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have size \`${e}\`, got \`${t.size}\``,
                  validator: (t) => t.size === e,
                });
              }
              minSize(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum size of \`${e}\`, got \`${t.size}\``,
                  validator: (t) => t.size >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum size of \`${
                      e - 1
                    }\`, got \`${t.size}\``,
                });
              }
              maxSize(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum size of \`${e}\`, got \`${t.size}\``,
                  validator: (t) => t.size <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum size of \`${
                      e + 1
                    }\`, got \`${t.size}\``,
                });
              }
              hasKeys(...e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `Expected ${t} to have keys \`${JSON.stringify(r)}\``,
                  validator: (t) => i.default(t, e),
                });
              }
              hasAnyKeys(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have any key of \`${JSON.stringify(e)}\``,
                  validator: (t) => e.some((e) => t.has(e)),
                });
              }
              hasValues(...e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `Expected ${t} to have values \`${JSON.stringify(r)}\``,
                  validator: (t) => i.default(new Set(t.values()), e),
                });
              }
              hasAnyValues(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have any value of \`${JSON.stringify(
                      e
                    )}\``,
                  validator: (t) => {
                    const r = new Set(t.values());
                    return e.some((e) => r.has(e));
                  },
                });
              }
              keysOfType(e) {
                return this.addValidator({
                  message: (e, t, r) => `(${t}) ${r}`,
                  validator: (t) => o.default(t.keys(), e),
                });
              }
              valuesOfType(e) {
                return this.addValidator({
                  message: (e, t, r) => `(${t}) ${r}`,
                  validator: (t) => o.default(t.values(), e),
                });
              }
              get empty() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be empty, got \`${JSON.stringify([
                      ...e,
                    ])}\``,
                  validator: (e) => 0 === e.size,
                });
              }
              get nonEmpty() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to not be empty`,
                  validator: (e) => e.size > 0,
                });
              }
              deepEqual(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be deeply equal to \`${JSON.stringify([
                      ...e,
                    ])}\`, got \`${JSON.stringify([...t])}\``,
                  validator: (t) => n(t, e),
                });
              }
            }
            t.MapPredicate = a;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(3),
              i = r(0);
            class o extends i.Predicate {
              constructor(e) {
                super("WeakMap", e);
              }
              hasKeys(...e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `Expected ${t} to have keys \`${JSON.stringify(r)}\``,
                  validator: (t) => n.default(t, e),
                });
              }
              hasAnyKeys(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have any key of \`${JSON.stringify(e)}\``,
                  validator: (t) => e.some((e) => t.has(e)),
                });
              }
            }
            t.WeakMapPredicate = o;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(5),
              i = r(3),
              o = r(8),
              s = r(0);
            class a extends s.Predicate {
              constructor(e) {
                super("Set", e);
              }
              size(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have size \`${e}\`, got \`${t.size}\``,
                  validator: (t) => t.size === e,
                });
              }
              minSize(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum size of \`${e}\`, got \`${t.size}\``,
                  validator: (t) => t.size >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum size of \`${
                      e - 1
                    }\`, got \`${t.size}\``,
                });
              }
              maxSize(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum size of \`${e}\`, got \`${t.size}\``,
                  validator: (t) => t.size <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum size of \`${
                      e + 1
                    }\`, got \`${t.size}\``,
                });
              }
              has(...e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `Expected ${t} to have items \`${JSON.stringify(r)}\``,
                  validator: (t) => i.default(t, e),
                });
              }
              hasAny(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have any item of \`${JSON.stringify(
                      e
                    )}\``,
                  validator: (t) => e.some((e) => t.has(e)),
                });
              }
              ofType(e) {
                return this.addValidator({
                  message: (e, t, r) => `(${t}) ${r}`,
                  validator: (t) => o.default(t, e),
                });
              }
              get empty() {
                return this.addValidator({
                  message: (e, t) =>
                    `Expected ${t} to be empty, got \`${JSON.stringify([
                      ...e,
                    ])}\``,
                  validator: (e) => 0 === e.size,
                });
              }
              get nonEmpty() {
                return this.addValidator({
                  message: (e, t) => `Expected ${t} to not be empty`,
                  validator: (e) => e.size > 0,
                });
              }
              deepEqual(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to be deeply equal to \`${JSON.stringify([
                      ...e,
                    ])}\`, got \`${JSON.stringify([...t])}\``,
                  validator: (t) => n(t, e),
                });
              }
            }
            t.SetPredicate = a;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(3),
              i = r(0);
            class o extends i.Predicate {
              constructor(e) {
                super("WeakSet", e);
              }
              has(...e) {
                return this.addValidator({
                  message: (e, t, r) =>
                    `Expected ${t} to have items \`${JSON.stringify(r)}\``,
                  validator: (t) => n.default(t, e),
                });
              }
              hasAny(...e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have any item of \`${JSON.stringify(
                      e
                    )}\``,
                  validator: (t) => e.some((e) => t.has(e)),
                });
              }
            }
            t.WeakSetPredicate = o;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(0);
            class i extends n.Predicate {
              byteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength === e,
                });
              }
              minByteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum byte length of \`${
                      e - 1
                    }\`, got \`${t.byteLength}\``,
                });
              }
              maxByteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum byte length of \`${
                      e + 1
                    }\`, got \`${t.byteLength}\``,
                });
              }
              length(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have length \`${e}\`, got \`${t.length}\``,
                  validator: (t) => t.length === e,
                });
              }
              minLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum length of \`${e}\`, got \`${t.length}\``,
                  validator: (t) => t.length >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum length of \`${
                      e - 1
                    }\`, got \`${t.length}\``,
                });
              }
              maxLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum length of \`${e}\`, got \`${t.length}\``,
                  validator: (t) => t.length <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum length of \`${
                      e + 1
                    }\`, got \`${t.length}\``,
                });
              }
            }
            t.TypedArrayPredicate = i;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(0);
            class i extends n.Predicate {
              byteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength === e,
                });
              }
              minByteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum byte length of \`${
                      e - 1
                    }\`, got \`${t.byteLength}\``,
                });
              }
              maxByteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum byte length of \`${
                      e + 1
                    }\`, got \`${t.byteLength}\``,
                });
              }
            }
            t.ArrayBufferPredicate = i;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(0);
            class i extends n.Predicate {
              constructor(e) {
                super("DataView", e);
              }
              byteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength === e,
                });
              }
              minByteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a minimum byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength >= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a maximum byte length of \`${
                      e - 1
                    }\`, got \`${t.byteLength}\``,
                });
              }
              maxByteLength(e) {
                return this.addValidator({
                  message: (t, r) =>
                    `Expected ${r} to have a maximum byte length of \`${e}\`, got \`${t.byteLength}\``,
                  validator: (t) => t.byteLength <= e,
                  negatedMessage: (t, r) =>
                    `Expected ${r} to have a minimum byte length of \`${
                      e + 1
                    }\`, got \`${t.byteLength}\``,
                });
              }
            }
            t.DataViewPredicate = i;
          },
          function (e, t, r) {
            "use strict";
            Object.defineProperty(t, "__esModule", { value: !0 });
            const n = r(6),
              i = r(2);
            t.AnyPredicate = class {
              constructor(e, t = {}) {
                (this.predicates = e), (this.options = t);
              }
              [i.testSymbol](e, t, r) {
                const i = ["Any predicate failed with the following errors:"];
                for (const n of this.predicates)
                  try {
                    return void t(e, r, n);
                  } catch (t) {
                    if (void 0 === e && !0 === this.options.optional) return;
                    i.push(`- ${t.message}`);
                  }
                throw new n.ArgumentError(i.join("\n"), t);
              }
            };
          },
        ]);
        const n = e.exports;
        (e.exports = n.default), Object.assign(e.exports, n);
      },
      3024: (e) => {
        "use strict";
        const t = (e = {}) => {
          const t = e.env || process.env;
          return "win32" !== (e.platform || process.platform)
            ? "PATH"
            : Object.keys(t)
                .reverse()
                .find((e) => "PATH" === e.toUpperCase()) || "Path";
        };
        (e.exports = t), (e.exports.default = t);
      },
      9847: (e, t, r) => {
        "use strict";
        const { promisify: n } = r(3837),
          i = r(7147);
        async function o(e, t, r) {
          if ("string" != typeof r)
            throw new TypeError("Expected a string, got " + typeof r);
          try {
            return (await n(i[e])(r))[t]();
          } catch (e) {
            if ("ENOENT" === e.code) return !1;
            throw e;
          }
        }
        function s(e, t, r) {
          if ("string" != typeof r)
            throw new TypeError("Expected a string, got " + typeof r);
          try {
            return i[e](r)[t]();
          } catch (e) {
            if ("ENOENT" === e.code) return !1;
            throw e;
          }
        }
        (t.isFile = o.bind(null, "stat", "isFile")),
          (t.isDirectory = o.bind(null, "stat", "isDirectory")),
          (t.isSymlink = o.bind(null, "lstat", "isSymbolicLink")),
          (t.isFileSync = s.bind(null, "statSync", "isFile")),
          (t.isDirectorySync = s.bind(null, "statSync", "isDirectory")),
          (t.isSymlinkSync = s.bind(null, "lstatSync", "isSymbolicLink"));
      },
      8985: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Deferred = void 0),
          (t.Deferred = class {
            constructor() {
              (this.resolve = () => null),
                (this.reject = () => null),
                (this.promise = new Promise((e, t) => {
                  (this.reject = t), (this.resolve = e);
                }));
            }
          });
      },
      7279: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EndOfStreamError = t.defaultMessages = void 0),
          (t.defaultMessages = "End-Of-Stream");
        class r extends Error {
          constructor() {
            super(t.defaultMessages);
          }
        }
        t.EndOfStreamError = r;
      },
      6654: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StreamReader = t.EndOfStreamError = void 0);
        const n = r(7279),
          i = r(8985);
        var o = r(7279);
        Object.defineProperty(t, "EndOfStreamError", {
          enumerable: !0,
          get: function () {
            return o.EndOfStreamError;
          },
        }),
          (t.StreamReader = class {
            constructor(e) {
              if (
                ((this.s = e),
                (this.deferred = null),
                (this.endOfStream = !1),
                (this.peekQueue = []),
                !e.read || !e.once)
              )
                throw new Error("Expected an instance of stream.Readable");
              this.s.once("end", () => this.reject(new n.EndOfStreamError())),
                this.s.once("error", (e) => this.reject(e)),
                this.s.once("close", () =>
                  this.reject(new Error("Stream closed"))
                );
            }
            async peek(e, t, r) {
              const n = await this.read(e, t, r);
              return this.peekQueue.push(e.subarray(t, t + n)), n;
            }
            async read(e, t, r) {
              if (0 === r) return 0;
              if (0 === this.peekQueue.length && this.endOfStream)
                throw new n.EndOfStreamError();
              let i = r,
                o = 0;
              for (; this.peekQueue.length > 0 && i > 0; ) {
                const r = this.peekQueue.pop();
                if (!r) throw new Error("peekData should be defined");
                const n = Math.min(r.length, i);
                e.set(r.subarray(0, n), t + o),
                  (o += n),
                  (i -= n),
                  n < r.length && this.peekQueue.push(r.subarray(n));
              }
              for (; i > 0 && !this.endOfStream; ) {
                const r = Math.min(i, 1048576),
                  n = await this.readFromStream(e, t + o, r);
                if (((o += n), n < r)) break;
                i -= n;
              }
              return o;
            }
            async readFromStream(e, t, r) {
              const n = this.s.read(r);
              if (n) return e.set(n, t), n.length;
              {
                const n = {
                  buffer: e,
                  offset: t,
                  length: r,
                  deferred: new i.Deferred(),
                };
                return (
                  (this.deferred = n.deferred),
                  this.s.once("readable", () => {
                    this.readDeferred(n);
                  }),
                  n.deferred.promise
                );
              }
            }
            readDeferred(e) {
              const t = this.s.read(e.length);
              t
                ? (e.buffer.set(t, e.offset),
                  e.deferred.resolve(t.length),
                  (this.deferred = null))
                : this.s.once("readable", () => {
                    this.readDeferred(e);
                  });
            }
            reject(e) {
              (this.endOfStream = !0),
                this.deferred &&
                  (this.deferred.reject(e), (this.deferred = null));
            }
          });
      },
      5167: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.StreamReader = t.EndOfStreamError = void 0);
        var n = r(7279);
        Object.defineProperty(t, "EndOfStreamError", {
          enumerable: !0,
          get: function () {
            return n.EndOfStreamError;
          },
        });
        var i = r(6654);
        Object.defineProperty(t, "StreamReader", {
          enumerable: !0,
          get: function () {
            return i.StreamReader;
          },
        });
      },
      9444: (e, t, r) => {
        "use strict";
        e.exports = r(6087);
      },
      1006: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = "\\.{1,2}(?:\\/|$)",
          o = {
            DOT_LITERAL: "\\.",
            PLUS_LITERAL: "\\+",
            QMARK_LITERAL: "\\?",
            SLASH_LITERAL: "\\/",
            ONE_CHAR: "(?=.)",
            QMARK: "[^/]",
            END_ANCHOR: "(?:\\/|$)",
            DOTS_SLASH: i,
            NO_DOT: "(?!\\.)",
            NO_DOTS: `(?!(?:^|\\/)${i})`,
            NO_DOT_SLASH: "(?!\\.{0,1}(?:\\/|$))",
            NO_DOTS_SLASH: `(?!${i})`,
            QMARK_NO_DOT: "[^.\\/]",
            STAR: "[^/]*?",
            START_ANCHOR: "(?:^|\\/)",
          },
          s = {
            ...o,
            SLASH_LITERAL: "[\\\\/]",
            QMARK: "[^\\\\/]",
            STAR: "[^\\\\/]*?",
            DOTS_SLASH: "\\.{1,2}(?:[\\\\/]|$)",
            NO_DOT: "(?!\\.)",
            NO_DOTS: "(?!(?:^|[\\\\/])\\.{1,2}(?:[\\\\/]|$))",
            NO_DOT_SLASH: "(?!\\.{0,1}(?:[\\\\/]|$))",
            NO_DOTS_SLASH: "(?!\\.{1,2}(?:[\\\\/]|$))",
            QMARK_NO_DOT: "[^.\\\\/]",
            START_ANCHOR: "(?:^|[\\\\/])",
            END_ANCHOR: "(?:[\\\\/]|$)",
          };
        e.exports = {
          MAX_LENGTH: 65536,
          POSIX_REGEX_SOURCE: {
            alnum: "a-zA-Z0-9",
            alpha: "a-zA-Z",
            ascii: "\\x00-\\x7F",
            blank: " \\t",
            cntrl: "\\x00-\\x1F\\x7F",
            digit: "0-9",
            graph: "\\x21-\\x7E",
            lower: "a-z",
            print: "\\x20-\\x7E ",
            punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
            space: " \\t\\r\\n\\v\\f",
            upper: "A-Z",
            word: "A-Za-z0-9_",
            xdigit: "A-Fa-f0-9",
          },
          REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
          REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
          REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
          REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
          REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
          REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
          REPLACEMENTS: { "***": "*", "**/**": "**", "**/**/**": "**" },
          CHAR_0: 48,
          CHAR_9: 57,
          CHAR_UPPERCASE_A: 65,
          CHAR_LOWERCASE_A: 97,
          CHAR_UPPERCASE_Z: 90,
          CHAR_LOWERCASE_Z: 122,
          CHAR_LEFT_PARENTHESES: 40,
          CHAR_RIGHT_PARENTHESES: 41,
          CHAR_ASTERISK: 42,
          CHAR_AMPERSAND: 38,
          CHAR_AT: 64,
          CHAR_BACKWARD_SLASH: 92,
          CHAR_CARRIAGE_RETURN: 13,
          CHAR_CIRCUMFLEX_ACCENT: 94,
          CHAR_COLON: 58,
          CHAR_COMMA: 44,
          CHAR_DOT: 46,
          CHAR_DOUBLE_QUOTE: 34,
          CHAR_EQUAL: 61,
          CHAR_EXCLAMATION_MARK: 33,
          CHAR_FORM_FEED: 12,
          CHAR_FORWARD_SLASH: 47,
          CHAR_GRAVE_ACCENT: 96,
          CHAR_HASH: 35,
          CHAR_HYPHEN_MINUS: 45,
          CHAR_LEFT_ANGLE_BRACKET: 60,
          CHAR_LEFT_CURLY_BRACE: 123,
          CHAR_LEFT_SQUARE_BRACKET: 91,
          CHAR_LINE_FEED: 10,
          CHAR_NO_BREAK_SPACE: 160,
          CHAR_PERCENT: 37,
          CHAR_PLUS: 43,
          CHAR_QUESTION_MARK: 63,
          CHAR_RIGHT_ANGLE_BRACKET: 62,
          CHAR_RIGHT_CURLY_BRACE: 125,
          CHAR_RIGHT_SQUARE_BRACKET: 93,
          CHAR_SEMICOLON: 59,
          CHAR_SINGLE_QUOTE: 39,
          CHAR_SPACE: 32,
          CHAR_TAB: 9,
          CHAR_UNDERSCORE: 95,
          CHAR_VERTICAL_LINE: 124,
          CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
          SEP: n.sep,
          extglobChars: (e) => ({
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${e.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" },
          }),
          globChars: (e) => (!0 === e ? s : o),
        };
      },
      3376: (e, t, r) => {
        "use strict";
        const n = r(1006),
          i = r(8702),
          {
            MAX_LENGTH: o,
            POSIX_REGEX_SOURCE: s,
            REGEX_NON_SPECIAL_CHARS: a,
            REGEX_SPECIAL_CHARS_BACKREF: c,
            REPLACEMENTS: u,
          } = n,
          l = (e, t) => {
            if ("function" == typeof t.expandRange)
              return t.expandRange(...e, t);
            e.sort();
            const r = `[${e.join("-")}]`;
            try {
              new RegExp(r);
            } catch (t) {
              return e.map((e) => i.escapeRegex(e)).join("..");
            }
            return r;
          },
          d = (e, t) =>
            `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`,
          p = (e, t) => {
            if ("string" != typeof e) throw new TypeError("Expected a string");
            e = u[e] || e;
            const r = { ...t },
              f = "number" == typeof r.maxLength ? Math.min(o, r.maxLength) : o;
            let m = e.length;
            if (m > f)
              throw new SyntaxError(
                `Input length: ${m}, exceeds maximum allowed length: ${f}`
              );
            const h = { type: "bos", value: "", output: r.prepend || "" },
              g = [h],
              y = r.capture ? "" : "?:",
              b = i.isWindows(t),
              _ = n.globChars(b),
              v = n.extglobChars(_),
              {
                DOT_LITERAL: x,
                PLUS_LITERAL: S,
                SLASH_LITERAL: E,
                ONE_CHAR: w,
                DOTS_SLASH: A,
                NO_DOT: O,
                NO_DOT_SLASH: P,
                NO_DOTS_SLASH: $,
                QMARK: T,
                QMARK_NO_DOT: k,
                STAR: R,
                START_ANCHOR: j,
              } = _,
              I = (e) => `(${y}(?:(?!${j}${e.dot ? A : x}).)*?)`,
              L = r.dot ? "" : O,
              C = r.dot ? T : k;
            let M = !0 === r.bash ? I(r) : R;
            r.capture && (M = `(${M})`),
              "boolean" == typeof r.noext && (r.noextglob = r.noext);
            const B = {
              input: e,
              index: -1,
              start: 0,
              dot: !0 === r.dot,
              consumed: "",
              output: "",
              prefix: "",
              backtrack: !1,
              negated: !1,
              brackets: 0,
              braces: 0,
              parens: 0,
              quotes: 0,
              globstar: !1,
              tokens: g,
            };
            (e = i.removePrefix(e, B)), (m = e.length);
            const N = [],
              F = [],
              D = [];
            let H,
              U = h;
            const G = () => B.index === m - 1,
              V = (B.peek = (t = 1) => e[B.index + t]),
              z = (B.advance = () => e[++B.index] || ""),
              q = () => e.slice(B.index + 1),
              W = (e = "", t = 0) => {
                (B.consumed += e), (B.index += t);
              },
              K = (e) => {
                (B.output += null != e.output ? e.output : e.value), W(e.value);
              },
              Q = () => {
                let e = 1;
                for (; "!" === V() && ("(" !== V(2) || "?" === V(3)); )
                  z(), B.start++, e++;
                return e % 2 != 0 && ((B.negated = !0), B.start++, !0);
              },
              Y = (e) => {
                B[e]++, D.push(e);
              },
              X = (e) => {
                B[e]--, D.pop();
              },
              J = (e) => {
                if ("globstar" === U.type) {
                  const t =
                      B.braces > 0 &&
                      ("comma" === e.type || "brace" === e.type),
                    r =
                      !0 === e.extglob ||
                      (N.length && ("pipe" === e.type || "paren" === e.type));
                  "slash" === e.type ||
                    "paren" === e.type ||
                    t ||
                    r ||
                    ((B.output = B.output.slice(0, -U.output.length)),
                    (U.type = "star"),
                    (U.value = "*"),
                    (U.output = M),
                    (B.output += U.output));
                }
                if (
                  (N.length &&
                    "paren" !== e.type &&
                    (N[N.length - 1].inner += e.value),
                  (e.value || e.output) && K(e),
                  U && "text" === U.type && "text" === e.type)
                )
                  return (
                    (U.value += e.value),
                    void (U.output = (U.output || "") + e.value)
                  );
                (e.prev = U), g.push(e), (U = e);
              },
              Z = (e, t) => {
                const n = { ...v[t], conditions: 1, inner: "" };
                (n.prev = U), (n.parens = B.parens), (n.output = B.output);
                const i = (r.capture ? "(" : "") + n.open;
                Y("parens"),
                  J({ type: e, value: t, output: B.output ? "" : w }),
                  J({ type: "paren", extglob: !0, value: z(), output: i }),
                  N.push(n);
              },
              ee = (e) => {
                let n,
                  i = e.close + (r.capture ? ")" : "");
                if ("negate" === e.type) {
                  let o = M;
                  if (
                    (e.inner &&
                      e.inner.length > 1 &&
                      e.inner.includes("/") &&
                      (o = I(r)),
                    (o !== M || G() || /^\)+$/.test(q())) &&
                      (i = e.close = `)$))${o}`),
                    e.inner.includes("*") &&
                      (n = q()) &&
                      /^\.[^\\/.]+$/.test(n))
                  ) {
                    const r = p(n, { ...t, fastpaths: !1 }).output;
                    i = e.close = `)${r})${o})`;
                  }
                  "bos" === e.prev.type && (B.negatedExtglob = !0);
                }
                J({ type: "paren", extglob: !0, value: H, output: i }),
                  X("parens");
              };
            if (!1 !== r.fastpaths && !/(^[*!]|[/()[\]{}"])/.test(e)) {
              let n = !1,
                o = e.replace(c, (e, t, r, i, o, s) =>
                  "\\" === i
                    ? ((n = !0), e)
                    : "?" === i
                    ? t
                      ? t + i + (o ? T.repeat(o.length) : "")
                      : 0 === s
                      ? C + (o ? T.repeat(o.length) : "")
                      : T.repeat(r.length)
                    : "." === i
                    ? x.repeat(r.length)
                    : "*" === i
                    ? t
                      ? t + i + (o ? M : "")
                      : M
                    : t
                    ? e
                    : `\\${e}`
                );
              return (
                !0 === n &&
                  (o =
                    !0 === r.unescape
                      ? o.replace(/\\/g, "")
                      : o.replace(/\\+/g, (e) =>
                          e.length % 2 == 0 ? "\\\\" : e ? "\\" : ""
                        )),
                o === e && !0 === r.contains
                  ? ((B.output = e), B)
                  : ((B.output = i.wrapOutput(o, B, t)), B)
              );
            }
            for (; !G(); ) {
              if (((H = z()), "\0" === H)) continue;
              if ("\\" === H) {
                const e = V();
                if ("/" === e && !0 !== r.bash) continue;
                if ("." === e || ";" === e) continue;
                if (!e) {
                  (H += "\\"), J({ type: "text", value: H });
                  continue;
                }
                const t = /^\\+/.exec(q());
                let n = 0;
                if (
                  (t &&
                    t[0].length > 2 &&
                    ((n = t[0].length),
                    (B.index += n),
                    n % 2 != 0 && (H += "\\")),
                  !0 === r.unescape ? (H = z()) : (H += z()),
                  0 === B.brackets)
                ) {
                  J({ type: "text", value: H });
                  continue;
                }
              }
              if (
                B.brackets > 0 &&
                ("]" !== H || "[" === U.value || "[^" === U.value)
              ) {
                if (!1 !== r.posix && ":" === H) {
                  const e = U.value.slice(1);
                  if (e.includes("[") && ((U.posix = !0), e.includes(":"))) {
                    const e = U.value.lastIndexOf("["),
                      t = U.value.slice(0, e),
                      r = U.value.slice(e + 2),
                      n = s[r];
                    if (n) {
                      (U.value = t + n),
                        (B.backtrack = !0),
                        z(),
                        h.output || 1 !== g.indexOf(U) || (h.output = w);
                      continue;
                    }
                  }
                }
                (("[" === H && ":" !== V()) || ("-" === H && "]" === V())) &&
                  (H = `\\${H}`),
                  "]" !== H ||
                    ("[" !== U.value && "[^" !== U.value) ||
                    (H = `\\${H}`),
                  !0 === r.posix && "!" === H && "[" === U.value && (H = "^"),
                  (U.value += H),
                  K({ value: H });
                continue;
              }
              if (1 === B.quotes && '"' !== H) {
                (H = i.escapeRegex(H)), (U.value += H), K({ value: H });
                continue;
              }
              if ('"' === H) {
                (B.quotes = 1 === B.quotes ? 0 : 1),
                  !0 === r.keepQuotes && J({ type: "text", value: H });
                continue;
              }
              if ("(" === H) {
                Y("parens"), J({ type: "paren", value: H });
                continue;
              }
              if (")" === H) {
                if (0 === B.parens && !0 === r.strictBrackets)
                  throw new SyntaxError(d("opening", "("));
                const e = N[N.length - 1];
                if (e && B.parens === e.parens + 1) {
                  ee(N.pop());
                  continue;
                }
                J({ type: "paren", value: H, output: B.parens ? ")" : "\\)" }),
                  X("parens");
                continue;
              }
              if ("[" === H) {
                if (!0 !== r.nobracket && q().includes("]")) Y("brackets");
                else {
                  if (!0 !== r.nobracket && !0 === r.strictBrackets)
                    throw new SyntaxError(d("closing", "]"));
                  H = `\\${H}`;
                }
                J({ type: "bracket", value: H });
                continue;
              }
              if ("]" === H) {
                if (
                  !0 === r.nobracket ||
                  (U && "bracket" === U.type && 1 === U.value.length)
                ) {
                  J({ type: "text", value: H, output: `\\${H}` });
                  continue;
                }
                if (0 === B.brackets) {
                  if (!0 === r.strictBrackets)
                    throw new SyntaxError(d("opening", "["));
                  J({ type: "text", value: H, output: `\\${H}` });
                  continue;
                }
                X("brackets");
                const e = U.value.slice(1);
                if (
                  (!0 === U.posix ||
                    "^" !== e[0] ||
                    e.includes("/") ||
                    (H = `/${H}`),
                  (U.value += H),
                  K({ value: H }),
                  !1 === r.literalBrackets || i.hasRegexChars(e))
                )
                  continue;
                const t = i.escapeRegex(U.value);
                if (
                  ((B.output = B.output.slice(0, -U.value.length)),
                  !0 === r.literalBrackets)
                ) {
                  (B.output += t), (U.value = t);
                  continue;
                }
                (U.value = `(${y}${t}|${U.value})`), (B.output += U.value);
                continue;
              }
              if ("{" === H && !0 !== r.nobrace) {
                Y("braces");
                const e = {
                  type: "brace",
                  value: H,
                  output: "(",
                  outputIndex: B.output.length,
                  tokensIndex: B.tokens.length,
                };
                F.push(e), J(e);
                continue;
              }
              if ("}" === H) {
                const e = F[F.length - 1];
                if (!0 === r.nobrace || !e) {
                  J({ type: "text", value: H, output: H });
                  continue;
                }
                let t = ")";
                if (!0 === e.dots) {
                  const e = g.slice(),
                    n = [];
                  for (
                    let t = e.length - 1;
                    t >= 0 && (g.pop(), "brace" !== e[t].type);
                    t--
                  )
                    "dots" !== e[t].type && n.unshift(e[t].value);
                  (t = l(n, r)), (B.backtrack = !0);
                }
                if (!0 !== e.comma && !0 !== e.dots) {
                  const r = B.output.slice(0, e.outputIndex),
                    n = B.tokens.slice(e.tokensIndex);
                  (e.value = e.output = "\\{"), (H = t = "\\}"), (B.output = r);
                  for (const e of n) B.output += e.output || e.value;
                }
                J({ type: "brace", value: H, output: t }), X("braces"), F.pop();
                continue;
              }
              if ("|" === H) {
                N.length > 0 && N[N.length - 1].conditions++,
                  J({ type: "text", value: H });
                continue;
              }
              if ("," === H) {
                let e = H;
                const t = F[F.length - 1];
                t &&
                  "braces" === D[D.length - 1] &&
                  ((t.comma = !0), (e = "|")),
                  J({ type: "comma", value: H, output: e });
                continue;
              }
              if ("/" === H) {
                if ("dot" === U.type && B.index === B.start + 1) {
                  (B.start = B.index + 1),
                    (B.consumed = ""),
                    (B.output = ""),
                    g.pop(),
                    (U = h);
                  continue;
                }
                J({ type: "slash", value: H, output: E });
                continue;
              }
              if ("." === H) {
                if (B.braces > 0 && "dot" === U.type) {
                  "." === U.value && (U.output = x);
                  const e = F[F.length - 1];
                  (U.type = "dots"),
                    (U.output += H),
                    (U.value += H),
                    (e.dots = !0);
                  continue;
                }
                if (
                  B.braces + B.parens === 0 &&
                  "bos" !== U.type &&
                  "slash" !== U.type
                ) {
                  J({ type: "text", value: H, output: x });
                  continue;
                }
                J({ type: "dot", value: H, output: x });
                continue;
              }
              if ("?" === H) {
                if (
                  (!U || "(" !== U.value) &&
                  !0 !== r.noextglob &&
                  "(" === V() &&
                  "?" !== V(2)
                ) {
                  Z("qmark", H);
                  continue;
                }
                if (U && "paren" === U.type) {
                  const e = V();
                  let t = H;
                  if ("<" === e && !i.supportsLookbehinds())
                    throw new Error(
                      "Node.js v10 or higher is required for regex lookbehinds"
                    );
                  (("(" === U.value && !/[!=<:]/.test(e)) ||
                    ("<" === e && !/<([!=]|\w+>)/.test(q()))) &&
                    (t = `\\${H}`),
                    J({ type: "text", value: H, output: t });
                  continue;
                }
                if (!0 !== r.dot && ("slash" === U.type || "bos" === U.type)) {
                  J({ type: "qmark", value: H, output: k });
                  continue;
                }
                J({ type: "qmark", value: H, output: T });
                continue;
              }
              if ("!" === H) {
                if (
                  !0 !== r.noextglob &&
                  "(" === V() &&
                  ("?" !== V(2) || !/[!=<:]/.test(V(3)))
                ) {
                  Z("negate", H);
                  continue;
                }
                if (!0 !== r.nonegate && 0 === B.index) {
                  Q();
                  continue;
                }
              }
              if ("+" === H) {
                if (!0 !== r.noextglob && "(" === V() && "?" !== V(2)) {
                  Z("plus", H);
                  continue;
                }
                if ((U && "(" === U.value) || !1 === r.regex) {
                  J({ type: "plus", value: H, output: S });
                  continue;
                }
                if (
                  (U &&
                    ("bracket" === U.type ||
                      "paren" === U.type ||
                      "brace" === U.type)) ||
                  B.parens > 0
                ) {
                  J({ type: "plus", value: H });
                  continue;
                }
                J({ type: "plus", value: S });
                continue;
              }
              if ("@" === H) {
                if (!0 !== r.noextglob && "(" === V() && "?" !== V(2)) {
                  J({ type: "at", extglob: !0, value: H, output: "" });
                  continue;
                }
                J({ type: "text", value: H });
                continue;
              }
              if ("*" !== H) {
                ("$" !== H && "^" !== H) || (H = `\\${H}`);
                const e = a.exec(q());
                e && ((H += e[0]), (B.index += e[0].length)),
                  J({ type: "text", value: H });
                continue;
              }
              if (U && ("globstar" === U.type || !0 === U.star)) {
                (U.type = "star"),
                  (U.star = !0),
                  (U.value += H),
                  (U.output = M),
                  (B.backtrack = !0),
                  (B.globstar = !0),
                  W(H);
                continue;
              }
              let t = q();
              if (!0 !== r.noextglob && /^\([^?]/.test(t)) {
                Z("star", H);
                continue;
              }
              if ("star" === U.type) {
                if (!0 === r.noglobstar) {
                  W(H);
                  continue;
                }
                const n = U.prev,
                  i = n.prev,
                  o = "slash" === n.type || "bos" === n.type,
                  s = i && ("star" === i.type || "globstar" === i.type);
                if (!0 === r.bash && (!o || (t[0] && "/" !== t[0]))) {
                  J({ type: "star", value: H, output: "" });
                  continue;
                }
                const a =
                    B.braces > 0 && ("comma" === n.type || "brace" === n.type),
                  c = N.length && ("pipe" === n.type || "paren" === n.type);
                if (!o && "paren" !== n.type && !a && !c) {
                  J({ type: "star", value: H, output: "" });
                  continue;
                }
                for (; "/**" === t.slice(0, 3); ) {
                  const r = e[B.index + 4];
                  if (r && "/" !== r) break;
                  (t = t.slice(3)), W("/**", 3);
                }
                if ("bos" === n.type && G()) {
                  (U.type = "globstar"),
                    (U.value += H),
                    (U.output = I(r)),
                    (B.output = U.output),
                    (B.globstar = !0),
                    W(H);
                  continue;
                }
                if ("slash" === n.type && "bos" !== n.prev.type && !s && G()) {
                  (B.output = B.output.slice(0, -(n.output + U.output).length)),
                    (n.output = `(?:${n.output}`),
                    (U.type = "globstar"),
                    (U.output = I(r) + (r.strictSlashes ? ")" : "|$)")),
                    (U.value += H),
                    (B.globstar = !0),
                    (B.output += n.output + U.output),
                    W(H);
                  continue;
                }
                if (
                  "slash" === n.type &&
                  "bos" !== n.prev.type &&
                  "/" === t[0]
                ) {
                  const e = void 0 !== t[1] ? "|$" : "";
                  (B.output = B.output.slice(0, -(n.output + U.output).length)),
                    (n.output = `(?:${n.output}`),
                    (U.type = "globstar"),
                    (U.output = `${I(r)}${E}|${E}${e})`),
                    (U.value += H),
                    (B.output += n.output + U.output),
                    (B.globstar = !0),
                    W(H + z()),
                    J({ type: "slash", value: "/", output: "" });
                  continue;
                }
                if ("bos" === n.type && "/" === t[0]) {
                  (U.type = "globstar"),
                    (U.value += H),
                    (U.output = `(?:^|${E}|${I(r)}${E})`),
                    (B.output = U.output),
                    (B.globstar = !0),
                    W(H + z()),
                    J({ type: "slash", value: "/", output: "" });
                  continue;
                }
                (B.output = B.output.slice(0, -U.output.length)),
                  (U.type = "globstar"),
                  (U.output = I(r)),
                  (U.value += H),
                  (B.output += U.output),
                  (B.globstar = !0),
                  W(H);
                continue;
              }
              const n = { type: "star", value: H, output: M };
              !0 !== r.bash
                ? !U ||
                  ("bracket" !== U.type && "paren" !== U.type) ||
                  !0 !== r.regex
                  ? ((B.index !== B.start &&
                      "slash" !== U.type &&
                      "dot" !== U.type) ||
                      ("dot" === U.type
                        ? ((B.output += P), (U.output += P))
                        : !0 === r.dot
                        ? ((B.output += $), (U.output += $))
                        : ((B.output += L), (U.output += L)),
                      "*" !== V() && ((B.output += w), (U.output += w))),
                    J(n))
                  : ((n.output = H), J(n))
                : ((n.output = ".*?"),
                  ("bos" !== U.type && "slash" !== U.type) ||
                    (n.output = L + n.output),
                  J(n));
            }
            for (; B.brackets > 0; ) {
              if (!0 === r.strictBrackets)
                throw new SyntaxError(d("closing", "]"));
              (B.output = i.escapeLast(B.output, "[")), X("brackets");
            }
            for (; B.parens > 0; ) {
              if (!0 === r.strictBrackets)
                throw new SyntaxError(d("closing", ")"));
              (B.output = i.escapeLast(B.output, "(")), X("parens");
            }
            for (; B.braces > 0; ) {
              if (!0 === r.strictBrackets)
                throw new SyntaxError(d("closing", "}"));
              (B.output = i.escapeLast(B.output, "{")), X("braces");
            }
            if (
              (!0 === r.strictSlashes ||
                ("star" !== U.type && "bracket" !== U.type) ||
                J({ type: "maybe_slash", value: "", output: `${E}?` }),
              !0 === B.backtrack)
            ) {
              B.output = "";
              for (const e of B.tokens)
                (B.output += null != e.output ? e.output : e.value),
                  e.suffix && (B.output += e.suffix);
            }
            return B;
          };
        (p.fastpaths = (e, t) => {
          const r = { ...t },
            s = "number" == typeof r.maxLength ? Math.min(o, r.maxLength) : o,
            a = e.length;
          if (a > s)
            throw new SyntaxError(
              `Input length: ${a}, exceeds maximum allowed length: ${s}`
            );
          e = u[e] || e;
          const c = i.isWindows(t),
            {
              DOT_LITERAL: l,
              SLASH_LITERAL: d,
              ONE_CHAR: p,
              DOTS_SLASH: f,
              NO_DOT: m,
              NO_DOTS: h,
              NO_DOTS_SLASH: g,
              STAR: y,
              START_ANCHOR: b,
            } = n.globChars(c),
            _ = r.dot ? h : m,
            v = r.dot ? g : m,
            x = r.capture ? "" : "?:";
          let S = !0 === r.bash ? ".*?" : y;
          r.capture && (S = `(${S})`);
          const E = (e) =>
              !0 === e.noglobstar ? S : `(${x}(?:(?!${b}${e.dot ? f : l}).)*?)`,
            w = (e) => {
              switch (e) {
                case "*":
                  return `${_}${p}${S}`;
                case ".*":
                  return `${l}${p}${S}`;
                case "*.*":
                  return `${_}${S}${l}${p}${S}`;
                case "*/*":
                  return `${_}${S}${d}${p}${v}${S}`;
                case "**":
                  return _ + E(r);
                case "**/*":
                  return `(?:${_}${E(r)}${d})?${v}${p}${S}`;
                case "**/*.*":
                  return `(?:${_}${E(r)}${d})?${v}${S}${l}${p}${S}`;
                case "**/.*":
                  return `(?:${_}${E(r)}${d})?${l}${p}${S}`;
                default: {
                  const t = /^(.*?)\.(\w+)$/.exec(e);
                  if (!t) return;
                  const r = w(t[1]);
                  if (!r) return;
                  return r + l + t[2];
                }
              }
            },
            A = i.removePrefix(e, { negated: !1, prefix: "" });
          let O = w(A);
          return O && !0 !== r.strictSlashes && (O += `${d}?`), O;
        }),
          (e.exports = p);
      },
      6087: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = r(3921),
          o = r(3376),
          s = r(8702),
          a = r(1006),
          c = (e, t, r = !1) => {
            if (Array.isArray(e)) {
              const n = e.map((e) => c(e, t, r)),
                i = (e) => {
                  for (const t of n) {
                    const r = t(e);
                    if (r) return r;
                  }
                  return !1;
                };
              return i;
            }
            const n =
              (i = e) &&
              "object" == typeof i &&
              !Array.isArray(i) &&
              e.tokens &&
              e.input;
            var i;
            if ("" === e || ("string" != typeof e && !n))
              throw new TypeError("Expected pattern to be a non-empty string");
            const o = t || {},
              a = s.isWindows(t),
              u = n ? c.compileRe(e, t) : c.makeRe(e, t, !1, !0),
              l = u.state;
            delete u.state;
            let d = () => !1;
            if (o.ignore) {
              const e = { ...t, ignore: null, onMatch: null, onResult: null };
              d = c(o.ignore, e, r);
            }
            const p = (r, n = !1) => {
              const {
                  isMatch: i,
                  match: s,
                  output: p,
                } = c.test(r, u, t, { glob: e, posix: a }),
                f = {
                  glob: e,
                  state: l,
                  regex: u,
                  posix: a,
                  input: r,
                  output: p,
                  match: s,
                  isMatch: i,
                };
              return (
                "function" == typeof o.onResult && o.onResult(f),
                !1 === i
                  ? ((f.isMatch = !1), !!n && f)
                  : d(r)
                  ? ("function" == typeof o.onIgnore && o.onIgnore(f),
                    (f.isMatch = !1),
                    !!n && f)
                  : ("function" == typeof o.onMatch && o.onMatch(f), !n || f)
              );
            };
            return r && (p.state = l), p;
          };
        (c.test = (e, t, r, { glob: n, posix: i } = {}) => {
          if ("string" != typeof e)
            throw new TypeError("Expected input to be a string");
          if ("" === e) return { isMatch: !1, output: "" };
          const o = r || {},
            a = o.format || (i ? s.toPosixSlashes : null);
          let u = e === n,
            l = u && a ? a(e) : e;
          return (
            !1 === u && ((l = a ? a(e) : e), (u = l === n)),
            (!1 !== u && !0 !== o.capture) ||
              (u =
                !0 === o.matchBase || !0 === o.basename
                  ? c.matchBase(e, t, r, i)
                  : t.exec(l)),
            { isMatch: Boolean(u), match: u, output: l }
          );
        }),
          (c.matchBase = (e, t, r, i = s.isWindows(r)) =>
            (t instanceof RegExp ? t : c.makeRe(t, r)).test(n.basename(e))),
          (c.isMatch = (e, t, r) => c(t, r)(e)),
          (c.parse = (e, t) =>
            Array.isArray(e)
              ? e.map((e) => c.parse(e, t))
              : o(e, { ...t, fastpaths: !1 })),
          (c.scan = (e, t) => i(e, t)),
          (c.compileRe = (e, t, r = !1, n = !1) => {
            if (!0 === r) return e.output;
            const i = t || {},
              o = i.contains ? "" : "^",
              s = i.contains ? "" : "$";
            let a = `${o}(?:${e.output})${s}`;
            e && !0 === e.negated && (a = `^(?!${a}).*$`);
            const u = c.toRegex(a, t);
            return !0 === n && (u.state = e), u;
          }),
          (c.makeRe = (e, t = {}, r = !1, n = !1) => {
            if (!e || "string" != typeof e)
              throw new TypeError("Expected a non-empty string");
            let i = { negated: !1, fastpaths: !0 };
            return (
              !1 === t.fastpaths ||
                ("." !== e[0] && "*" !== e[0]) ||
                (i.output = o.fastpaths(e, t)),
              i.output || (i = o(e, t)),
              c.compileRe(i, t, r, n)
            );
          }),
          (c.toRegex = (e, t) => {
            try {
              const r = t || {};
              return new RegExp(e, r.flags || (r.nocase ? "i" : ""));
            } catch (e) {
              if (t && !0 === t.debug) throw e;
              return /$^/;
            }
          }),
          (c.constants = a),
          (e.exports = c);
      },
      3921: (e, t, r) => {
        "use strict";
        const n = r(8702),
          {
            CHAR_ASTERISK: i,
            CHAR_AT: o,
            CHAR_BACKWARD_SLASH: s,
            CHAR_COMMA: a,
            CHAR_DOT: c,
            CHAR_EXCLAMATION_MARK: u,
            CHAR_FORWARD_SLASH: l,
            CHAR_LEFT_CURLY_BRACE: d,
            CHAR_LEFT_PARENTHESES: p,
            CHAR_LEFT_SQUARE_BRACKET: f,
            CHAR_PLUS: m,
            CHAR_QUESTION_MARK: h,
            CHAR_RIGHT_CURLY_BRACE: g,
            CHAR_RIGHT_PARENTHESES: y,
            CHAR_RIGHT_SQUARE_BRACKET: b,
          } = r(1006),
          _ = (e) => e === l || e === s,
          v = (e) => {
            !0 !== e.isPrefix && (e.depth = e.isGlobstar ? 1 / 0 : 1);
          };
        e.exports = (e, t) => {
          const r = t || {},
            x = e.length - 1,
            S = !0 === r.parts || !0 === r.scanToEnd,
            E = [],
            w = [],
            A = [];
          let O,
            P,
            $ = e,
            T = -1,
            k = 0,
            R = 0,
            j = !1,
            I = !1,
            L = !1,
            C = !1,
            M = !1,
            B = !1,
            N = !1,
            F = !1,
            D = !1,
            H = !1,
            U = 0,
            G = { value: "", depth: 0, isGlob: !1 };
          const V = () => T >= x,
            z = () => ((O = P), $.charCodeAt(++T));
          for (; T < x; ) {
            let e;
            if (((P = z()), P !== s)) {
              if (!0 === B || P === d) {
                for (U++; !0 !== V() && (P = z()); )
                  if (P !== s)
                    if (P !== d) {
                      if (!0 !== B && P === c && (P = z()) === c) {
                        if (
                          ((j = G.isBrace = !0),
                          (L = G.isGlob = !0),
                          (H = !0),
                          !0 === S)
                        )
                          continue;
                        break;
                      }
                      if (!0 !== B && P === a) {
                        if (
                          ((j = G.isBrace = !0),
                          (L = G.isGlob = !0),
                          (H = !0),
                          !0 === S)
                        )
                          continue;
                        break;
                      }
                      if (P === g && (U--, 0 === U)) {
                        (B = !1), (j = G.isBrace = !0), (H = !0);
                        break;
                      }
                    } else U++;
                  else (N = G.backslashes = !0), z();
                if (!0 === S) continue;
                break;
              }
              if (P !== l) {
                if (
                  !0 !== r.noext &&
                  !0 == (P === m || P === o || P === i || P === h || P === u) &&
                  $.charCodeAt(T + 1) === p
                ) {
                  if (
                    ((L = G.isGlob = !0),
                    (C = G.isExtglob = !0),
                    (H = !0),
                    P === u && T === k && (D = !0),
                    !0 === S)
                  ) {
                    for (; !0 !== V() && (P = z()); )
                      if (P !== s) {
                        if (P === y) {
                          (L = G.isGlob = !0), (H = !0);
                          break;
                        }
                      } else (N = G.backslashes = !0), (P = z());
                    continue;
                  }
                  break;
                }
                if (P === i) {
                  if (
                    (O === i && (M = G.isGlobstar = !0),
                    (L = G.isGlob = !0),
                    (H = !0),
                    !0 === S)
                  )
                    continue;
                  break;
                }
                if (P === h) {
                  if (((L = G.isGlob = !0), (H = !0), !0 === S)) continue;
                  break;
                }
                if (P === f) {
                  for (; !0 !== V() && (e = z()); )
                    if (e !== s) {
                      if (e === b) {
                        (I = G.isBracket = !0), (L = G.isGlob = !0), (H = !0);
                        break;
                      }
                    } else (N = G.backslashes = !0), z();
                  if (!0 === S) continue;
                  break;
                }
                if (!0 === r.nonegate || P !== u || T !== k) {
                  if (!0 !== r.noparen && P === p) {
                    if (((L = G.isGlob = !0), !0 === S)) {
                      for (; !0 !== V() && (P = z()); )
                        if (P !== p) {
                          if (P === y) {
                            H = !0;
                            break;
                          }
                        } else (N = G.backslashes = !0), (P = z());
                      continue;
                    }
                    break;
                  }
                  if (!0 === L) {
                    if (((H = !0), !0 === S)) continue;
                    break;
                  }
                } else (F = G.negated = !0), k++;
              } else {
                if (
                  (E.push(T),
                  w.push(G),
                  (G = { value: "", depth: 0, isGlob: !1 }),
                  !0 === H)
                )
                  continue;
                if (O === c && T === k + 1) {
                  k += 2;
                  continue;
                }
                R = T + 1;
              }
            } else (N = G.backslashes = !0), (P = z()), P === d && (B = !0);
          }
          !0 === r.noext && ((C = !1), (L = !1));
          let q = $,
            W = "",
            K = "";
          k > 0 && ((W = $.slice(0, k)), ($ = $.slice(k)), (R -= k)),
            q && !0 === L && R > 0
              ? ((q = $.slice(0, R)), (K = $.slice(R)))
              : !0 === L
              ? ((q = ""), (K = $))
              : (q = $),
            q &&
              "" !== q &&
              "/" !== q &&
              q !== $ &&
              _(q.charCodeAt(q.length - 1)) &&
              (q = q.slice(0, -1)),
            !0 === r.unescape &&
              (K && (K = n.removeBackslashes(K)),
              q && !0 === N && (q = n.removeBackslashes(q)));
          const Q = {
            prefix: W,
            input: e,
            start: k,
            base: q,
            glob: K,
            isBrace: j,
            isBracket: I,
            isGlob: L,
            isExtglob: C,
            isGlobstar: M,
            negated: F,
            negatedExtglob: D,
          };
          if (
            (!0 === r.tokens &&
              ((Q.maxDepth = 0), _(P) || w.push(G), (Q.tokens = w)),
            !0 === r.parts || !0 === r.tokens)
          ) {
            let t;
            for (let n = 0; n < E.length; n++) {
              const i = t ? t + 1 : k,
                o = E[n],
                s = e.slice(i, o);
              r.tokens &&
                (0 === n && 0 !== k
                  ? ((w[n].isPrefix = !0), (w[n].value = W))
                  : (w[n].value = s),
                v(w[n]),
                (Q.maxDepth += w[n].depth)),
                (0 === n && "" === s) || A.push(s),
                (t = o);
            }
            if (t && t + 1 < e.length) {
              const n = e.slice(t + 1);
              A.push(n),
                r.tokens &&
                  ((w[w.length - 1].value = n),
                  v(w[w.length - 1]),
                  (Q.maxDepth += w[w.length - 1].depth));
            }
            (Q.slashes = E), (Q.parts = A);
          }
          return Q;
        };
      },
      8702: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = "win32" === process.platform,
          {
            REGEX_BACKSLASH: o,
            REGEX_REMOVE_BACKSLASH: s,
            REGEX_SPECIAL_CHARS: a,
            REGEX_SPECIAL_CHARS_GLOBAL: c,
          } = r(1006);
        (t.isObject = (e) =>
          null !== e && "object" == typeof e && !Array.isArray(e)),
          (t.hasRegexChars = (e) => a.test(e)),
          (t.isRegexChar = (e) => 1 === e.length && t.hasRegexChars(e)),
          (t.escapeRegex = (e) => e.replace(c, "\\$1")),
          (t.toPosixSlashes = (e) => e.replace(o, "/")),
          (t.removeBackslashes = (e) =>
            e.replace(s, (e) => ("\\" === e ? "" : e))),
          (t.supportsLookbehinds = () => {
            const e = process.version.slice(1).split(".").map(Number);
            return (3 === e.length && e[0] >= 9) || (8 === e[0] && e[1] >= 10);
          }),
          (t.isWindows = (e) =>
            e && "boolean" == typeof e.windows
              ? e.windows
              : !0 === i || "\\" === n.sep),
          (t.escapeLast = (e, r, n) => {
            const i = e.lastIndexOf(r, n);
            return -1 === i
              ? e
              : "\\" === e[i - 1]
              ? t.escapeLast(e, r, i - 1)
              : `${e.slice(0, i)}\\${e.slice(i)}`;
          }),
          (t.removePrefix = (e, t = {}) => {
            let r = e;
            return (
              r.startsWith("./") && ((r = r.slice(2)), (t.prefix = "./")), r
            );
          }),
          (t.wrapOutput = (e, t = {}, r = {}) => {
            let n = `${r.contains ? "" : "^"}(?:${e})${r.contains ? "" : "$"}`;
            return !0 === t.negated && (n = `(?:^(?!${n}).*$)`), n;
          });
      },
      2352: (e) => {
        "use strict";
        const t = (e, t) =>
          function (...r) {
            return new (0, t.promiseModule)((n, i) => {
              t.multiArgs
                ? r.push((...e) => {
                    t.errorFirst ? (e[0] ? i(e) : (e.shift(), n(e))) : n(e);
                  })
                : t.errorFirst
                ? r.push((e, t) => {
                    e ? i(e) : n(t);
                  })
                : r.push(n),
                e.apply(this, r);
            });
          };
        e.exports = (e, r) => {
          r = Object.assign(
            {
              exclude: [/.+(Sync|Stream)$/],
              errorFirst: !0,
              promiseModule: Promise,
            },
            r
          );
          const n = typeof e;
          if (null === e || ("object" !== n && "function" !== n))
            throw new TypeError(
              `Expected \`input\` to be a \`Function\` or \`Object\`, got \`${
                null === e ? "null" : n
              }\``
            );
          const i = (e) => {
            const t = (t) => ("string" == typeof t ? e === t : t.test(e));
            return r.include ? r.include.some(t) : !r.exclude.some(t);
          };
          let o;
          o =
            "function" === n
              ? function (...n) {
                  return r.excludeMain ? e(...n) : t(e, r).apply(this, n);
                }
              : Object.create(Object.getPrototypeOf(e));
          for (const n in e) {
            const s = e[n];
            o[n] = "function" == typeof s && i(n) ? t(s, r) : s;
          }
          return o;
        };
      },
      7108: (e, t, r) => {
        "use strict";
        e.exports = r(1098).path();
      },
      1098: (e, t, r) => {
        "use strict";
        const n = r(1017),
          i = r(561),
          o = `https://raw.githubusercontent.com/imagemin/pngquant-bin/v${
            r(9034).version
          }/vendor/`;
        e.exports = new i()
          .src(`${o}macos/pngquant`, "darwin")
          .src(`${o}linux/x86/pngquant`, "linux", "x86")
          .src(`${o}linux/x64/pngquant`, "linux", "x64")
          .src(`${o}freebsd/x64/pngquant`, "freebsd", "x64")
          .src(`${o}win/pngquant.exe`, "win32")
          .dest(n.resolve(__dirname, "../vendor"))
          .use("win32" === process.platform ? "pngquant.exe" : "pngquant");
      },
      4286: (e, t, r) => {
        var n = r(447),
          i = r(2840),
          o = r(7147),
          s = function () {},
          a = /^v?\.0/.test(process.version),
          c = function (e) {
            return "function" == typeof e;
          },
          u = function (e, t, r, u) {
            u = n(u);
            var l = !1;
            e.on("close", function () {
              l = !0;
            }),
              i(e, { readable: t, writable: r }, function (e) {
                if (e) return u(e);
                (l = !0), u();
              });
            var d = !1;
            return function (t) {
              if (!l && !d)
                return (
                  (d = !0),
                  (function (e) {
                    return (
                      !!a &&
                      !!o &&
                      (e instanceof (o.ReadStream || s) ||
                        e instanceof (o.WriteStream || s)) &&
                      c(e.close)
                    );
                  })(e)
                    ? e.close(s)
                    : (function (e) {
                        return e.setHeader && c(e.abort);
                      })(e)
                    ? e.abort()
                    : c(e.destroy)
                    ? e.destroy()
                    : void u(t || new Error("stream was destroyed"))
                );
            };
          },
          l = function (e) {
            e();
          },
          d = function (e, t) {
            return e.pipe(t);
          };
        e.exports = function () {
          var e,
            t = Array.prototype.slice.call(arguments),
            r = (c(t[t.length - 1] || s) && t.pop()) || s;
          if ((Array.isArray(t[0]) && (t = t[0]), t.length < 2))
            throw new Error("pump requires two streams per minimum");
          var n = t.map(function (i, o) {
            var s = o < t.length - 1;
            return u(i, s, o > 0, function (t) {
              e || (e = t), t && n.forEach(l), s || (n.forEach(l), r(e));
            });
          });
          return t.reduce(d);
        };
      },
      4375: (e) => {
        let t;
        e.exports =
          "function" == typeof queueMicrotask
            ? queueMicrotask.bind(
                "undefined" != typeof window ? window : global
              )
            : (e) =>
                (t || (t = Promise.resolve())).then(e).catch((e) =>
                  setTimeout(() => {
                    throw e;
                  }, 0)
                );
      },
      8245: (e, t, r) => {
        "use strict";
        var n = r(1017);
        e.exports = function (e, t) {
          if ("string" != typeof e) return e;
          if (0 === e.length) return e;
          var r,
            i = n.basename(e, n.extname(e)) + t,
            o = n.join(n.dirname(e), i);
          return (r = e.slice(0, 2)) === "." + n.sep || "./" === r
            ? "." + n.sep + o
            : o;
        };
      },
      3650: (e) => {
        "use strict";
        e.exports = function (e) {
          var t = new e(),
            r = t;
          return {
            get: function () {
              var n = t;
              return (
                n.next ? (t = n.next) : ((t = new e()), (r = t)),
                (n.next = null),
                n
              );
            },
            release: function (e) {
              (r.next = e), (r = e);
            },
          };
        };
      },
      4595: (e, t, r) => {
        e.exports = function (e, t) {
          let r,
            i,
            o,
            s = !0;
          function a(e) {
            function i() {
              t && t(e, r), (t = null);
            }
            s ? n(i) : i();
          }
          function c(e, t, n) {
            (r[e] = n), (0 == --i || t) && a(t);
          }
          Array.isArray(e)
            ? ((r = []), (i = e.length))
            : ((o = Object.keys(e)), (r = {}), (i = o.length)),
            i
              ? o
                ? o.forEach(function (t) {
                    e[t](function (e, r) {
                      c(t, e, r);
                    });
                  })
                : e.forEach(function (e, t) {
                    e(function (e, r) {
                      c(t, e, r);
                    });
                  })
              : a(null),
            (s = !1);
        };
        const n = r(4375);
      },
      2063: (e, t, r) => {
        "use strict";
        const n = r(9395);
        e.exports = (e = "") => {
          const t = e.match(n);
          if (!t) return null;
          const [r, i] = t[0].replace(/#! ?/, "").split(" "),
            o = r.split("/").pop();
          return "env" === o ? i : i ? `${o} ${i}` : o;
        };
      },
      9395: (e) => {
        "use strict";
        e.exports = /^#!(.*)/;
      },
      7908: (e, t, r) => {
        var n = global.process;
        const i = function (e) {
          return (
            e &&
            "object" == typeof e &&
            "function" == typeof e.removeListener &&
            "function" == typeof e.emit &&
            "function" == typeof e.reallyExit &&
            "function" == typeof e.listeners &&
            "function" == typeof e.kill &&
            "number" == typeof e.pid &&
            "function" == typeof e.on
          );
        };
        if (i(n)) {
          var o,
            s = r(9491),
            a = r(5397),
            c = /^win/i.test(n.platform),
            u = r(2361);
          "function" != typeof u && (u = u.EventEmitter),
            n.__signal_exit_emitter__
              ? (o = n.__signal_exit_emitter__)
              : (((o = n.__signal_exit_emitter__ = new u()).count = 0),
                (o.emitted = {})),
            o.infinite || (o.setMaxListeners(1 / 0), (o.infinite = !0)),
            (e.exports = function (e, t) {
              if (!i(global.process)) return function () {};
              s.equal(
                typeof e,
                "function",
                "a callback must be provided for exit handler"
              ),
                !1 === f && m();
              var r = "exit";
              return (
                t && t.alwaysLast && (r = "afterexit"),
                o.on(r, e),
                function () {
                  o.removeListener(r, e),
                    0 === o.listeners("exit").length &&
                      0 === o.listeners("afterexit").length &&
                      l();
                }
              );
            });
          var l = function () {
            f &&
              i(global.process) &&
              ((f = !1),
              a.forEach(function (e) {
                try {
                  n.removeListener(e, p[e]);
                } catch (e) {}
              }),
              (n.emit = y),
              (n.reallyExit = h),
              (o.count -= 1));
          };
          e.exports.unload = l;
          var d = function (e, t, r) {
              o.emitted[e] || ((o.emitted[e] = !0), o.emit(e, t, r));
            },
            p = {};
          a.forEach(function (e) {
            p[e] = function () {
              i(global.process) &&
                n.listeners(e).length === o.count &&
                (l(),
                d("exit", null, e),
                d("afterexit", null, e),
                c && "SIGHUP" === e && (e = "SIGINT"),
                n.kill(n.pid, e));
            };
          }),
            (e.exports.signals = function () {
              return a;
            });
          var f = !1,
            m = function () {
              !f &&
                i(global.process) &&
                ((f = !0),
                (o.count += 1),
                (a = a.filter(function (e) {
                  try {
                    return n.on(e, p[e]), !0;
                  } catch (e) {
                    return !1;
                  }
                })),
                (n.emit = b),
                (n.reallyExit = g));
            };
          e.exports.load = m;
          var h = n.reallyExit,
            g = function (e) {
              i(global.process) &&
                ((n.exitCode = e || 0),
                d("exit", n.exitCode, null),
                d("afterexit", n.exitCode, null),
                h.call(n, n.exitCode));
            },
            y = n.emit,
            b = function (e, t) {
              if ("exit" === e && i(global.process)) {
                void 0 !== t && (n.exitCode = t);
                var r = y.apply(this, arguments);
                return (
                  d("exit", n.exitCode, null),
                  d("afterexit", n.exitCode, null),
                  r
                );
              }
              return y.apply(this, arguments);
            };
        } else
          e.exports = function () {
            return function () {};
          };
      },
      5397: (e) => {
        (e.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"]),
          "win32" !== process.platform &&
            e.exports.push(
              "SIGVTALRM",
              "SIGXCPU",
              "SIGXFSZ",
              "SIGUSR2",
              "SIGTRAP",
              "SIGSYS",
              "SIGQUIT",
              "SIGIOT"
            ),
          "linux" === process.platform &&
            e.exports.push(
              "SIGIO",
              "SIGPOLL",
              "SIGPWR",
              "SIGSTKFLT",
              "SIGUNUSED"
            );
      },
      3859: (e) => {
        "use strict";
        e.exports = (e) => {
          const t = /^\\\\\?\\/.test(e),
            r = /[^\u0000-\u0080]+/.test(e);
          return t || r ? e : e.replace(/\\/g, "/");
        };
      },
      842: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AbstractTokenizer = void 0);
        const n = r(5167);
        t.AbstractTokenizer = class {
          constructor(e) {
            (this.position = 0),
              (this.numBuffer = new Uint8Array(8)),
              (this.fileInfo = e || {});
          }
          async readToken(e, t = this.position) {
            const r = Buffer.alloc(e.len);
            if ((await this.readBuffer(r, { position: t })) < e.len)
              throw new n.EndOfStreamError();
            return e.get(r, 0);
          }
          async peekToken(e, t = this.position) {
            const r = Buffer.alloc(e.len);
            if ((await this.peekBuffer(r, { position: t })) < e.len)
              throw new n.EndOfStreamError();
            return e.get(r, 0);
          }
          async readNumber(e) {
            if (
              (await this.readBuffer(this.numBuffer, { length: e.len })) < e.len
            )
              throw new n.EndOfStreamError();
            return e.get(this.numBuffer, 0);
          }
          async peekNumber(e) {
            if (
              (await this.peekBuffer(this.numBuffer, { length: e.len })) < e.len
            )
              throw new n.EndOfStreamError();
            return e.get(this.numBuffer, 0);
          }
          async ignore(e) {
            if (void 0 !== this.fileInfo.size) {
              const t = this.fileInfo.size - this.position;
              if (e > t) return (this.position += t), t;
            }
            return (this.position += e), e;
          }
          async close() {}
          normalizeOptions(e, t) {
            if (t && void 0 !== t.position && t.position < this.position)
              throw new Error(
                "`options.position` must be equal or greater than `tokenizer.position`"
              );
            return t
              ? {
                  mayBeLess: !0 === t.mayBeLess,
                  offset: t.offset ? t.offset : 0,
                  length: t.length
                    ? t.length
                    : e.length - (t.offset ? t.offset : 0),
                  position: t.position ? t.position : this.position,
                }
              : {
                  mayBeLess: !1,
                  offset: 0,
                  length: e.length,
                  position: this.position,
                };
          }
        };
      },
      778: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BufferTokenizer = void 0);
        const n = r(5167),
          i = r(842);
        class o extends i.AbstractTokenizer {
          constructor(e, t) {
            super(t),
              (this.uint8Array = e),
              (this.fileInfo.size = this.fileInfo.size
                ? this.fileInfo.size
                : e.length);
          }
          async readBuffer(e, t) {
            if (t && t.position) {
              if (t.position < this.position)
                throw new Error(
                  "`options.position` must be equal or greater than `tokenizer.position`"
                );
              this.position = t.position;
            }
            const r = await this.peekBuffer(e, t);
            return (this.position += r), r;
          }
          async peekBuffer(e, t) {
            const r = this.normalizeOptions(e, t),
              i = Math.min(this.uint8Array.length - r.position, r.length);
            if (!r.mayBeLess && i < r.length) throw new n.EndOfStreamError();
            return (
              e.set(
                this.uint8Array.subarray(r.position, r.position + i),
                r.offset
              ),
              i
            );
          }
          async close() {}
        }
        t.BufferTokenizer = o;
      },
      7859: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.fromFile = t.FileTokenizer = void 0);
        const n = r(842),
          i = r(5167),
          o = r(7209);
        class s extends n.AbstractTokenizer {
          constructor(e, t) {
            super(t), (this.fd = e);
          }
          async readBuffer(e, t) {
            const r = this.normalizeOptions(e, t);
            this.position = r.position;
            const n = await o.read(this.fd, e, r.offset, r.length, r.position);
            if (
              ((this.position += n.bytesRead),
              n.bytesRead < r.length && (!t || !t.mayBeLess))
            )
              throw new i.EndOfStreamError();
            return n.bytesRead;
          }
          async peekBuffer(e, t) {
            const r = this.normalizeOptions(e, t),
              n = await o.read(this.fd, e, r.offset, r.length, r.position);
            if (!r.mayBeLess && n.bytesRead < r.length)
              throw new i.EndOfStreamError();
            return n.bytesRead;
          }
          async close() {
            return o.close(this.fd);
          }
        }
        (t.FileTokenizer = s),
          (t.fromFile = async function (e) {
            const t = await o.stat(e);
            if (!t.isFile) throw new Error(`File not a file: ${e}`);
            const r = await o.open(e, "r");
            return new s(r, { path: e, size: t.size });
          });
      },
      7209: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.readFile =
            t.writeFileSync =
            t.writeFile =
            t.read =
            t.open =
            t.close =
            t.stat =
            t.createReadStream =
            t.pathExists =
              void 0);
        const n = r(7147);
        (t.pathExists = n.existsSync),
          (t.createReadStream = n.createReadStream),
          (t.stat = async function (e) {
            return new Promise((t, r) => {
              n.stat(e, (e, n) => {
                e ? r(e) : t(n);
              });
            });
          }),
          (t.close = async function (e) {
            return new Promise((t, r) => {
              n.close(e, (e) => {
                e ? r(e) : t();
              });
            });
          }),
          (t.open = async function (e, t) {
            return new Promise((r, i) => {
              n.open(e, t, (e, t) => {
                e ? i(e) : r(t);
              });
            });
          }),
          (t.read = async function (e, t, r, i, o) {
            return new Promise((s, a) => {
              n.read(e, t, r, i, o, (e, t, r) => {
                e ? a(e) : s({ bytesRead: t, buffer: r });
              });
            });
          }),
          (t.writeFile = async function (e, t) {
            return new Promise((r, i) => {
              n.writeFile(e, t, (e) => {
                e ? i(e) : r();
              });
            });
          }),
          (t.writeFileSync = function (e, t) {
            n.writeFileSync(e, t);
          }),
          (t.readFile = async function (e) {
            return new Promise((t, r) => {
              n.readFile(e, (e, n) => {
                e ? r(e) : t(n);
              });
            });
          });
      },
      599: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ReadStreamTokenizer = void 0);
        const n = r(842),
          i = r(5167);
        class o extends n.AbstractTokenizer {
          constructor(e, t) {
            super(t), (this.streamReader = new i.StreamReader(e));
          }
          async getFileInfo() {
            return this.fileInfo;
          }
          async readBuffer(e, t) {
            const r = this.normalizeOptions(e, t),
              n = r.position - this.position;
            if (n > 0) return await this.ignore(n), this.readBuffer(e, t);
            if (n < 0)
              throw new Error(
                "`options.position` must be equal or greater than `tokenizer.position`"
              );
            if (0 === r.length) return 0;
            const o = await this.streamReader.read(e, r.offset, r.length);
            if (((this.position += o), (!t || !t.mayBeLess) && o < r.length))
              throw new i.EndOfStreamError();
            return o;
          }
          async peekBuffer(e, t) {
            const r = this.normalizeOptions(e, t);
            let n = 0;
            if (r.position) {
              const t = r.position - this.position;
              if (t > 0) {
                const i = new Uint8Array(r.length + t);
                return (
                  (n = await this.peekBuffer(i, { mayBeLess: r.mayBeLess })),
                  e.set(i.subarray(t), r.offset),
                  n - t
                );
              }
              if (t < 0)
                throw new Error(
                  "Cannot peek from a negative offset in a stream"
                );
            }
            if (r.length > 0) {
              try {
                n = await this.streamReader.peek(e, r.offset, r.length);
              } catch (e) {
                if (t && t.mayBeLess && e instanceof i.EndOfStreamError)
                  return 0;
                throw e;
              }
              if (!r.mayBeLess && n < r.length) throw new i.EndOfStreamError();
            }
            return n;
          }
          async ignore(e) {
            const t = Math.min(256e3, e),
              r = new Uint8Array(t);
            let n = 0;
            for (; n < e; ) {
              const i = e - n,
                o = await this.readBuffer(r, { length: Math.min(t, i) });
              if (o < 0) return o;
              n += o;
            }
            return n;
          }
        }
        t.ReadStreamTokenizer = o;
      },
      5849: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.fromBuffer = t.fromStream = t.EndOfStreamError = void 0);
        const n = r(599),
          i = r(778);
        var o = r(5167);
        Object.defineProperty(t, "EndOfStreamError", {
          enumerable: !0,
          get: function () {
            return o.EndOfStreamError;
          },
        }),
          (t.fromStream = function (e, t) {
            return (t = t || {}), new n.ReadStreamTokenizer(e, t);
          }),
          (t.fromBuffer = function (e, t) {
            return new i.BufferTokenizer(e, t);
          });
      },
      6597: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.fromStream =
            t.fromBuffer =
            t.EndOfStreamError =
            t.fromFile =
              void 0);
        const n = r(7209),
          i = r(5849);
        var o = r(7859);
        Object.defineProperty(t, "fromFile", {
          enumerable: !0,
          get: function () {
            return o.fromFile;
          },
        });
        var s = r(5849);
        Object.defineProperty(t, "EndOfStreamError", {
          enumerable: !0,
          get: function () {
            return s.EndOfStreamError;
          },
        }),
          Object.defineProperty(t, "fromBuffer", {
            enumerable: !0,
            get: function () {
              return s.fromBuffer;
            },
          }),
          (t.fromStream = async function (e, t) {
            if (((t = t || {}), e.path)) {
              const r = await n.stat(e.path);
              (t.path = e.path), (t.size = r.size);
            }
            return i.fromStream(e, t);
          });
      },
      5702: (e, t, r) => {
        "use strict";
        const n = r(9924),
          i = (e, t, r) => {
            if (!1 === n(e))
              throw new TypeError(
                "toRegexRange: expected the first argument to be a number"
              );
            if (void 0 === t || e === t) return String(e);
            if (!1 === n(t))
              throw new TypeError(
                "toRegexRange: expected the second argument to be a number."
              );
            let o = { relaxZeros: !0, ...r };
            "boolean" == typeof o.strictZeros &&
              (o.relaxZeros = !1 === o.strictZeros);
            let c =
              e +
              ":" +
              t +
              "=" +
              String(o.relaxZeros) +
              String(o.shorthand) +
              String(o.capture) +
              String(o.wrap);
            if (i.cache.hasOwnProperty(c)) return i.cache[c].result;
            let u = Math.min(e, t),
              l = Math.max(e, t);
            if (1 === Math.abs(u - l)) {
              let r = e + "|" + t;
              return o.capture ? `(${r})` : !1 === o.wrap ? r : `(?:${r})`;
            }
            let d = f(e) || f(t),
              p = { min: e, max: t, a: u, b: l },
              m = [],
              h = [];
            return (
              d && ((p.isPadded = d), (p.maxLen = String(p.max).length)),
              u < 0 &&
                ((h = s(l < 0 ? Math.abs(l) : 1, Math.abs(u), p, o)),
                (u = p.a = 0)),
              l >= 0 && (m = s(u, l, p, o)),
              (p.negatives = h),
              (p.positives = m),
              (p.result = (function (e, t, r) {
                let n = a(e, t, "-", !1) || [],
                  i = a(t, e, "", !1) || [],
                  o = a(e, t, "-?", !0) || [];
                return n.concat(o).concat(i).join("|");
              })(h, m)),
              !0 === o.capture
                ? (p.result = `(${p.result})`)
                : !1 !== o.wrap &&
                  m.length + h.length > 1 &&
                  (p.result = `(?:${p.result})`),
              (i.cache[c] = p),
              p.result
            );
          };
        function o(e, t, r) {
          if (e === t) return { pattern: e, count: [], digits: 0 };
          let n = (function (e, t) {
              let r = [];
              for (let n = 0; n < e.length; n++) r.push([e[n], t[n]]);
              return r;
            })(e, t),
            i = n.length,
            o = "",
            s = 0;
          for (let e = 0; e < i; e++) {
            let [t, r] = n[e];
            t === r
              ? (o += t)
              : "0" !== t || "9" !== r
              ? (o += `[${(a = t)}${(c = r) - a == 1 ? "" : "-"}${c}]`)
              : s++;
          }
          var a, c;
          return (
            s && (o += !0 === r.shorthand ? "\\d" : "[0-9]"),
            { pattern: o, count: [s], digits: i }
          );
        }
        function s(e, t, r, n) {
          let i,
            s = (function (e, t) {
              let r = 1,
                n = 1,
                i = l(e, r),
                o = new Set([t]);
              for (; e <= i && i <= t; ) o.add(i), (r += 1), (i = l(e, r));
              for (i = d(t + 1, n) - 1; e < i && i <= t; )
                o.add(i), (n += 1), (i = d(t + 1, n) - 1);
              return (o = [...o]), o.sort(c), o;
            })(e, t),
            a = [],
            u = e;
          for (let e = 0; e < s.length; e++) {
            let t = s[e],
              c = o(String(u), String(t), n),
              l = "";
            r.isPadded || !i || i.pattern !== c.pattern
              ? (r.isPadded && (l = m(t, r, n)),
                (c.string = l + c.pattern + p(c.count)),
                a.push(c),
                (u = t + 1),
                (i = c))
              : (i.count.length > 1 && i.count.pop(),
                i.count.push(c.count[0]),
                (i.string = i.pattern + p(i.count)),
                (u = t + 1));
          }
          return a;
        }
        function a(e, t, r, n, i) {
          let o = [];
          for (let i of e) {
            let { string: e } = i;
            n || u(t, "string", e) || o.push(r + e),
              n && u(t, "string", e) && o.push(r + e);
          }
          return o;
        }
        function c(e, t) {
          return e > t ? 1 : t > e ? -1 : 0;
        }
        function u(e, t, r) {
          return e.some((e) => e[t] === r);
        }
        function l(e, t) {
          return Number(String(e).slice(0, -t) + "9".repeat(t));
        }
        function d(e, t) {
          return e - (e % Math.pow(10, t));
        }
        function p(e) {
          let [t = 0, r = ""] = e;
          return r || t > 1 ? `{${t + (r ? "," + r : "")}}` : "";
        }
        function f(e) {
          return /^-?(0+)\d/.test(e);
        }
        function m(e, t, r) {
          if (!t.isPadded) return e;
          let n = Math.abs(t.maxLen - String(e).length),
            i = !1 !== r.relaxZeros;
          switch (n) {
            case 0:
              return "";
            case 1:
              return i ? "0?" : "0";
            case 2:
              return i ? "0{0,2}" : "00";
            default:
              return i ? `0{0,${n}}` : `0{${n}}`;
          }
        }
        (i.cache = {}), (i.clearCache = () => (i.cache = {})), (e.exports = i);
      },
      3416: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AnsiStringType =
            t.StringType =
            t.BufferType =
            t.Uint8ArrayType =
            t.IgnoreType =
            t.Float80_LE =
            t.Float80_BE =
            t.Float64_LE =
            t.Float64_BE =
            t.Float32_LE =
            t.Float32_BE =
            t.Float16_LE =
            t.Float16_BE =
            t.INT64_BE =
            t.UINT64_BE =
            t.INT64_LE =
            t.UINT64_LE =
            t.INT32_LE =
            t.INT32_BE =
            t.INT24_BE =
            t.INT24_LE =
            t.INT16_LE =
            t.INT16_BE =
            t.INT8 =
            t.UINT32_BE =
            t.UINT32_LE =
            t.UINT24_BE =
            t.UINT24_LE =
            t.UINT16_BE =
            t.UINT16_LE =
            t.UINT8 =
              void 0);
        const n = r(645);
        function i(e) {
          return new DataView(e.buffer, e.byteOffset);
        }
        (t.UINT8 = {
          len: 1,
          get: (e, t) => i(e).getUint8(t),
          put: (e, t, r) => (i(e).setUint8(t, r), t + 1),
        }),
          (t.UINT16_LE = {
            len: 2,
            get: (e, t) => i(e).getUint16(t, !0),
            put: (e, t, r) => (i(e).setUint16(t, r, !0), t + 2),
          }),
          (t.UINT16_BE = {
            len: 2,
            get: (e, t) => i(e).getUint16(t),
            put: (e, t, r) => (i(e).setUint16(t, r), t + 2),
          }),
          (t.UINT24_LE = {
            len: 3,
            get(e, t) {
              const r = i(e);
              return r.getUint8(t) + (r.getUint16(t + 1, !0) << 8);
            },
            put(e, t, r) {
              const n = i(e);
              return (
                n.setUint8(t, 255 & r), n.setUint16(t + 1, r >> 8, !0), t + 3
              );
            },
          }),
          (t.UINT24_BE = {
            len: 3,
            get(e, t) {
              const r = i(e);
              return (r.getUint16(t) << 8) + r.getUint8(t + 2);
            },
            put(e, t, r) {
              const n = i(e);
              return n.setUint16(t, r >> 8), n.setUint8(t + 2, 255 & r), t + 3;
            },
          }),
          (t.UINT32_LE = {
            len: 4,
            get: (e, t) => i(e).getUint32(t, !0),
            put: (e, t, r) => (i(e).setUint32(t, r, !0), t + 4),
          }),
          (t.UINT32_BE = {
            len: 4,
            get: (e, t) => i(e).getUint32(t),
            put: (e, t, r) => (i(e).setUint32(t, r), t + 4),
          }),
          (t.INT8 = {
            len: 1,
            get: (e, t) => i(e).getInt8(t),
            put: (e, t, r) => (i(e).setInt8(t, r), t + 2),
          }),
          (t.INT16_BE = {
            len: 2,
            get: (e, t) => i(e).getInt16(t),
            put: (e, t, r) => (i(e).setInt16(t, r), t + 2),
          }),
          (t.INT16_LE = {
            len: 2,
            get: (e, t) => i(e).getInt16(t, !0),
            put: (e, t, r) => (i(e).setInt16(t, r, !0), t + 2),
          }),
          (t.INT24_LE = {
            len: 3,
            get(e, r) {
              const n = t.UINT24_LE.get(e, r);
              return n > 8388607 ? n - 16777216 : n;
            },
            put(e, t, r) {
              const n = i(e);
              return (
                n.setUint8(t, 255 & r), n.setUint16(t + 1, r >> 8, !0), t + 3
              );
            },
          }),
          (t.INT24_BE = {
            len: 3,
            get(e, r) {
              const n = t.UINT24_BE.get(e, r);
              return n > 8388607 ? n - 16777216 : n;
            },
            put(e, t, r) {
              const n = i(e);
              return n.setUint16(t, r >> 8), n.setUint8(t + 2, 255 & r), t + 3;
            },
          }),
          (t.INT32_BE = {
            len: 4,
            get: (e, t) => i(e).getInt32(t),
            put: (e, t, r) => (i(e).setInt32(t, r), t + 4),
          }),
          (t.INT32_LE = {
            len: 4,
            get: (e, t) => i(e).getInt32(t, !0),
            put: (e, t, r) => (i(e).setInt32(t, r, !0), t + 4),
          }),
          (t.UINT64_LE = {
            len: 8,
            get: (e, t) => i(e).getBigUint64(t, !0),
            put: (e, t, r) => (i(e).setBigUint64(t, r, !0), t + 8),
          }),
          (t.INT64_LE = {
            len: 8,
            get: (e, t) => i(e).getBigInt64(t, !0),
            put: (e, t, r) => (i(e).setBigInt64(t, r, !0), t + 8),
          }),
          (t.UINT64_BE = {
            len: 8,
            get: (e, t) => i(e).getBigUint64(t),
            put: (e, t, r) => (i(e).setBigUint64(t, r), t + 8),
          }),
          (t.INT64_BE = {
            len: 8,
            get: (e, t) => i(e).getBigInt64(t),
            put: (e, t, r) => (i(e).setBigInt64(t, r), t + 8),
          }),
          (t.Float16_BE = {
            len: 2,
            get(e, t) {
              return n.read(e, t, !1, 10, this.len);
            },
            put(e, t, r) {
              return n.write(e, r, t, !1, 10, this.len), t + this.len;
            },
          }),
          (t.Float16_LE = {
            len: 2,
            get(e, t) {
              return n.read(e, t, !0, 10, this.len);
            },
            put(e, t, r) {
              return n.write(e, r, t, !0, 10, this.len), t + this.len;
            },
          }),
          (t.Float32_BE = {
            len: 4,
            get: (e, t) => i(e).getFloat32(t),
            put: (e, t, r) => (i(e).setFloat32(t, r), t + 4),
          }),
          (t.Float32_LE = {
            len: 4,
            get: (e, t) => i(e).getFloat32(t, !0),
            put: (e, t, r) => (i(e).setFloat32(t, r, !0), t + 4),
          }),
          (t.Float64_BE = {
            len: 8,
            get: (e, t) => i(e).getFloat64(t),
            put: (e, t, r) => (i(e).setFloat64(t, r), t + 8),
          }),
          (t.Float64_LE = {
            len: 8,
            get: (e, t) => i(e).getFloat64(t, !0),
            put: (e, t, r) => (i(e).setFloat64(t, r, !0), t + 8),
          }),
          (t.Float80_BE = {
            len: 10,
            get(e, t) {
              return n.read(e, t, !1, 63, this.len);
            },
            put(e, t, r) {
              return n.write(e, r, t, !1, 63, this.len), t + this.len;
            },
          }),
          (t.Float80_LE = {
            len: 10,
            get(e, t) {
              return n.read(e, t, !0, 63, this.len);
            },
            put(e, t, r) {
              return n.write(e, r, t, !0, 63, this.len), t + this.len;
            },
          }),
          (t.IgnoreType = class {
            constructor(e) {
              this.len = e;
            }
            get(e, t) {}
          }),
          (t.Uint8ArrayType = class {
            constructor(e) {
              this.len = e;
            }
            get(e, t) {
              return e.subarray(t, t + this.len);
            }
          }),
          (t.BufferType = class {
            constructor(e) {
              this.len = e;
            }
            get(e, t) {
              return Buffer.from(e.subarray(t, t + this.len));
            }
          }),
          (t.StringType = class {
            constructor(e, t) {
              (this.len = e), (this.encoding = t);
            }
            get(e, t) {
              return Buffer.from(e).toString(this.encoding, t, t + this.len);
            }
          });
        class o {
          constructor(e) {
            this.len = e;
          }
          static decode(e, t, r) {
            let n = "";
            for (let i = t; i < r; ++i)
              n += o.codePointToString(o.singleByteDecoder(e[i]));
            return n;
          }
          static inRange(e, t, r) {
            return t <= e && e <= r;
          }
          static codePointToString(e) {
            return e <= 65535
              ? String.fromCharCode(e)
              : ((e -= 65536),
                String.fromCharCode(55296 + (e >> 10), 56320 + (1023 & e)));
          }
          static singleByteDecoder(e) {
            if (o.inRange(e, 0, 127)) return e;
            const t = o.windows1252[e - 128];
            if (null === t) throw Error("invaliding encoding");
            return t;
          }
          get(e, t = 0) {
            return o.decode(e, t, t + this.len);
          }
        }
        (t.AnsiStringType = o),
          (o.windows1252 = [
            8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249,
            338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212,
            732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164,
            165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
            178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
            191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
            204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
            217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
            230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,
            243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
          ]);
      },
      2806: (e, t, r) => {
        const n =
            "win32" === process.platform ||
            "cygwin" === process.env.OSTYPE ||
            "msys" === process.env.OSTYPE,
          i = r(1017),
          o = n ? ";" : ":",
          s = r(1959),
          a = (e) =>
            Object.assign(new Error(`not found: ${e}`), { code: "ENOENT" }),
          c = (e, t) => {
            const r = t.colon || o,
              i =
                e.match(/\//) || (n && e.match(/\\/))
                  ? [""]
                  : [
                      ...(n ? [process.cwd()] : []),
                      ...(t.path || process.env.PATH || "").split(r),
                    ],
              s = n
                ? t.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM"
                : "",
              a = n ? s.split(r) : [""];
            return (
              n && -1 !== e.indexOf(".") && "" !== a[0] && a.unshift(""),
              { pathEnv: i, pathExt: a, pathExtExe: s }
            );
          },
          u = (e, t, r) => {
            "function" == typeof t && ((r = t), (t = {})), t || (t = {});
            const { pathEnv: n, pathExt: o, pathExtExe: u } = c(e, t),
              l = [],
              d = (r) =>
                new Promise((o, s) => {
                  if (r === n.length) return t.all && l.length ? o(l) : s(a(e));
                  const c = n[r],
                    u = /^".*"$/.test(c) ? c.slice(1, -1) : c,
                    d = i.join(u, e),
                    f = !u && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + d : d;
                  o(p(f, r, 0));
                }),
              p = (e, r, n) =>
                new Promise((i, a) => {
                  if (n === o.length) return i(d(r + 1));
                  const c = o[n];
                  s(e + c, { pathExt: u }, (o, s) => {
                    if (!o && s) {
                      if (!t.all) return i(e + c);
                      l.push(e + c);
                    }
                    return i(p(e, r, n + 1));
                  });
                });
            return r ? d(0).then((e) => r(null, e), r) : d(0);
          };
        (e.exports = u),
          (u.sync = (e, t) => {
            t = t || {};
            const { pathEnv: r, pathExt: n, pathExtExe: o } = c(e, t),
              u = [];
            for (let a = 0; a < r.length; a++) {
              const c = r[a],
                l = /^".*"$/.test(c) ? c.slice(1, -1) : c,
                d = i.join(l, e),
                p = !l && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + d : d;
              for (let e = 0; e < n.length; e++) {
                const r = p + n[e];
                try {
                  if (s.sync(r, { pathExt: o })) {
                    if (!t.all) return r;
                    u.push(r);
                  }
                } catch (e) {}
              }
            }
            if (t.all && u.length) return u;
            if (t.nothrow) return null;
            throw a(e);
          });
      },
      2479: (e) => {
        e.exports = function e(t, r) {
          if (t && r) return e(t)(r);
          if ("function" != typeof t)
            throw new TypeError("need wrapper function");
          return (
            Object.keys(t).forEach(function (e) {
              n[e] = t[e];
            }),
            n
          );
          function n() {
            for (var e = new Array(arguments.length), r = 0; r < e.length; r++)
              e[r] = arguments[r];
            var n = t.apply(this, e),
              i = e[e.length - 1];
            return (
              "function" == typeof n &&
                n !== i &&
                Object.keys(i).forEach(function (e) {
                  n[e] = i[e];
                }),
              n
            );
          }
        };
      },
      4944: (e, t, r) => {
        "use strict";
        e.exports = r.p + "114c557480b501ad0853.json";
      },
      9491: (e) => {
        "use strict";
        e.exports = require("assert");
      },
      4300: (e) => {
        "use strict";
        e.exports = require("buffer");
      },
      2081: (e) => {
        "use strict";
        e.exports = require("child_process");
      },
      2057: (e) => {
        "use strict";
        e.exports = require("constants");
      },
      2361: (e) => {
        "use strict";
        e.exports = require("events");
      },
      7147: (e) => {
        "use strict";
        e.exports = require("fs");
      },
      2254: (e) => {
        "use strict";
        e.exports = require("buffer");
      },
      7561: (e) => {
        "use strict";
        e.exports = require("fs");
      },
      9411: (e) => {
        "use strict";
        e.exports = require("path");
      },
      7742: (e) => {
        "use strict";
        e.exports = require("process");
      },
      1041: (e) => {
        "use strict";
        e.exports = require("url");
      },
      2037: (e) => {
        "use strict";
        e.exports = require("os");
      },
      1017: (e) => {
        "use strict";
        e.exports = require("path");
      },
      2781: (e) => {
        "use strict";
        e.exports = require("stream");
      },
      7310: (e) => {
        "use strict";
        e.exports = require("url");
      },
      3837: (e) => {
        "use strict";
        e.exports = require("util");
      },
      2172: (e, t, r) => {
        "use strict";
        r.r(t), r.d(t, { default: () => Z });
        var n = r(2254),
          i = r(9411);
        const o = require("child_process");
        var s = r(7742),
          a = r(8309),
          c = r(1041);
        function u(e = {}) {
          const { env: t = process.env, platform: r = process.platform } = e;
          return "win32" !== r
            ? "PATH"
            : Object.keys(t)
                .reverse()
                .find((e) => "PATH" === e.toUpperCase()) || "Path";
        }
        const l = (e, t, r, n) => {
            if ("length" === r || "prototype" === r) return;
            if ("arguments" === r || "caller" === r) return;
            const i = Object.getOwnPropertyDescriptor(e, r),
              o = Object.getOwnPropertyDescriptor(t, r);
            (!d(i, o) && n) || Object.defineProperty(e, r, o);
          },
          d = function (e, t) {
            return (
              void 0 === e ||
              e.configurable ||
              (e.writable === t.writable &&
                e.enumerable === t.enumerable &&
                e.configurable === t.configurable &&
                (e.writable || e.value === t.value))
            );
          },
          p = (e, t) => `/* Wrapped ${e}*/\n${t}`,
          f = Object.getOwnPropertyDescriptor(Function.prototype, "toString"),
          m = Object.getOwnPropertyDescriptor(
            Function.prototype.toString,
            "name"
          );
        const h = new WeakMap(),
          g = (e, t = {}) => {
            if ("function" != typeof e)
              throw new TypeError("Expected a function");
            let r,
              n = 0;
            const i = e.displayName || e.name || "<anonymous>",
              o = function (...s) {
                if ((h.set(o, ++n), 1 === n))
                  (r = e.apply(this, s)), (e = null);
                else if (!0 === t.throw)
                  throw new Error(`Function \`${i}\` can only be called once`);
                return r;
              };
            return (
              (function (e, t, { ignoreNonConfigurable: r = !1 } = {}) {
                const { name: n } = e;
                for (const n of Reflect.ownKeys(t)) l(e, t, n, r);
                ((e, t) => {
                  const r = Object.getPrototypeOf(t);
                  r !== Object.getPrototypeOf(e) && Object.setPrototypeOf(e, r);
                })(e, t),
                  ((e, t, r) => {
                    const n = "" === r ? "" : `with ${r.trim()}() `,
                      i = p.bind(null, n, t.toString());
                    Object.defineProperty(i, "name", m),
                      Object.defineProperty(e, "toString", { ...f, value: i });
                  })(e, t, n);
              })(o, e),
              h.set(o, n),
              o
            );
          };
        g.callCount = (e) => {
          if (!h.has(e))
            throw new Error(
              `The given function \`${e.name}\` is not wrapped by the \`onetime\` package`
            );
          return h.get(e);
        };
        const y = g;
        var b = r(2037);
        const _ = function (e, t) {
            return {
              name: `SIGRT${t + 1}`,
              number: v + t,
              action: "terminate",
              description: "Application-specific signal (realtime)",
              standard: "posix",
            };
          },
          v = 34,
          x = [
            {
              name: "SIGHUP",
              number: 1,
              action: "terminate",
              description: "Terminal closed",
              standard: "posix",
            },
            {
              name: "SIGINT",
              number: 2,
              action: "terminate",
              description: "User interruption with CTRL-C",
              standard: "ansi",
            },
            {
              name: "SIGQUIT",
              number: 3,
              action: "core",
              description: "User interruption with CTRL-\\",
              standard: "posix",
            },
            {
              name: "SIGILL",
              number: 4,
              action: "core",
              description: "Invalid machine instruction",
              standard: "ansi",
            },
            {
              name: "SIGTRAP",
              number: 5,
              action: "core",
              description: "Debugger breakpoint",
              standard: "posix",
            },
            {
              name: "SIGABRT",
              number: 6,
              action: "core",
              description: "Aborted",
              standard: "ansi",
            },
            {
              name: "SIGIOT",
              number: 6,
              action: "core",
              description: "Aborted",
              standard: "bsd",
            },
            {
              name: "SIGBUS",
              number: 7,
              action: "core",
              description:
                "Bus error due to misaligned, non-existing address or paging error",
              standard: "bsd",
            },
            {
              name: "SIGEMT",
              number: 7,
              action: "terminate",
              description: "Command should be emulated but is not implemented",
              standard: "other",
            },
            {
              name: "SIGFPE",
              number: 8,
              action: "core",
              description: "Floating point arithmetic error",
              standard: "ansi",
            },
            {
              name: "SIGKILL",
              number: 9,
              action: "terminate",
              description: "Forced termination",
              standard: "posix",
              forced: !0,
            },
            {
              name: "SIGUSR1",
              number: 10,
              action: "terminate",
              description: "Application-specific signal",
              standard: "posix",
            },
            {
              name: "SIGSEGV",
              number: 11,
              action: "core",
              description: "Segmentation fault",
              standard: "ansi",
            },
            {
              name: "SIGUSR2",
              number: 12,
              action: "terminate",
              description: "Application-specific signal",
              standard: "posix",
            },
            {
              name: "SIGPIPE",
              number: 13,
              action: "terminate",
              description: "Broken pipe or socket",
              standard: "posix",
            },
            {
              name: "SIGALRM",
              number: 14,
              action: "terminate",
              description: "Timeout or timer",
              standard: "posix",
            },
            {
              name: "SIGTERM",
              number: 15,
              action: "terminate",
              description: "Termination",
              standard: "ansi",
            },
            {
              name: "SIGSTKFLT",
              number: 16,
              action: "terminate",
              description: "Stack is empty or overflowed",
              standard: "other",
            },
            {
              name: "SIGCHLD",
              number: 17,
              action: "ignore",
              description: "Child process terminated, paused or unpaused",
              standard: "posix",
            },
            {
              name: "SIGCLD",
              number: 17,
              action: "ignore",
              description: "Child process terminated, paused or unpaused",
              standard: "other",
            },
            {
              name: "SIGCONT",
              number: 18,
              action: "unpause",
              description: "Unpaused",
              standard: "posix",
              forced: !0,
            },
            {
              name: "SIGSTOP",
              number: 19,
              action: "pause",
              description: "Paused",
              standard: "posix",
              forced: !0,
            },
            {
              name: "SIGTSTP",
              number: 20,
              action: "pause",
              description: 'Paused using CTRL-Z or "suspend"',
              standard: "posix",
            },
            {
              name: "SIGTTIN",
              number: 21,
              action: "pause",
              description: "Background process cannot read terminal input",
              standard: "posix",
            },
            {
              name: "SIGBREAK",
              number: 21,
              action: "terminate",
              description: "User interruption with CTRL-BREAK",
              standard: "other",
            },
            {
              name: "SIGTTOU",
              number: 22,
              action: "pause",
              description: "Background process cannot write to terminal output",
              standard: "posix",
            },
            {
              name: "SIGURG",
              number: 23,
              action: "ignore",
              description: "Socket received out-of-band data",
              standard: "bsd",
            },
            {
              name: "SIGXCPU",
              number: 24,
              action: "core",
              description: "Process timed out",
              standard: "bsd",
            },
            {
              name: "SIGXFSZ",
              number: 25,
              action: "core",
              description: "File too big",
              standard: "bsd",
            },
            {
              name: "SIGVTALRM",
              number: 26,
              action: "terminate",
              description: "Timeout or timer",
              standard: "bsd",
            },
            {
              name: "SIGPROF",
              number: 27,
              action: "terminate",
              description: "Timeout or timer",
              standard: "bsd",
            },
            {
              name: "SIGWINCH",
              number: 28,
              action: "ignore",
              description: "Terminal window size changed",
              standard: "bsd",
            },
            {
              name: "SIGIO",
              number: 29,
              action: "terminate",
              description: "I/O is available",
              standard: "other",
            },
            {
              name: "SIGPOLL",
              number: 29,
              action: "terminate",
              description: "Watched event",
              standard: "other",
            },
            {
              name: "SIGINFO",
              number: 29,
              action: "ignore",
              description: "Request for process information",
              standard: "other",
            },
            {
              name: "SIGPWR",
              number: 30,
              action: "terminate",
              description: "Device running out of power",
              standard: "systemv",
            },
            {
              name: "SIGSYS",
              number: 31,
              action: "core",
              description: "Invalid system call",
              standard: "other",
            },
            {
              name: "SIGUNUSED",
              number: 31,
              action: "terminate",
              description: "Invalid system call",
              standard: "other",
            },
          ],
          S = function () {
            const e = (function () {
              const e = 64 - v + 1;
              return Array.from({ length: e }, _);
            })();
            return [...x, ...e].map(E);
          },
          E = function ({
            name: e,
            number: t,
            description: r,
            action: n,
            forced: i = !1,
            standard: o,
          }) {
            const {
                signals: { [e]: s },
              } = b.constants,
              a = void 0 !== s;
            return {
              name: e,
              number: a ? s : t,
              description: r,
              supported: a,
              action: n,
              forced: i,
              standard: o,
            };
          },
          w = S().reduce(function (
            e,
            {
              name: t,
              number: r,
              description: n,
              supported: i,
              action: o,
              forced: s,
              standard: a,
            }
          ) {
            return {
              ...e,
              [t]: {
                name: t,
                number: r,
                description: n,
                supported: i,
                action: o,
                forced: s,
                standard: a,
              },
            };
          },
          {}),
          A = function (e, t) {
            const r = t.find(({ name: t }) => b.constants.signals[t] === e);
            return void 0 !== r ? r : t.find((t) => t.number === e);
          },
          O =
            ((function () {
              const e = S(),
                t = Array.from({ length: 65 }, (t, r) =>
                  (function (e, t) {
                    const r = A(e, t);
                    if (void 0 === r) return {};
                    const {
                      name: n,
                      description: i,
                      supported: o,
                      action: s,
                      forced: a,
                      standard: c,
                    } = r;
                    return {
                      [e]: {
                        name: n,
                        number: e,
                        description: i,
                        supported: o,
                        action: s,
                        forced: a,
                        standard: c,
                      },
                    };
                  })(r, e)
                );
              Object.assign({}, ...t);
            })(),
            ({
              stdout: e,
              stderr: t,
              all: r,
              error: n,
              signal: i,
              exitCode: o,
              command: s,
              escapedCommand: a,
              timedOut: c,
              isCanceled: u,
              killed: l,
              parsed: {
                options: { timeout: d },
              },
            }) => {
              o = null === o ? void 0 : o;
              const p =
                  void 0 === (i = null === i ? void 0 : i)
                    ? void 0
                    : w[i].description,
                f = (({
                  timedOut: e,
                  timeout: t,
                  errorCode: r,
                  signal: n,
                  signalDescription: i,
                  exitCode: o,
                  isCanceled: s,
                }) =>
                  e
                    ? `timed out after ${t} milliseconds`
                    : s
                    ? "was canceled"
                    : void 0 !== r
                    ? `failed with ${r}`
                    : void 0 !== n
                    ? `was killed with ${n} (${i})`
                    : void 0 !== o
                    ? `failed with exit code ${o}`
                    : "failed")({
                  timedOut: c,
                  timeout: d,
                  errorCode: n && n.code,
                  signal: i,
                  signalDescription: p,
                  exitCode: o,
                  isCanceled: u,
                }),
                m = `Command ${f}: ${s}`,
                h = "[object Error]" === Object.prototype.toString.call(n),
                g = h ? `${m}\n${n.message}` : m,
                y = [g, t, e].filter(Boolean).join("\n");
              return (
                h
                  ? ((n.originalMessage = n.message), (n.message = y))
                  : (n = new Error(y)),
                (n.shortMessage = g),
                (n.command = s),
                (n.escapedCommand = a),
                (n.exitCode = o),
                (n.signal = i),
                (n.signalDescription = p),
                (n.stdout = e),
                (n.stderr = t),
                void 0 !== r && (n.all = r),
                "bufferedData" in n && delete n.bufferedData,
                (n.failed = !0),
                (n.timedOut = Boolean(c)),
                (n.isCanceled = u),
                (n.killed = l && !c),
                n
              );
            }),
          P = ["stdin", "stdout", "stderr"],
          $ = require("os");
        var T = r(7908);
        const k = (e, t = "SIGTERM", r = {}) => {
            const n = e(t);
            return R(e, t, r, n), n;
          },
          R = (e, t, r, n) => {
            if (!j(t, r, n)) return;
            const i = L(r),
              o = setTimeout(() => {
                e("SIGKILL");
              }, i);
            o.unref && o.unref();
          },
          j = (e, { forceKillAfterTimeout: t }, r) => I(e) && !1 !== t && r,
          I = (e) =>
            e === $.constants.signals.SIGTERM ||
            ("string" == typeof e && "SIGTERM" === e.toUpperCase()),
          L = ({ forceKillAfterTimeout: e = !0 }) => {
            if (!0 === e) return 5e3;
            if (!Number.isFinite(e) || e < 0)
              throw new TypeError(
                `Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`
              );
            return e;
          },
          C = (e, t) => {
            e.kill() && (t.isCanceled = !0);
          };
        var M = r(31),
          B = r(4034);
        const N = async (e, t) => {
            if (e) {
              e.destroy();
              try {
                return await t;
              } catch (e) {
                return e.bufferedData;
              }
            }
          },
          F = (e, { encoding: t, buffer: r, maxBuffer: n }) => {
            if (e && r)
              return t
                ? M(e, { encoding: t, maxBuffer: n })
                : M.buffer(e, { maxBuffer: n });
          },
          D = (async () => {})().constructor.prototype,
          H = ["then", "catch", "finally"].map((e) => [
            e,
            Reflect.getOwnPropertyDescriptor(D, e),
          ]),
          U = (e, t) => {
            for (const [r, n] of H) {
              const i =
                "function" == typeof t
                  ? (...e) => Reflect.apply(n.value, t(), e)
                  : n.value.bind(t);
              Reflect.defineProperty(e, r, { ...n, value: i });
            }
            return e;
          },
          G = (e, t = []) => (Array.isArray(t) ? [e, ...t] : [e]),
          V = /^[\w.-]+$/,
          z = /"/g,
          q = (e, t, r = {}) => {
            const n = a._parse(e, t, r);
            return (
              (e = n.command),
              (t = n.args),
              ((r = {
                maxBuffer: 1e8,
                buffer: !0,
                stripFinalNewline: !0,
                extendEnv: !0,
                preferLocal: !1,
                localDir: (r = n.options).cwd || s.cwd(),
                execPath: s.execPath,
                encoding: "utf8",
                reject: !0,
                cleanup: !0,
                all: !1,
                windowsHide: !0,
                ...r,
              }).env = (({
                env: e,
                extendEnv: t,
                preferLocal: r,
                localDir: n,
                execPath: o,
              }) => {
                const a = t ? { ...s.env, ...e } : e;
                return r
                  ? (function ({ env: e = s.env, ...t } = {}) {
                      const r = u({ env: (e = { ...e }) });
                      return (
                        (t.path = e[r]),
                        (e[r] = (function (e = {}) {
                          const {
                            cwd: t = s.cwd(),
                            path: r = s.env[u()],
                            execPath: n = s.execPath,
                          } = e;
                          let o;
                          const a = t instanceof URL ? c.fileURLToPath(t) : t;
                          let l = i.resolve(a);
                          const d = [];
                          for (; o !== l; )
                            d.push(i.join(l, "node_modules/.bin")),
                              (o = l),
                              (l = i.resolve(l, ".."));
                          return (
                            d.push(i.resolve(a, n, "..")),
                            [...d, r].join(i.delimiter)
                          );
                        })(t)),
                        e
                      );
                    })({ env: a, cwd: n, execPath: o })
                  : a;
              })(r)),
              (r.stdio = ((e) => {
                if (!e) return;
                const { stdio: t } = e;
                if (void 0 === t) return P.map((t) => e[t]);
                if (((e) => P.some((t) => void 0 !== e[t]))(e))
                  throw new Error(
                    `It's not possible to provide \`stdio\` in combination with one of ${P.map(
                      (e) => `\`${e}\``
                    ).join(", ")}`
                  );
                if ("string" == typeof t) return t;
                if (!Array.isArray(t))
                  throw new TypeError(
                    `Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``
                  );
                const r = Math.max(t.length, P.length);
                return Array.from({ length: r }, (e, r) => t[r]);
              })(r)),
              "win32" === s.platform &&
                "cmd" === i.basename(e, ".exe") &&
                t.unshift("/q"),
              { file: e, args: t, options: r, parsed: n }
            );
          },
          W = (e, t, r) =>
            "string" == typeof t || n.Buffer.isBuffer(t)
              ? e.stripFinalNewline
                ? (function (e) {
                    const t = "string" == typeof e ? "\n" : "\n".charCodeAt(),
                      r = "string" == typeof e ? "\r" : "\r".charCodeAt();
                    return (
                      e[e.length - 1] === t && (e = e.slice(0, -1)),
                      e[e.length - 1] === r && (e = e.slice(0, -1)),
                      e
                    );
                  })(t)
                : t
              : void 0 === r
              ? void 0
              : "";
        function K(e, t, r) {
          const n = q(e, t, r),
            i = ((e, t) => G(e, t).join(" "))(e, t),
            s = ((e, t) =>
              G(e, t)
                .map((e) =>
                  ((e) =>
                    "string" != typeof e || V.test(e)
                      ? e
                      : `"${e.replace(z, '\\"')}"`)(e)
                )
                .join(" "))(e, t);
          let a;
          (({ timeout: e }) => {
            if (void 0 !== e && (!Number.isFinite(e) || e < 0))
              throw new TypeError(
                `Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`
              );
          })(n.options);
          try {
            a = o.spawn(n.file, n.args, n.options);
          } catch (e) {
            const t = new o.ChildProcess(),
              r = Promise.reject(
                O({
                  error: e,
                  stdout: "",
                  stderr: "",
                  all: "",
                  command: i,
                  escapedCommand: s,
                  parsed: n,
                  timedOut: !1,
                  isCanceled: !1,
                  killed: !1,
                })
              );
            return U(t, r);
          }
          const c = ((e) =>
              new Promise((t, r) => {
                e.on("exit", (e, r) => {
                  t({ exitCode: e, signal: r });
                }),
                  e.on("error", (e) => {
                    r(e);
                  }),
                  e.stdin &&
                    e.stdin.on("error", (e) => {
                      r(e);
                    });
              }))(a),
            u = ((e, { timeout: t, killSignal: r = "SIGTERM" }, n) => {
              if (0 === t || void 0 === t) return n;
              let i;
              const o = new Promise((n, o) => {
                  i = setTimeout(() => {
                    ((e, t, r) => {
                      e.kill(t),
                        r(
                          Object.assign(new Error("Timed out"), {
                            timedOut: !0,
                            signal: t,
                          })
                        );
                    })(e, r, o);
                  }, t);
                }),
                s = n.finally(() => {
                  clearTimeout(i);
                });
              return Promise.race([o, s]);
            })(a, n.options, c),
            l = (async (e, { cleanup: t, detached: r }, n) => {
              if (!t || r) return n;
              const i = T(() => {
                e.kill();
              });
              return n.finally(() => {
                i();
              });
            })(a, n.options, u),
            d = { isCanceled: !1 };
          (a.kill = k.bind(null, a.kill.bind(a))),
            (a.cancel = C.bind(null, a, d));
          const p = y(async () => {
            const [{ error: e, exitCode: t, signal: r, timedOut: o }, c, u, p] =
                await (async (
                  { stdout: e, stderr: t, all: r },
                  { encoding: n, buffer: i, maxBuffer: o },
                  s
                ) => {
                  const a = F(e, { encoding: n, buffer: i, maxBuffer: o }),
                    c = F(t, { encoding: n, buffer: i, maxBuffer: o }),
                    u = F(r, { encoding: n, buffer: i, maxBuffer: 2 * o });
                  try {
                    return await Promise.all([s, a, c, u]);
                  } catch (n) {
                    return Promise.all([
                      { error: n, signal: n.signal, timedOut: n.timedOut },
                      N(e, a),
                      N(t, c),
                      N(r, u),
                    ]);
                  }
                })(a, n.options, l),
              f = W(n.options, c),
              m = W(n.options, u),
              h = W(n.options, p);
            if (e || 0 !== t || null !== r) {
              const c = O({
                error: e,
                exitCode: t,
                signal: r,
                stdout: f,
                stderr: m,
                all: h,
                command: i,
                escapedCommand: s,
                parsed: n,
                timedOut: o,
                isCanceled:
                  d.isCanceled ||
                  (!!n.options.signal && n.options.signal.aborted),
                killed: a.killed,
              });
              if (!n.options.reject) return c;
              throw c;
            }
            return {
              command: i,
              escapedCommand: s,
              exitCode: 0,
              stdout: f,
              stderr: m,
              all: h,
              failed: !1,
              timedOut: !1,
              isCanceled: !1,
              killed: !1,
            };
          });
          return (
            ((e, t) => {
              var r;
              void 0 !== t &&
                void 0 !== e.stdin &&
                (null !== (r = t) &&
                "object" == typeof r &&
                "function" == typeof r.pipe
                  ? t.pipe(e.stdin)
                  : e.stdin.end(t));
            })(a, n.options.input),
            (a.all = ((e, { all: t }) => {
              if (!t || (!e.stdout && !e.stderr)) return;
              const r = B();
              return (
                e.stdout && r.add(e.stdout), e.stderr && r.add(e.stderr), r
              );
            })(a, n.options)),
            U(a, p)
          );
        }
        var Q = r(7561),
          Y = r(561);
        const X = `https://raw.githubusercontent.com/imagemin/mozjpeg-bin/v${
            JSON.parse(Q.readFileSync(new URL(r(4944), r.b))).version
          }/vendor/`,
          J = new Y()
            .src(`${X}macos/cjpeg`, "darwin")
            .src(`${X}linux/cjpeg`, "linux")
            .src(`${X}win/cjpeg.exe`, "win32")
            .dest(
              (0, c.fileURLToPath)(
                new URL(
                  "../vendor",
                  "file:///C:/Users/Admin/.CocosCreator/extensions/simple-test/node_modules/mozjpeg/lib/index.js"
                )
              )
            )
            .use("win32" === s.platform ? "cjpeg.exe" : "cjpeg")
            .path(),
          Z = (e) => async (t) => {
            if (
              ((e = { trellis: !0, trellisDC: !0, overshoot: !0, ...e }),
              !n.Buffer.isBuffer(t))
            )
              return Promise.reject(new TypeError("Expected a buffer"));
            if (
              !(function (e) {
                return (
                  !(!e || e.length < 3) &&
                  255 === e[0] &&
                  216 === e[1] &&
                  255 === e[2]
                );
              })(t)
            )
              return Promise.resolve(t);
            if (e.fastcrush)
              return Promise.reject(
                new Error("Option `fastcrush` was renamed to `fastCrush`")
              );
            if (e.maxmemory)
              return Promise.reject(
                new Error("Option `maxmemory` was renamed to `maxMemory`")
              );
            if (e.notrellis)
              return Promise.reject(
                new Error(
                  "Option `notrellis` was renamed to `trellis` and inverted"
                )
              );
            if (e.noovershoot)
              return Promise.reject(
                new Error(
                  "Option `noovershoot` was renamed to `overshoot` and inverted"
                )
              );
            const r = [];
            void 0 !== e.quality && r.push("-quality", e.quality),
              !1 === e.progressive && r.push("-baseline"),
              e.targa && r.push("-targa"),
              e.revert && r.push("-revert"),
              e.fastCrush && r.push("-fastcrush"),
              void 0 !== e.dcScanOpt && r.push("-dc-scan-opt", e.dcScanOpt),
              e.trellis || r.push("-notrellis"),
              e.trellisDC || r.push("-notrellis-dc"),
              e.tune && r.push(`-tune-${e.tune}`),
              e.overshoot || r.push("-noovershoot"),
              e.arithmetic && r.push("-arithmetic"),
              e.dct && r.push("-dct", e.dct),
              e.quantBaseline && r.push("-quant-baseline", e.quantBaseline),
              void 0 !== e.quantTable && r.push("-quant-table", e.quantTable),
              e.smooth && r.push("-smooth", e.smooth),
              e.maxMemory && r.push("-maxmemory", e.maxMemory),
              e.sample && r.push("-sample", e.sample.join(","));
            const { stdout: i } = await K(J, r, {
              encoding: null,
              input: t,
              maxBuffer: Number.POSITIVE_INFINITY,
            });
            return i;
          };
      },
      9689: (e, t, r) => {
        "use strict";
        r.r(t), r.d(t, { default: () => T });
        var n = r(2254),
          i = r(7561);
        const o = require("util");
        var s = r(9411),
          a = r(77),
          c = r(7769);
        const u = (...e) => [...new Set(e.flat())];
        r(155);
        var l = r(3294),
          d = r(367),
          p = r(1041);
        const f = (e) =>
          e
            ? (e instanceof URL && (e = e.href),
              e.startsWith("file://") ? (0, p.fileURLToPath)(e) : e)
            : e;
        var m = r(7742),
          h = r(5151);
        function g(e) {
          const t = /^\\\\\?\\/.test(e),
            r = /[^\u0000-\u0080]+/.test(e);
          return t || r ? e : e.replace(/\\/g, "/");
        }
        const y = [
            "**/node_modules/**",
            "**/flow-typed/**",
            "**/coverage/**",
            "**/.git",
          ],
          b = (e, t) => {
            const r = g(s.relative(t.cwd, s.dirname(t.fileName)));
            return e
              .split(/\r?\n/)
              .filter(Boolean)
              .filter((e) => !e.startsWith("#"))
              .map(
                (
                  (e) => (t) =>
                    t.startsWith("!")
                      ? "!" + s.posix.join(e, t.slice(1))
                      : s.posix.join(e, t)
                )(r)
              );
          },
          _ = async (e) => {
            e = (({ ignore: e = [], cwd: t = g(m.cwd()) } = {}) => ({
              ignore: [...y, ...e],
              cwd: f(t),
            }))(e);
            const t = await l("**/.gitignore", e),
              r = ((e) => {
                const t = h();
                for (const r of e)
                  t.add(b(r.content, { cwd: r.cwd, fileName: r.filePath }));
                return t;
              })(
                await Promise.all(
                  t.map((t) =>
                    (async (e, t) => {
                      const r = s.join(t, e);
                      return {
                        cwd: t,
                        filePath: r,
                        content: await i.promises.readFile(r, "utf8"),
                      };
                    })(t, e.cwd)
                  )
                )
              );
            return (
              (e, t) => (r) =>
                e.ignores(
                  g(
                    s.relative(
                      t,
                      ((e, t) => {
                        if (((e = g(e)), s.isAbsolute(t))) {
                          if (g(t).startsWith(e)) return t;
                          throw new Error(`Path ${t} is not in cwd ${e}`);
                        }
                        return s.join(e, t);
                      })(t, f(r.path || r))
                    )
                  )
                )
            )(r, e.cwd);
          };
        require("stream");
        const v = () => !1,
          x = (e) => "!" === e[0],
          S = async (e, t) => {
            const r = ((e, t = {}) => {
                ((e) => {
                  if (!e.every((e) => "string" == typeof e))
                    throw new TypeError(
                      "Patterns must be a string or an array of strings"
                    );
                })((e = u([e].flat())));
                const r = [];
                ((e) => {
                  if (!e.cwd) return;
                  let t;
                  try {
                    t = i.statSync(e.cwd);
                  } catch {
                    return;
                  }
                  if (!t.isDirectory())
                    throw new Error(
                      "The `cwd` option must be a path to a directory"
                    );
                })(
                  (t = {
                    ignore: [],
                    expandDirectories: !0,
                    ...t,
                    cwd: f(t.cwd),
                  })
                );
                for (const [n, i] of e.entries()) {
                  if (x(i)) continue;
                  const o = e
                      .slice(n)
                      .filter((e) => x(e))
                      .map((e) => e.slice(1)),
                    s = { ...t, ignore: [...t.ignore, ...o] };
                  r.push({ pattern: i, options: s });
                }
                return r;
              })(e, t),
              [n, o] = await Promise.all([
                (async () =>
                  t && t.gitignore ? _({ cwd: t.cwd, ignore: t.ignore }) : v)(),
                (async () => {
                  const e = await Promise.all(
                    r.map(async (e) => {
                      const t = await ((e, t) =>
                        e.options.expandDirectories
                          ? ((e, t) => {
                              let r = {};
                              return (
                                e.options.cwd && (r.cwd = e.options.cwd),
                                Array.isArray(e.options.expandDirectories)
                                  ? (r = {
                                      ...r,
                                      files: e.options.expandDirectories,
                                    })
                                  : "object" ==
                                      typeof e.options.expandDirectories &&
                                    (r = {
                                      ...r,
                                      ...e.options.expandDirectories,
                                    }),
                                t(e.pattern, r)
                              );
                            })(e, t)
                          : [e.pattern])(e, d);
                      return Promise.all(
                        t.map(
                          ((e) => async (t) => {
                            const { options: r } = e;
                            return (
                              r.ignore &&
                                Array.isArray(r.ignore) &&
                                r.expandDirectories &&
                                (r.ignore = await d(r.ignore)),
                              { pattern: t, options: r }
                            );
                          })(e)
                        )
                      );
                    })
                  );
                  return u(...e);
                })(),
              ]),
              s = await Promise.all(o.map((e) => l(e.pattern, e.options)));
            return u(...s).filter((e) => {
              return !n(((t = e), t.stats instanceof i.Stats ? t.path : t));
              var t;
            });
          };
        function E(...e) {
          if (0 === e.length) throw new Error("Expected at least one argument");
          return async (t) => {
            let r = t;
            for (const t of e) r = await t(r);
            return r;
          };
        }
        var w = r(8245),
          A = r(1351),
          O = r(3859);
        const P = (0, o.promisify)(a.readFile),
          $ = (0, o.promisify)(a.writeFile);
        async function T(e, { glob: t = !0, ...r } = {}) {
          if (!Array.isArray(e))
            throw new TypeError(`Expected an \`Array\`, got \`${typeof e}\``);
          const n = e.map((e) => O(e)),
            o = t ? await S(n, { onlyFiles: !0 }) : e;
          return Promise.all(
            o
              .filter((e) => A.not(s.basename(e)))
              .map(async (t) => {
                try {
                  return await (async (
                    e,
                    { destination: t, plugins: r = [] }
                  ) => {
                    if (r && !Array.isArray(r))
                      throw new TypeError(
                        "The `plugins` option should be an `Array`"
                      );
                    let n = await P(e);
                    n = await (r.length > 0 ? E(...r)(n) : n);
                    const { ext: o } = (await c.fromBuffer(n)) || {
                      ext: s.extname(e),
                    };
                    let a = t ? s.join(t, s.basename(e)) : void 0;
                    a = "webp" === o ? w(a, ".webp") : a;
                    const u = { data: n, sourcePath: e, destinationPath: a };
                    return a
                      ? (await i.promises.mkdir(s.dirname(u.destinationPath), {
                          recursive: !0,
                        }),
                        await $(u.destinationPath, u.data),
                        u)
                      : u;
                  })(t, r);
                } catch (t) {
                  throw (
                    ((t.message = `Error occurred when handling file: ${e}\n\n${t.stack}`),
                    t)
                  );
                }
              })
          );
        }
        T.buffer = async (e, { plugins: t = [] } = {}) => {
          if (!n.Buffer.isBuffer(e))
            throw new TypeError(`Expected a \`Buffer\`, got \`${typeof e}\``);
          return 0 === t.length ? e : E(...t)(e);
        };
      },
      9034: (e) => {
        "use strict";
        e.exports = JSON.parse(
          '{"name":"pngquant-bin","version":"6.0.1","description":"`pngquant` wrapper that makes it seamlessly available as a local dependency","license":"GPL-3.0+","repository":"imagemin/pngquant-bin","author":{"name":"Kevin MÃ¥rtensson","email":"kevinmartensson@gmail.com","url":"github.com/kevva"},"maintainers":[{"name":"Sindre Sorhus","email":"sindresorhus@gmail.com","url":"sindresorhus.com"},{"name":"Shinnosuke Watanabe","url":"github.com/shinnn"}],"bin":{"pngquant":"cli.js"},"engines":{"node":">=10"},"scripts":{"postinstall":"node lib/install.js","test":"xo && ava --timeout=120s"},"files":["cli.js","index.js","lib","vendor/source"],"keywords":["imagemin","compress","image","img","minify","optimize","png","pngquant"],"dependencies":{"bin-build":"^3.0.0","bin-wrapper":"^4.0.1","execa":"^4.0.0"},"devDependencies":{"ava":"^3.8.0","bin-check":"^4.0.1","compare-size":"^3.0.0","tempy":"^0.5.0","xo":"^0.30.0"}}'
        );
      },
    },
    __webpack_module_cache__ = {};
  function __webpack_require__(e) {
    var t = __webpack_module_cache__[e];
    if (void 0 !== t) return t.exports;
    var r = (__webpack_module_cache__[e] = { exports: {} });
    return (
      __webpack_modules__[e].call(r.exports, r, r.exports, __webpack_require__),
      r.exports
    );
  }
  (__webpack_require__.m = __webpack_modules__),
    (__webpack_require__.d = (e, t) => {
      for (var r in t)
        __webpack_require__.o(t, r) &&
          !__webpack_require__.o(e, r) &&
          Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
    }),
    (__webpack_require__.o = (e, t) =>
      Object.prototype.hasOwnProperty.call(e, t)),
    (__webpack_require__.r = (e) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (__webpack_require__.p = ""),
    (__webpack_require__.b = require("url").pathToFileURL(__filename));
  var __webpack_exports__ = __webpack_require__(2563);
  return __webpack_exports__
})();
